(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/array/from"), __esModule: true };
},{"core-js/library/fn/array/from":39}],2:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/get-iterator"), __esModule: true };
},{"core-js/library/fn/get-iterator":40}],3:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/map"), __esModule: true };
},{"core-js/library/fn/map":41}],4:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/number/epsilon"), __esModule: true };
},{"core-js/library/fn/number/epsilon":42}],5:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/object/assign"), __esModule: true };
},{"core-js/library/fn/object/assign":43}],6:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/object/create"), __esModule: true };
},{"core-js/library/fn/object/create":44}],7:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/object/define-properties"), __esModule: true };
},{"core-js/library/fn/object/define-properties":45}],8:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/object/define-property"), __esModule: true };
},{"core-js/library/fn/object/define-property":46}],9:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/object/freeze"), __esModule: true };
},{"core-js/library/fn/object/freeze":47}],10:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/object/get-own-property-descriptor"), __esModule: true };
},{"core-js/library/fn/object/get-own-property-descriptor":48}],11:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/object/keys"), __esModule: true };
},{"core-js/library/fn/object/keys":49}],12:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/object/set-prototype-of"), __esModule: true };
},{"core-js/library/fn/object/set-prototype-of":50}],13:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/set"), __esModule: true };
},{"core-js/library/fn/set":51}],14:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/string/from-code-point"), __esModule: true };
},{"core-js/library/fn/string/from-code-point":52}],15:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/symbol"), __esModule: true };
},{"core-js/library/fn/symbol":53}],16:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/symbol/iterator"), __esModule: true };
},{"core-js/library/fn/symbol/iterator":54}],17:[function(require,module,exports){
"use strict";

exports.__esModule = true;

exports.default = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};
},{}],18:[function(require,module,exports){
"use strict";

exports.__esModule = true;

var _defineProperty = require("../core-js/object/define-property");

var _defineProperty2 = _interopRequireDefault(_defineProperty);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      (0, _defineProperty2.default)(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();
},{"../core-js/object/define-property":8}],19:[function(require,module,exports){
"use strict";

exports.__esModule = true;

var _setPrototypeOf = require("../core-js/object/set-prototype-of");

var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);

var _create = require("../core-js/object/create");

var _create2 = _interopRequireDefault(_create);

var _typeof2 = require("../helpers/typeof");

var _typeof3 = _interopRequireDefault(_typeof2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : (0, _typeof3.default)(superClass)));
  }

  subClass.prototype = (0, _create2.default)(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf2.default ? (0, _setPrototypeOf2.default)(subClass, superClass) : subClass.__proto__ = superClass;
};
},{"../core-js/object/create":6,"../core-js/object/set-prototype-of":12,"../helpers/typeof":21}],20:[function(require,module,exports){
"use strict";

exports.__esModule = true;

var _typeof2 = require("../helpers/typeof");

var _typeof3 = _interopRequireDefault(_typeof2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && ((typeof call === "undefined" ? "undefined" : (0, _typeof3.default)(call)) === "object" || typeof call === "function") ? call : self;
};
},{"../helpers/typeof":21}],21:[function(require,module,exports){
"use strict";

exports.__esModule = true;

var _iterator = require("../core-js/symbol/iterator");

var _iterator2 = _interopRequireDefault(_iterator);

var _symbol = require("../core-js/symbol");

var _symbol2 = _interopRequireDefault(_symbol);

var _typeof = typeof _symbol2.default === "function" && typeof _iterator2.default === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? "symbol" : typeof obj; };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = typeof _symbol2.default === "function" && _typeof(_iterator2.default) === "symbol" ? function (obj) {
  return typeof obj === "undefined" ? "undefined" : _typeof(obj);
} : function (obj) {
  return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof(obj);
};
},{"../core-js/symbol":15,"../core-js/symbol/iterator":16}],22:[function(require,module,exports){
'use strict'

exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  var i
  for (i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(
      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)
    ))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}

},{}],23:[function(require,module,exports){
(function (Buffer){
/* global Blob, FileReader */

module.exports = function blobToBuffer (blob, cb) {
  if (typeof Blob === 'undefined' || !(blob instanceof Blob)) {
    throw new Error('first argument must be a Blob')
  }
  if (typeof cb !== 'function') {
    throw new Error('second argument must be a function')
  }

  var reader = new FileReader()

  function onLoadEnd (e) {
    reader.removeEventListener('loadend', onLoadEnd, false)
    if (e.error) cb(e.error)
    else cb(null, Buffer.from(reader.result))
  }

  reader.addEventListener('loadend', onLoadEnd, false)
  reader.readAsArrayBuffer(blob)
}

}).call(this,require("buffer").Buffer)
},{"buffer":37}],24:[function(require,module,exports){
/* Copyright 2013 Google Inc. All Rights Reserved.

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

   Bit reading helpers
*/

var BROTLI_READ_SIZE = 4096;
var BROTLI_IBUF_SIZE =  (2 * BROTLI_READ_SIZE + 32);
var BROTLI_IBUF_MASK =  (2 * BROTLI_READ_SIZE - 1);

var kBitMask = new Uint32Array([
  0, 1, 3, 7, 15, 31, 63, 127, 255, 511, 1023, 2047, 4095, 8191, 16383, 32767,
  65535, 131071, 262143, 524287, 1048575, 2097151, 4194303, 8388607, 16777215
]);

/* Input byte buffer, consist of a ringbuffer and a "slack" region where */
/* bytes from the start of the ringbuffer are copied. */
function BrotliBitReader(input) {
  this.buf_ = new Uint8Array(BROTLI_IBUF_SIZE);
  this.input_ = input;    /* input callback */
  
  this.reset();
}

BrotliBitReader.READ_SIZE = BROTLI_READ_SIZE;
BrotliBitReader.IBUF_MASK = BROTLI_IBUF_MASK;

BrotliBitReader.prototype.reset = function() {
  this.buf_ptr_ = 0;      /* next input will write here */
  this.val_ = 0;          /* pre-fetched bits */
  this.pos_ = 0;          /* byte position in stream */
  this.bit_pos_ = 0;      /* current bit-reading position in val_ */
  this.bit_end_pos_ = 0;  /* bit-reading end position from LSB of val_ */
  this.eos_ = 0;          /* input stream is finished */
  
  this.readMoreInput();
  for (var i = 0; i < 4; i++) {
    this.val_ |= this.buf_[this.pos_] << (8 * i);
    ++this.pos_;
  }
  
  return this.bit_end_pos_ > 0;
};

/* Fills up the input ringbuffer by calling the input callback.

   Does nothing if there are at least 32 bytes present after current position.

   Returns 0 if either:
    - the input callback returned an error, or
    - there is no more input and the position is past the end of the stream.

   After encountering the end of the input stream, 32 additional zero bytes are
   copied to the ringbuffer, therefore it is safe to call this function after
   every 32 bytes of input is read.
*/
BrotliBitReader.prototype.readMoreInput = function() {
  if (this.bit_end_pos_ > 256) {
    return;
  } else if (this.eos_) {
    if (this.bit_pos_ > this.bit_end_pos_)
      throw new Error('Unexpected end of input ' + this.bit_pos_ + ' ' + this.bit_end_pos_);
  } else {
    var dst = this.buf_ptr_;
    var bytes_read = this.input_.read(this.buf_, dst, BROTLI_READ_SIZE);
    if (bytes_read < 0) {
      throw new Error('Unexpected end of input');
    }
    
    if (bytes_read < BROTLI_READ_SIZE) {
      this.eos_ = 1;
      /* Store 32 bytes of zero after the stream end. */
      for (var p = 0; p < 32; p++)
        this.buf_[dst + bytes_read + p] = 0;
    }
    
    if (dst === 0) {
      /* Copy the head of the ringbuffer to the slack region. */
      for (var p = 0; p < 32; p++)
        this.buf_[(BROTLI_READ_SIZE << 1) + p] = this.buf_[p];

      this.buf_ptr_ = BROTLI_READ_SIZE;
    } else {
      this.buf_ptr_ = 0;
    }
    
    this.bit_end_pos_ += bytes_read << 3;
  }
};

/* Guarantees that there are at least 24 bits in the buffer. */
BrotliBitReader.prototype.fillBitWindow = function() {    
  while (this.bit_pos_ >= 8) {
    this.val_ >>>= 8;
    this.val_ |= this.buf_[this.pos_ & BROTLI_IBUF_MASK] << 24;
    ++this.pos_;
    this.bit_pos_ = this.bit_pos_ - 8 >>> 0;
    this.bit_end_pos_ = this.bit_end_pos_ - 8 >>> 0;
  }
};

/* Reads the specified number of bits from Read Buffer. */
BrotliBitReader.prototype.readBits = function(n_bits) {
  if (32 - this.bit_pos_ < n_bits) {
    this.fillBitWindow();
  }
  
  var val = ((this.val_ >>> this.bit_pos_) & kBitMask[n_bits]);
  this.bit_pos_ += n_bits;
  return val;
};

module.exports = BrotliBitReader;

},{}],25:[function(require,module,exports){
/* Copyright 2013 Google Inc. All Rights Reserved.

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

   Lookup table to map the previous two bytes to a context id.

   There are four different context modeling modes defined here:
     CONTEXT_LSB6: context id is the least significant 6 bits of the last byte,
     CONTEXT_MSB6: context id is the most significant 6 bits of the last byte,
     CONTEXT_UTF8: second-order context model tuned for UTF8-encoded text,
     CONTEXT_SIGNED: second-order context model tuned for signed integers.

   The context id for the UTF8 context model is calculated as follows. If p1
   and p2 are the previous two bytes, we calcualte the context as

     context = kContextLookup[p1] | kContextLookup[p2 + 256].

   If the previous two bytes are ASCII characters (i.e. < 128), this will be
   equivalent to

     context = 4 * context1(p1) + context2(p2),

   where context1 is based on the previous byte in the following way:

     0  : non-ASCII control
     1  : \t, \n, \r
     2  : space
     3  : other punctuation
     4  : " '
     5  : %
     6  : ( < [ {
     7  : ) > ] }
     8  : , ; :
     9  : .
     10 : =
     11 : number
     12 : upper-case vowel
     13 : upper-case consonant
     14 : lower-case vowel
     15 : lower-case consonant

   and context2 is based on the second last byte:

     0 : control, space
     1 : punctuation
     2 : upper-case letter, number
     3 : lower-case letter

   If the last byte is ASCII, and the second last byte is not (in a valid UTF8
   stream it will be a continuation byte, value between 128 and 191), the
   context is the same as if the second last byte was an ASCII control or space.

   If the last byte is a UTF8 lead byte (value >= 192), then the next byte will
   be a continuation byte and the context id is 2 or 3 depending on the LSB of
   the last byte and to a lesser extent on the second last byte if it is ASCII.

   If the last byte is a UTF8 continuation byte, the second last byte can be:
     - continuation byte: the next byte is probably ASCII or lead byte (assuming
       4-byte UTF8 characters are rare) and the context id is 0 or 1.
     - lead byte (192 - 207): next byte is ASCII or lead byte, context is 0 or 1
     - lead byte (208 - 255): next byte is continuation byte, context is 2 or 3

   The possible value combinations of the previous two bytes, the range of
   context ids and the type of the next byte is summarized in the table below:

   |--------\-----------------------------------------------------------------|
   |         \                         Last byte                              |
   | Second   \---------------------------------------------------------------|
   | last byte \    ASCII            |   cont. byte        |   lead byte      |
   |            \   (0-127)          |   (128-191)         |   (192-)         |
   |=============|===================|=====================|==================|
   |  ASCII      | next: ASCII/lead  |  not valid          |  next: cont.     |
   |  (0-127)    | context: 4 - 63   |                     |  context: 2 - 3  |
   |-------------|-------------------|---------------------|------------------|
   |  cont. byte | next: ASCII/lead  |  next: ASCII/lead   |  next: cont.     |
   |  (128-191)  | context: 4 - 63   |  context: 0 - 1     |  context: 2 - 3  |
   |-------------|-------------------|---------------------|------------------|
   |  lead byte  | not valid         |  next: ASCII/lead   |  not valid       |
   |  (192-207)  |                   |  context: 0 - 1     |                  |
   |-------------|-------------------|---------------------|------------------|
   |  lead byte  | not valid         |  next: cont.        |  not valid       |
   |  (208-)     |                   |  context: 2 - 3     |                  |
   |-------------|-------------------|---------------------|------------------|

   The context id for the signed context mode is calculated as:

     context = (kContextLookup[512 + p1] << 3) | kContextLookup[512 + p2].

   For any context modeling modes, the context ids can be calculated by |-ing
   together two lookups from one table using context model dependent offsets:

     context = kContextLookup[offset1 + p1] | kContextLookup[offset2 + p2].

   where offset1 and offset2 are dependent on the context mode.
*/

var CONTEXT_LSB6         = 0;
var CONTEXT_MSB6         = 1;
var CONTEXT_UTF8         = 2;
var CONTEXT_SIGNED       = 3;

/* Common context lookup table for all context modes. */
exports.lookup = new Uint8Array([
  /* CONTEXT_UTF8, last byte. */
  /* ASCII range. */
   0,  0,  0,  0,  0,  0,  0,  0,  0,  4,  4,  0,  0,  4,  0,  0,
   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
   8, 12, 16, 12, 12, 20, 12, 16, 24, 28, 12, 12, 32, 12, 36, 12,
  44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 32, 32, 24, 40, 28, 12,
  12, 48, 52, 52, 52, 48, 52, 52, 52, 48, 52, 52, 52, 52, 52, 48,
  52, 52, 52, 52, 52, 48, 52, 52, 52, 52, 52, 24, 12, 28, 12, 12,
  12, 56, 60, 60, 60, 56, 60, 60, 60, 56, 60, 60, 60, 60, 60, 56,
  60, 60, 60, 60, 60, 56, 60, 60, 60, 60, 60, 24, 12, 28, 12,  0,
  /* UTF8 continuation byte range. */
  0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,
  0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,
  0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,
  0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,
  /* UTF8 lead byte range. */
  2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3,
  2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3,
  2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3,
  2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3,
  /* CONTEXT_UTF8 second last byte. */
  /* ASCII range. */
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1,
  1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
  2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1,
  1, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
  3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 1, 1, 1, 1, 0,
  /* UTF8 continuation byte range. */
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  /* UTF8 lead byte range. */
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
  2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
  /* CONTEXT_SIGNED, second last byte. */
  0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
  2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
  2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
  3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
  3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
  3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
  3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
  4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
  4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
  4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
  4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
  5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
  5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
  5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7,
  /* CONTEXT_SIGNED, last byte, same as the above values shifted by 3 bits. */
   0, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
  24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
  24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
  24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
  24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
  32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
  32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
  32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
  32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
  40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40,
  40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40,
  40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40,
  48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 56,
  /* CONTEXT_LSB6, last byte. */
   0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15,
  16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,
  32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,
  48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63,
   0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15,
  16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,
  32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,
  48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63,
   0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15,
  16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,
  32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,
  48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63,
   0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15,
  16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,
  32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,
  48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63,
  /* CONTEXT_MSB6, last byte. */
   0,  0,  0,  0,  1,  1,  1,  1,  2,  2,  2,  2,  3,  3,  3,  3,
   4,  4,  4,  4,  5,  5,  5,  5,  6,  6,  6,  6,  7,  7,  7,  7,
   8,  8,  8,  8,  9,  9,  9,  9, 10, 10, 10, 10, 11, 11, 11, 11,
  12, 12, 12, 12, 13, 13, 13, 13, 14, 14, 14, 14, 15, 15, 15, 15,
  16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19,
  20, 20, 20, 20, 21, 21, 21, 21, 22, 22, 22, 22, 23, 23, 23, 23,
  24, 24, 24, 24, 25, 25, 25, 25, 26, 26, 26, 26, 27, 27, 27, 27,
  28, 28, 28, 28, 29, 29, 29, 29, 30, 30, 30, 30, 31, 31, 31, 31,
  32, 32, 32, 32, 33, 33, 33, 33, 34, 34, 34, 34, 35, 35, 35, 35,
  36, 36, 36, 36, 37, 37, 37, 37, 38, 38, 38, 38, 39, 39, 39, 39,
  40, 40, 40, 40, 41, 41, 41, 41, 42, 42, 42, 42, 43, 43, 43, 43,
  44, 44, 44, 44, 45, 45, 45, 45, 46, 46, 46, 46, 47, 47, 47, 47,
  48, 48, 48, 48, 49, 49, 49, 49, 50, 50, 50, 50, 51, 51, 51, 51,
  52, 52, 52, 52, 53, 53, 53, 53, 54, 54, 54, 54, 55, 55, 55, 55,
  56, 56, 56, 56, 57, 57, 57, 57, 58, 58, 58, 58, 59, 59, 59, 59,
  60, 60, 60, 60, 61, 61, 61, 61, 62, 62, 62, 62, 63, 63, 63, 63,
  /* CONTEXT_{M,L}SB6, second last byte, */
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
]);

exports.lookupOffsets = new Uint16Array([
  /* CONTEXT_LSB6 */
  1024, 1536,
  /* CONTEXT_MSB6 */
  1280, 1536,
  /* CONTEXT_UTF8 */
  0, 256,
  /* CONTEXT_SIGNED */
  768, 512,
]);

},{}],26:[function(require,module,exports){
/* Copyright 2013 Google Inc. All Rights Reserved.

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/

var BrotliInput = require('./streams').BrotliInput;
var BrotliOutput = require('./streams').BrotliOutput;
var BrotliBitReader = require('./bit_reader');
var BrotliDictionary = require('./dictionary');
var HuffmanCode = require('./huffman').HuffmanCode;
var BrotliBuildHuffmanTable = require('./huffman').BrotliBuildHuffmanTable;
var Context = require('./context');
var Prefix = require('./prefix');
var Transform = require('./transform');

var kDefaultCodeLength = 8;
var kCodeLengthRepeatCode = 16;
var kNumLiteralCodes = 256;
var kNumInsertAndCopyCodes = 704;
var kNumBlockLengthCodes = 26;
var kLiteralContextBits = 6;
var kDistanceContextBits = 2;

var HUFFMAN_TABLE_BITS = 8;
var HUFFMAN_TABLE_MASK = 0xff;
/* Maximum possible Huffman table size for an alphabet size of 704, max code
 * length 15 and root table bits 8. */
var HUFFMAN_MAX_TABLE_SIZE = 1080;

var CODE_LENGTH_CODES = 18;
var kCodeLengthCodeOrder = new Uint8Array([
  1, 2, 3, 4, 0, 5, 17, 6, 16, 7, 8, 9, 10, 11, 12, 13, 14, 15,
]);

var NUM_DISTANCE_SHORT_CODES = 16;
var kDistanceShortCodeIndexOffset = new Uint8Array([
  3, 2, 1, 0, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2
]);

var kDistanceShortCodeValueOffset = new Int8Array([
  0, 0, 0, 0, -1, 1, -2, 2, -3, 3, -1, 1, -2, 2, -3, 3
]);

var kMaxHuffmanTableSize = new Uint16Array([
  256, 402, 436, 468, 500, 534, 566, 598, 630, 662, 694, 726, 758, 790, 822,
  854, 886, 920, 952, 984, 1016, 1048, 1080
]);

function DecodeWindowBits(br) {
  var n;
  if (br.readBits(1) === 0) {
    return 16;
  }
  
  n = br.readBits(3);
  if (n > 0) {
    return 17 + n;
  }
  
  n = br.readBits(3);
  if (n > 0) {
    return 8 + n;
  }
  
  return 17;
}

/* Decodes a number in the range [0..255], by reading 1 - 11 bits. */
function DecodeVarLenUint8(br) {
  if (br.readBits(1)) {
    var nbits = br.readBits(3);
    if (nbits === 0) {
      return 1;
    } else {
      return br.readBits(nbits) + (1 << nbits);
    }
  }
  return 0;
}

function MetaBlockLength() {
  this.meta_block_length = 0;
  this.input_end = 0;
  this.is_uncompressed = 0;
  this.is_metadata = false;
}

function DecodeMetaBlockLength(br) {
  var out = new MetaBlockLength;  
  var size_nibbles;
  var size_bytes;
  var i;
  
  out.input_end = br.readBits(1);
  if (out.input_end && br.readBits(1)) {
    return out;
  }
  
  size_nibbles = br.readBits(2) + 4;
  if (size_nibbles === 7) {
    out.is_metadata = true;
    
    if (br.readBits(1) !== 0)
      throw new Error('Invalid reserved bit');
    
    size_bytes = br.readBits(2);
    if (size_bytes === 0)
      return out;
    
    for (i = 0; i < size_bytes; i++) {
      var next_byte = br.readBits(8);
      if (i + 1 === size_bytes && size_bytes > 1 && next_byte === 0)
        throw new Error('Invalid size byte');
      
      out.meta_block_length |= next_byte << (i * 8);
    }
  } else {
    for (i = 0; i < size_nibbles; ++i) {
      var next_nibble = br.readBits(4);
      if (i + 1 === size_nibbles && size_nibbles > 4 && next_nibble === 0)
        throw new Error('Invalid size nibble');
      
      out.meta_block_length |= next_nibble << (i * 4);
    }
  }
  
  ++out.meta_block_length;
  
  if (!out.input_end && !out.is_metadata) {
    out.is_uncompressed = br.readBits(1);
  }
  
  return out;
}

/* Decodes the next Huffman code from bit-stream. */
function ReadSymbol(table, index, br) {
  var start_index = index;
  
  var nbits;
  br.fillBitWindow();
  index += (br.val_ >>> br.bit_pos_) & HUFFMAN_TABLE_MASK;
  nbits = table[index].bits - HUFFMAN_TABLE_BITS;
  if (nbits > 0) {
    br.bit_pos_ += HUFFMAN_TABLE_BITS;
    index += table[index].value;
    index += (br.val_ >>> br.bit_pos_) & ((1 << nbits) - 1);
  }
  br.bit_pos_ += table[index].bits;
  return table[index].value;
}

function ReadHuffmanCodeLengths(code_length_code_lengths, num_symbols, code_lengths, br) {
  var symbol = 0;
  var prev_code_len = kDefaultCodeLength;
  var repeat = 0;
  var repeat_code_len = 0;
  var space = 32768;
  
  var table = [];
  for (var i = 0; i < 32; i++)
    table.push(new HuffmanCode(0, 0));
  
  BrotliBuildHuffmanTable(table, 0, 5, code_length_code_lengths, CODE_LENGTH_CODES);

  while (symbol < num_symbols && space > 0) {
    var p = 0;
    var code_len;
    
    br.readMoreInput();
    br.fillBitWindow();
    p += (br.val_ >>> br.bit_pos_) & 31;
    br.bit_pos_ += table[p].bits;
    code_len = table[p].value & 0xff;
    if (code_len < kCodeLengthRepeatCode) {
      repeat = 0;
      code_lengths[symbol++] = code_len;
      if (code_len !== 0) {
        prev_code_len = code_len;
        space -= 32768 >> code_len;
      }
    } else {
      var extra_bits = code_len - 14;
      var old_repeat;
      var repeat_delta;
      var new_len = 0;
      if (code_len === kCodeLengthRepeatCode) {
        new_len = prev_code_len;
      }
      if (repeat_code_len !== new_len) {
        repeat = 0;
        repeat_code_len = new_len;
      }
      old_repeat = repeat;
      if (repeat > 0) {
        repeat -= 2;
        repeat <<= extra_bits;
      }
      repeat += br.readBits(extra_bits) + 3;
      repeat_delta = repeat - old_repeat;
      if (symbol + repeat_delta > num_symbols) {
        throw new Error('[ReadHuffmanCodeLengths] symbol + repeat_delta > num_symbols');
      }
      
      for (var x = 0; x < repeat_delta; x++)
        code_lengths[symbol + x] = repeat_code_len;
      
      symbol += repeat_delta;
      
      if (repeat_code_len !== 0) {
        space -= repeat_delta << (15 - repeat_code_len);
      }
    }
  }
  if (space !== 0) {
    throw new Error("[ReadHuffmanCodeLengths] space = " + space);
  }
  
  for (; symbol < num_symbols; symbol++)
    code_lengths[symbol] = 0;
}

function ReadHuffmanCode(alphabet_size, tables, table, br) {
  var table_size = 0;
  var simple_code_or_skip;
  var code_lengths = new Uint8Array(alphabet_size);
  
  br.readMoreInput();
  
  /* simple_code_or_skip is used as follows:
     1 for simple code;
     0 for no skipping, 2 skips 2 code lengths, 3 skips 3 code lengths */
  simple_code_or_skip = br.readBits(2);
  if (simple_code_or_skip === 1) {
    /* Read symbols, codes & code lengths directly. */
    var i;
    var max_bits_counter = alphabet_size - 1;
    var max_bits = 0;
    var symbols = new Int32Array(4);
    var num_symbols = br.readBits(2) + 1;
    while (max_bits_counter) {
      max_bits_counter >>= 1;
      ++max_bits;
    }

    for (i = 0; i < num_symbols; ++i) {
      symbols[i] = br.readBits(max_bits) % alphabet_size;
      code_lengths[symbols[i]] = 2;
    }
    code_lengths[symbols[0]] = 1;
    switch (num_symbols) {
      case 1:
        break;
      case 3:
        if ((symbols[0] === symbols[1]) ||
            (symbols[0] === symbols[2]) ||
            (symbols[1] === symbols[2])) {
          throw new Error('[ReadHuffmanCode] invalid symbols');
        }
        break;
      case 2:
        if (symbols[0] === symbols[1]) {
          throw new Error('[ReadHuffmanCode] invalid symbols');
        }
        
        code_lengths[symbols[1]] = 1;
        break;
      case 4:
        if ((symbols[0] === symbols[1]) ||
            (symbols[0] === symbols[2]) ||
            (symbols[0] === symbols[3]) ||
            (symbols[1] === symbols[2]) ||
            (symbols[1] === symbols[3]) ||
            (symbols[2] === symbols[3])) {
          throw new Error('[ReadHuffmanCode] invalid symbols');
        }
        
        if (br.readBits(1)) {
          code_lengths[symbols[2]] = 3;
          code_lengths[symbols[3]] = 3;
        } else {
          code_lengths[symbols[0]] = 2;
        }
        break;
    }
  } else {  /* Decode Huffman-coded code lengths. */
    var i;
    var code_length_code_lengths = new Uint8Array(CODE_LENGTH_CODES);
    var space = 32;
    var num_codes = 0;
    /* Static Huffman code for the code length code lengths */
    var huff = [
      new HuffmanCode(2, 0), new HuffmanCode(2, 4), new HuffmanCode(2, 3), new HuffmanCode(3, 2), 
      new HuffmanCode(2, 0), new HuffmanCode(2, 4), new HuffmanCode(2, 3), new HuffmanCode(4, 1),
      new HuffmanCode(2, 0), new HuffmanCode(2, 4), new HuffmanCode(2, 3), new HuffmanCode(3, 2), 
      new HuffmanCode(2, 0), new HuffmanCode(2, 4), new HuffmanCode(2, 3), new HuffmanCode(4, 5)
    ];
    for (i = simple_code_or_skip; i < CODE_LENGTH_CODES && space > 0; ++i) {
      var code_len_idx = kCodeLengthCodeOrder[i];
      var p = 0;
      var v;
      br.fillBitWindow();
      p += (br.val_ >>> br.bit_pos_) & 15;
      br.bit_pos_ += huff[p].bits;
      v = huff[p].value;
      code_length_code_lengths[code_len_idx] = v;
      if (v !== 0) {
        space -= (32 >> v);
        ++num_codes;
      }
    }
    
    if (!(num_codes === 1 || space === 0))
      throw new Error('[ReadHuffmanCode] invalid num_codes or space');
    
    ReadHuffmanCodeLengths(code_length_code_lengths, alphabet_size, code_lengths, br);
  }
  
  table_size = BrotliBuildHuffmanTable(tables, table, HUFFMAN_TABLE_BITS, code_lengths, alphabet_size);
  
  if (table_size === 0) {
    throw new Error("[ReadHuffmanCode] BuildHuffmanTable failed: ");
  }
  
  return table_size;
}

function ReadBlockLength(table, index, br) {
  var code;
  var nbits;
  code = ReadSymbol(table, index, br);
  nbits = Prefix.kBlockLengthPrefixCode[code].nbits;
  return Prefix.kBlockLengthPrefixCode[code].offset + br.readBits(nbits);
}

function TranslateShortCodes(code, ringbuffer, index) {
  var val;
  if (code < NUM_DISTANCE_SHORT_CODES) {
    index += kDistanceShortCodeIndexOffset[code];
    index &= 3;
    val = ringbuffer[index] + kDistanceShortCodeValueOffset[code];
  } else {
    val = code - NUM_DISTANCE_SHORT_CODES + 1;
  }
  return val;
}

function MoveToFront(v, index) {
  var value = v[index];
  var i = index;
  for (; i; --i) v[i] = v[i - 1];
  v[0] = value;
}

function InverseMoveToFrontTransform(v, v_len) {
  var mtf = new Uint8Array(256);
  var i;
  for (i = 0; i < 256; ++i) {
    mtf[i] = i;
  }
  for (i = 0; i < v_len; ++i) {
    var index = v[i];
    v[i] = mtf[index];
    if (index) MoveToFront(mtf, index);
  }
}

/* Contains a collection of huffman trees with the same alphabet size. */
function HuffmanTreeGroup(alphabet_size, num_htrees) {
  this.alphabet_size = alphabet_size;
  this.num_htrees = num_htrees;
  this.codes = new Array(num_htrees + num_htrees * kMaxHuffmanTableSize[(alphabet_size + 31) >>> 5]);  
  this.htrees = new Uint32Array(num_htrees);
}

HuffmanTreeGroup.prototype.decode = function(br) {
  var i;
  var table_size;
  var next = 0;
  for (i = 0; i < this.num_htrees; ++i) {
    this.htrees[i] = next;
    table_size = ReadHuffmanCode(this.alphabet_size, this.codes, next, br);
    next += table_size;
  }
};

function DecodeContextMap(context_map_size, br) {
  var out = { num_htrees: null, context_map: null };
  var use_rle_for_zeros;
  var max_run_length_prefix = 0;
  var table;
  var i;
  
  br.readMoreInput();
  var num_htrees = out.num_htrees = DecodeVarLenUint8(br) + 1;

  var context_map = out.context_map = new Uint8Array(context_map_size);
  if (num_htrees <= 1) {
    return out;
  }

  use_rle_for_zeros = br.readBits(1);
  if (use_rle_for_zeros) {
    max_run_length_prefix = br.readBits(4) + 1;
  }
  
  table = [];
  for (i = 0; i < HUFFMAN_MAX_TABLE_SIZE; i++) {
    table[i] = new HuffmanCode(0, 0);
  }
  
  ReadHuffmanCode(num_htrees + max_run_length_prefix, table, 0, br);
  
  for (i = 0; i < context_map_size;) {
    var code;

    br.readMoreInput();
    code = ReadSymbol(table, 0, br);
    if (code === 0) {
      context_map[i] = 0;
      ++i;
    } else if (code <= max_run_length_prefix) {
      var reps = 1 + (1 << code) + br.readBits(code);
      while (--reps) {
        if (i >= context_map_size) {
          throw new Error("[DecodeContextMap] i >= context_map_size");
        }
        context_map[i] = 0;
        ++i;
      }
    } else {
      context_map[i] = code - max_run_length_prefix;
      ++i;
    }
  }
  if (br.readBits(1)) {
    InverseMoveToFrontTransform(context_map, context_map_size);
  }
  
  return out;
}

function DecodeBlockType(max_block_type, trees, tree_type, block_types, ringbuffers, indexes, br) {
  var ringbuffer = tree_type * 2;
  var index = tree_type;
  var type_code = ReadSymbol(trees, tree_type * HUFFMAN_MAX_TABLE_SIZE, br);
  var block_type;
  if (type_code === 0) {
    block_type = ringbuffers[ringbuffer + (indexes[index] & 1)];
  } else if (type_code === 1) {
    block_type = ringbuffers[ringbuffer + ((indexes[index] - 1) & 1)] + 1;
  } else {
    block_type = type_code - 2;
  }
  if (block_type >= max_block_type) {
    block_type -= max_block_type;
  }
  block_types[tree_type] = block_type;
  ringbuffers[ringbuffer + (indexes[index] & 1)] = block_type;
  ++indexes[index];
}

function CopyUncompressedBlockToOutput(output, len, pos, ringbuffer, ringbuffer_mask, br) {
  var rb_size = ringbuffer_mask + 1;
  var rb_pos = pos & ringbuffer_mask;
  var br_pos = br.pos_ & BrotliBitReader.IBUF_MASK;
  var nbytes;

  /* For short lengths copy byte-by-byte */
  if (len < 8 || br.bit_pos_ + (len << 3) < br.bit_end_pos_) {
    while (len-- > 0) {
      br.readMoreInput();
      ringbuffer[rb_pos++] = br.readBits(8);
      if (rb_pos === rb_size) {
        output.write(ringbuffer, rb_size);
        rb_pos = 0;
      }
    }
    return;
  }

  if (br.bit_end_pos_ < 32) {
    throw new Error('[CopyUncompressedBlockToOutput] br.bit_end_pos_ < 32');
  }

  /* Copy remaining 0-4 bytes from br.val_ to ringbuffer. */
  while (br.bit_pos_ < 32) {
    ringbuffer[rb_pos] = (br.val_ >>> br.bit_pos_);
    br.bit_pos_ += 8;
    ++rb_pos;
    --len;
  }

  /* Copy remaining bytes from br.buf_ to ringbuffer. */
  nbytes = (br.bit_end_pos_ - br.bit_pos_) >> 3;
  if (br_pos + nbytes > BrotliBitReader.IBUF_MASK) {
    var tail = BrotliBitReader.IBUF_MASK + 1 - br_pos;
    for (var x = 0; x < tail; x++)
      ringbuffer[rb_pos + x] = br.buf_[br_pos + x];
    
    nbytes -= tail;
    rb_pos += tail;
    len -= tail;
    br_pos = 0;
  }

  for (var x = 0; x < nbytes; x++)
    ringbuffer[rb_pos + x] = br.buf_[br_pos + x];
  
  rb_pos += nbytes;
  len -= nbytes;

  /* If we wrote past the logical end of the ringbuffer, copy the tail of the
     ringbuffer to its beginning and flush the ringbuffer to the output. */
  if (rb_pos >= rb_size) {
    output.write(ringbuffer, rb_size);
    rb_pos -= rb_size;    
    for (var x = 0; x < rb_pos; x++)
      ringbuffer[x] = ringbuffer[rb_size + x];
  }

  /* If we have more to copy than the remaining size of the ringbuffer, then we
     first fill the ringbuffer from the input and then flush the ringbuffer to
     the output */
  while (rb_pos + len >= rb_size) {
    nbytes = rb_size - rb_pos;
    if (br.input_.read(ringbuffer, rb_pos, nbytes) < nbytes) {
      throw new Error('[CopyUncompressedBlockToOutput] not enough bytes');
    }
    output.write(ringbuffer, rb_size);
    len -= nbytes;
    rb_pos = 0;
  }

  /* Copy straight from the input onto the ringbuffer. The ringbuffer will be
     flushed to the output at a later time. */
  if (br.input_.read(ringbuffer, rb_pos, len) < len) {
    throw new Error('[CopyUncompressedBlockToOutput] not enough bytes');
  }

  /* Restore the state of the bit reader. */
  br.reset();
}

/* Advances the bit reader position to the next byte boundary and verifies
   that any skipped bits are set to zero. */
function JumpToByteBoundary(br) {
  var new_bit_pos = (br.bit_pos_ + 7) & ~7;
  var pad_bits = br.readBits(new_bit_pos - br.bit_pos_);
  return pad_bits == 0;
}

function BrotliDecompressedSize(buffer) {
  var input = new BrotliInput(buffer);
  var br = new BrotliBitReader(input);
  DecodeWindowBits(br);
  var out = DecodeMetaBlockLength(br);
  return out.meta_block_length;
}

exports.BrotliDecompressedSize = BrotliDecompressedSize;

function BrotliDecompressBuffer(buffer, output_size) {
  var input = new BrotliInput(buffer);
  
  if (output_size == null) {
    output_size = BrotliDecompressedSize(buffer);
  }
  
  var output_buffer = new Uint8Array(output_size);
  var output = new BrotliOutput(output_buffer);
  
  BrotliDecompress(input, output);
  
  if (output.pos < output.buffer.length) {
    output.buffer = output.buffer.subarray(0, output.pos);
  }
  
  return output.buffer;
}

exports.BrotliDecompressBuffer = BrotliDecompressBuffer;

function BrotliDecompress(input, output) {
  var i;
  var pos = 0;
  var input_end = 0;
  var window_bits = 0;
  var max_backward_distance;
  var max_distance = 0;
  var ringbuffer_size;
  var ringbuffer_mask;
  var ringbuffer;
  var ringbuffer_end;
  /* This ring buffer holds a few past copy distances that will be used by */
  /* some special distance codes. */
  var dist_rb = [ 16, 15, 11, 4 ];
  var dist_rb_idx = 0;
  /* The previous 2 bytes used for context. */
  var prev_byte1 = 0;
  var prev_byte2 = 0;
  var hgroup = [new HuffmanTreeGroup(0, 0), new HuffmanTreeGroup(0, 0), new HuffmanTreeGroup(0, 0)];
  var block_type_trees;
  var block_len_trees;
  var br;

  /* We need the slack region for the following reasons:
       - always doing two 8-byte copies for fast backward copying
       - transforms
       - flushing the input ringbuffer when decoding uncompressed blocks */
  var kRingBufferWriteAheadSlack = 128 + BrotliBitReader.READ_SIZE;

  br = new BrotliBitReader(input);

  /* Decode window size. */
  window_bits = DecodeWindowBits(br);
  max_backward_distance = (1 << window_bits) - 16;

  ringbuffer_size = 1 << window_bits;
  ringbuffer_mask = ringbuffer_size - 1;
  ringbuffer = new Uint8Array(ringbuffer_size + kRingBufferWriteAheadSlack + BrotliDictionary.maxDictionaryWordLength);
  ringbuffer_end = ringbuffer_size;

  block_type_trees = [];
  block_len_trees = [];
  for (var x = 0; x < 3 * HUFFMAN_MAX_TABLE_SIZE; x++) {
    block_type_trees[x] = new HuffmanCode(0, 0);
    block_len_trees[x] = new HuffmanCode(0, 0);
  }

  while (!input_end) {
    var meta_block_remaining_len = 0;
    var is_uncompressed;
    var block_length = [ 1 << 28, 1 << 28, 1 << 28 ];
    var block_type = [ 0 ];
    var num_block_types = [ 1, 1, 1 ];
    var block_type_rb = [ 0, 1, 0, 1, 0, 1 ];
    var block_type_rb_index = [ 0 ];
    var distance_postfix_bits;
    var num_direct_distance_codes;
    var distance_postfix_mask;
    var num_distance_codes;
    var context_map = null;
    var context_modes = null;
    var num_literal_htrees;
    var dist_context_map = null;
    var num_dist_htrees;
    var context_offset = 0;
    var context_map_slice = null;
    var literal_htree_index = 0;
    var dist_context_offset = 0;
    var dist_context_map_slice = null;
    var dist_htree_index = 0;
    var context_lookup_offset1 = 0;
    var context_lookup_offset2 = 0;
    var context_mode;
    var htree_command;

    for (i = 0; i < 3; ++i) {
      hgroup[i].codes = null;
      hgroup[i].htrees = null;
    }

    br.readMoreInput();
    
    var _out = DecodeMetaBlockLength(br);
    meta_block_remaining_len = _out.meta_block_length;
    if (pos + meta_block_remaining_len > output.buffer.length) {
      /* We need to grow the output buffer to fit the additional data. */
      var tmp = new Uint8Array( pos + meta_block_remaining_len );
      tmp.set( output.buffer );
      output.buffer = tmp;
    }    
    input_end = _out.input_end;
    is_uncompressed = _out.is_uncompressed;
    
    if (_out.is_metadata) {
      JumpToByteBoundary(br);
      
      for (; meta_block_remaining_len > 0; --meta_block_remaining_len) {
        br.readMoreInput();
        /* Read one byte and ignore it. */
        br.readBits(8);
      }
      
      continue;
    }
    
    if (meta_block_remaining_len === 0) {
      continue;
    }
    
    if (is_uncompressed) {
      br.bit_pos_ = (br.bit_pos_ + 7) & ~7;
      CopyUncompressedBlockToOutput(output, meta_block_remaining_len, pos,
                                    ringbuffer, ringbuffer_mask, br);
      pos += meta_block_remaining_len;
      continue;
    }
    
    for (i = 0; i < 3; ++i) {
      num_block_types[i] = DecodeVarLenUint8(br) + 1;
      if (num_block_types[i] >= 2) {
        ReadHuffmanCode(num_block_types[i] + 2, block_type_trees, i * HUFFMAN_MAX_TABLE_SIZE, br);
        ReadHuffmanCode(kNumBlockLengthCodes, block_len_trees, i * HUFFMAN_MAX_TABLE_SIZE, br);
        block_length[i] = ReadBlockLength(block_len_trees, i * HUFFMAN_MAX_TABLE_SIZE, br);
        block_type_rb_index[i] = 1;
      }
    }
    
    br.readMoreInput();
    
    distance_postfix_bits = br.readBits(2);
    num_direct_distance_codes = NUM_DISTANCE_SHORT_CODES + (br.readBits(4) << distance_postfix_bits);
    distance_postfix_mask = (1 << distance_postfix_bits) - 1;
    num_distance_codes = (num_direct_distance_codes + (48 << distance_postfix_bits));
    context_modes = new Uint8Array(num_block_types[0]);

    for (i = 0; i < num_block_types[0]; ++i) {
       br.readMoreInput();
       context_modes[i] = (br.readBits(2) << 1);
    }
    
    var _o1 = DecodeContextMap(num_block_types[0] << kLiteralContextBits, br);
    num_literal_htrees = _o1.num_htrees;
    context_map = _o1.context_map;
    
    var _o2 = DecodeContextMap(num_block_types[2] << kDistanceContextBits, br);
    num_dist_htrees = _o2.num_htrees;
    dist_context_map = _o2.context_map;
    
    hgroup[0] = new HuffmanTreeGroup(kNumLiteralCodes, num_literal_htrees);
    hgroup[1] = new HuffmanTreeGroup(kNumInsertAndCopyCodes, num_block_types[1]);
    hgroup[2] = new HuffmanTreeGroup(num_distance_codes, num_dist_htrees);

    for (i = 0; i < 3; ++i) {
      hgroup[i].decode(br);
    }

    context_map_slice = 0;
    dist_context_map_slice = 0;
    context_mode = context_modes[block_type[0]];
    context_lookup_offset1 = Context.lookupOffsets[context_mode];
    context_lookup_offset2 = Context.lookupOffsets[context_mode + 1];
    htree_command = hgroup[1].htrees[0];

    while (meta_block_remaining_len > 0) {
      var cmd_code;
      var range_idx;
      var insert_code;
      var copy_code;
      var insert_length;
      var copy_length;
      var distance_code;
      var distance;
      var context;
      var j;
      var copy_dst;

      br.readMoreInput();
      
      if (block_length[1] === 0) {
        DecodeBlockType(num_block_types[1],
                        block_type_trees, 1, block_type, block_type_rb,
                        block_type_rb_index, br);
        block_length[1] = ReadBlockLength(block_len_trees, HUFFMAN_MAX_TABLE_SIZE, br);
        htree_command = hgroup[1].htrees[block_type[1]];
      }
      --block_length[1];
      cmd_code = ReadSymbol(hgroup[1].codes, htree_command, br);
      range_idx = cmd_code >> 6;
      if (range_idx >= 2) {
        range_idx -= 2;
        distance_code = -1;
      } else {
        distance_code = 0;
      }
      insert_code = Prefix.kInsertRangeLut[range_idx] + ((cmd_code >> 3) & 7);
      copy_code = Prefix.kCopyRangeLut[range_idx] + (cmd_code & 7);
      insert_length = Prefix.kInsertLengthPrefixCode[insert_code].offset +
          br.readBits(Prefix.kInsertLengthPrefixCode[insert_code].nbits);
      copy_length = Prefix.kCopyLengthPrefixCode[copy_code].offset +
          br.readBits(Prefix.kCopyLengthPrefixCode[copy_code].nbits);
      prev_byte1 = ringbuffer[pos-1 & ringbuffer_mask];
      prev_byte2 = ringbuffer[pos-2 & ringbuffer_mask];
      for (j = 0; j < insert_length; ++j) {
        br.readMoreInput();

        if (block_length[0] === 0) {
          DecodeBlockType(num_block_types[0],
                          block_type_trees, 0, block_type, block_type_rb,
                          block_type_rb_index, br);
          block_length[0] = ReadBlockLength(block_len_trees, 0, br);
          context_offset = block_type[0] << kLiteralContextBits;
          context_map_slice = context_offset;
          context_mode = context_modes[block_type[0]];
          context_lookup_offset1 = Context.lookupOffsets[context_mode];
          context_lookup_offset2 = Context.lookupOffsets[context_mode + 1];
        }
        context = (Context.lookup[context_lookup_offset1 + prev_byte1] |
                   Context.lookup[context_lookup_offset2 + prev_byte2]);
        literal_htree_index = context_map[context_map_slice + context];
        --block_length[0];
        prev_byte2 = prev_byte1;
        prev_byte1 = ReadSymbol(hgroup[0].codes, hgroup[0].htrees[literal_htree_index], br);
        ringbuffer[pos & ringbuffer_mask] = prev_byte1;
        if ((pos & ringbuffer_mask) === ringbuffer_mask) {
          output.write(ringbuffer, ringbuffer_size);
        }
        ++pos;
      }
      meta_block_remaining_len -= insert_length;
      if (meta_block_remaining_len <= 0) break;

      if (distance_code < 0) {
        var context;
        
        br.readMoreInput();
        if (block_length[2] === 0) {
          DecodeBlockType(num_block_types[2],
                          block_type_trees, 2, block_type, block_type_rb,
                          block_type_rb_index, br);
          block_length[2] = ReadBlockLength(block_len_trees, 2 * HUFFMAN_MAX_TABLE_SIZE, br);
          dist_context_offset = block_type[2] << kDistanceContextBits;
          dist_context_map_slice = dist_context_offset;
        }
        --block_length[2];
        context = (copy_length > 4 ? 3 : copy_length - 2) & 0xff;
        dist_htree_index = dist_context_map[dist_context_map_slice + context];
        distance_code = ReadSymbol(hgroup[2].codes, hgroup[2].htrees[dist_htree_index], br);
        if (distance_code >= num_direct_distance_codes) {
          var nbits;
          var postfix;
          var offset;
          distance_code -= num_direct_distance_codes;
          postfix = distance_code & distance_postfix_mask;
          distance_code >>= distance_postfix_bits;
          nbits = (distance_code >> 1) + 1;
          offset = ((2 + (distance_code & 1)) << nbits) - 4;
          distance_code = num_direct_distance_codes +
              ((offset + br.readBits(nbits)) <<
               distance_postfix_bits) + postfix;
        }
      }

      /* Convert the distance code to the actual distance by possibly looking */
      /* up past distnaces from the ringbuffer. */
      distance = TranslateShortCodes(distance_code, dist_rb, dist_rb_idx);
      if (distance < 0) {
        throw new Error('[BrotliDecompress] invalid distance');
      }

      if (pos < max_backward_distance &&
          max_distance !== max_backward_distance) {
        max_distance = pos;
      } else {
        max_distance = max_backward_distance;
      }

      copy_dst = pos & ringbuffer_mask;

      if (distance > max_distance) {
        if (copy_length >= BrotliDictionary.minDictionaryWordLength &&
            copy_length <= BrotliDictionary.maxDictionaryWordLength) {
          var offset = BrotliDictionary.offsetsByLength[copy_length];
          var word_id = distance - max_distance - 1;
          var shift = BrotliDictionary.sizeBitsByLength[copy_length];
          var mask = (1 << shift) - 1;
          var word_idx = word_id & mask;
          var transform_idx = word_id >> shift;
          offset += word_idx * copy_length;
          if (transform_idx < Transform.kNumTransforms) {
            var len = Transform.transformDictionaryWord(ringbuffer, copy_dst, offset, copy_length, transform_idx);
            copy_dst += len;
            pos += len;
            meta_block_remaining_len -= len;
            if (copy_dst >= ringbuffer_end) {
              output.write(ringbuffer, ringbuffer_size);
              
              for (var _x = 0; _x < (copy_dst - ringbuffer_end); _x++)
                ringbuffer[_x] = ringbuffer[ringbuffer_end + _x];
            }
          } else {
            throw new Error("Invalid backward reference. pos: " + pos + " distance: " + distance +
              " len: " + copy_length + " bytes left: " + meta_block_remaining_len);
          }
        } else {
          throw new Error("Invalid backward reference. pos: " + pos + " distance: " + distance +
            " len: " + copy_length + " bytes left: " + meta_block_remaining_len);
        }
      } else {
        if (distance_code > 0) {
          dist_rb[dist_rb_idx & 3] = distance;
          ++dist_rb_idx;
        }

        if (copy_length > meta_block_remaining_len) {
          throw new Error("Invalid backward reference. pos: " + pos + " distance: " + distance +
            " len: " + copy_length + " bytes left: " + meta_block_remaining_len);
        }

        for (j = 0; j < copy_length; ++j) {
          ringbuffer[pos & ringbuffer_mask] = ringbuffer[(pos - distance) & ringbuffer_mask];
          if ((pos & ringbuffer_mask) === ringbuffer_mask) {
            output.write(ringbuffer, ringbuffer_size);
          }
          ++pos;
          --meta_block_remaining_len;
        }
      }

      /* When we get here, we must have inserted at least one literal and */
      /* made a copy of at least length two, therefore accessing the last 2 */
      /* bytes is valid. */
      prev_byte1 = ringbuffer[(pos - 1) & ringbuffer_mask];
      prev_byte2 = ringbuffer[(pos - 2) & ringbuffer_mask];
    }

    /* Protect pos from overflow, wrap it around at every GB of input data */
    pos &= 0x3fffffff;
  }

  output.write(ringbuffer, pos & ringbuffer_mask);
}

exports.BrotliDecompress = BrotliDecompress;

BrotliDictionary.init();

},{"./bit_reader":24,"./context":25,"./dictionary":29,"./huffman":30,"./prefix":31,"./streams":32,"./transform":33}],27:[function(require,module,exports){
var base64 = require('base64-js');
var fs = require('fs');

/**
 * The normal dictionary-data.js is quite large, which makes it 
 * unsuitable for browser usage. In order to make it smaller, 
 * we read dictionary.bin, which is a compressed version of
 * the dictionary, and on initial load, Brotli decompresses 
 * it's own dictionary. 😜
 */
exports.init = function() {
  var BrotliDecompressBuffer = require('./decode').BrotliDecompressBuffer;
  var compressed = base64.toByteArray(require('./dictionary.bin.js'));
  return BrotliDecompressBuffer(compressed);
};

},{"./decode":26,"./dictionary.bin.js":28,"base64-js":22,"fs":36}],28:[function(require,module,exports){
module.exports="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";

},{}],29:[function(require,module,exports){
/* Copyright 2013 Google Inc. All Rights Reserved.

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

   Collection of static dictionary words.
*/

var data = require('./dictionary-data');
exports.init = function() {
  exports.dictionary = data.init();
};

exports.offsetsByLength = new Uint32Array([
     0,     0,     0,     0,     0,  4096,  9216, 21504, 35840, 44032,
 53248, 63488, 74752, 87040, 93696, 100864, 104704, 106752, 108928, 113536,
 115968, 118528, 119872, 121280, 122016,
]);

exports.sizeBitsByLength = new Uint8Array([
  0,  0,  0,  0, 10, 10, 11, 11, 10, 10,
 10, 10, 10,  9,  9,  8,  7,  7,  8,  7,
  7,  6,  6,  5,  5,
]);

exports.minDictionaryWordLength = 4;
exports.maxDictionaryWordLength = 24;

},{"./dictionary-data":27}],30:[function(require,module,exports){
function HuffmanCode(bits, value) {
  this.bits = bits;   /* number of bits used for this symbol */
  this.value = value; /* symbol value or table offset */
}

exports.HuffmanCode = HuffmanCode;

var MAX_LENGTH = 15;

/* Returns reverse(reverse(key, len) + 1, len), where reverse(key, len) is the
   bit-wise reversal of the len least significant bits of key. */
function GetNextKey(key, len) {
  var step = 1 << (len - 1);
  while (key & step) {
    step >>= 1;
  }
  return (key & (step - 1)) + step;
}

/* Stores code in table[0], table[step], table[2*step], ..., table[end] */
/* Assumes that end is an integer multiple of step */
function ReplicateValue(table, i, step, end, code) {
  do {
    end -= step;
    table[i + end] = new HuffmanCode(code.bits, code.value);
  } while (end > 0);
}

/* Returns the table width of the next 2nd level table. count is the histogram
   of bit lengths for the remaining symbols, len is the code length of the next
   processed symbol */
function NextTableBitSize(count, len, root_bits) {
  var left = 1 << (len - root_bits);
  while (len < MAX_LENGTH) {
    left -= count[len];
    if (left <= 0) break;
    ++len;
    left <<= 1;
  }
  return len - root_bits;
}

exports.BrotliBuildHuffmanTable = function(root_table, table, root_bits, code_lengths, code_lengths_size) {
  var start_table = table;
  var code;            /* current table entry */
  var len;             /* current code length */
  var symbol;          /* symbol index in original or sorted table */
  var key;             /* reversed prefix code */
  var step;            /* step size to replicate values in current table */
  var low;             /* low bits for current root entry */
  var mask;            /* mask for low bits */
  var table_bits;      /* key length of current table */
  var table_size;      /* size of current table */
  var total_size;      /* sum of root table size and 2nd level table sizes */
  var sorted;          /* symbols sorted by code length */
  var count = new Int32Array(MAX_LENGTH + 1);  /* number of codes of each length */
  var offset = new Int32Array(MAX_LENGTH + 1);  /* offsets in sorted table for each length */

  sorted = new Int32Array(code_lengths_size);

  /* build histogram of code lengths */
  for (symbol = 0; symbol < code_lengths_size; symbol++) {
    count[code_lengths[symbol]]++;
  }

  /* generate offsets into sorted symbol table by code length */
  offset[1] = 0;
  for (len = 1; len < MAX_LENGTH; len++) {
    offset[len + 1] = offset[len] + count[len];
  }

  /* sort symbols by length, by symbol order within each length */
  for (symbol = 0; symbol < code_lengths_size; symbol++) {
    if (code_lengths[symbol] !== 0) {
      sorted[offset[code_lengths[symbol]]++] = symbol;
    }
  }
  
  table_bits = root_bits;
  table_size = 1 << table_bits;
  total_size = table_size;

  /* special case code with only one value */
  if (offset[MAX_LENGTH] === 1) {
    for (key = 0; key < total_size; ++key) {
      root_table[table + key] = new HuffmanCode(0, sorted[0] & 0xffff);
    }
    
    return total_size;
  }

  /* fill in root table */
  key = 0;
  symbol = 0;
  for (len = 1, step = 2; len <= root_bits; ++len, step <<= 1) {
    for (; count[len] > 0; --count[len]) {
      code = new HuffmanCode(len & 0xff, sorted[symbol++] & 0xffff);
      ReplicateValue(root_table, table + key, step, table_size, code);
      key = GetNextKey(key, len);
    }
  }

  /* fill in 2nd level tables and add pointers to root table */
  mask = total_size - 1;
  low = -1;
  for (len = root_bits + 1, step = 2; len <= MAX_LENGTH; ++len, step <<= 1) {
    for (; count[len] > 0; --count[len]) {
      if ((key & mask) !== low) {
        table += table_size;
        table_bits = NextTableBitSize(count, len, root_bits);
        table_size = 1 << table_bits;
        total_size += table_size;
        low = key & mask;
        root_table[start_table + low] = new HuffmanCode((table_bits + root_bits) & 0xff, ((table - start_table) - low) & 0xffff);
      }
      code = new HuffmanCode((len - root_bits) & 0xff, sorted[symbol++] & 0xffff);
      ReplicateValue(root_table, table + (key >> root_bits), step, table_size, code);
      key = GetNextKey(key, len);
    }
  }
  
  return total_size;
}

},{}],31:[function(require,module,exports){
/* Copyright 2013 Google Inc. All Rights Reserved.

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

   Lookup tables to map prefix codes to value ranges. This is used during
   decoding of the block lengths, literal insertion lengths and copy lengths.
*/

/* Represents the range of values belonging to a prefix code: */
/* [offset, offset + 2^nbits) */
function PrefixCodeRange(offset, nbits) {
  this.offset = offset;
  this.nbits = nbits;
}

exports.kBlockLengthPrefixCode = [
  new PrefixCodeRange(1, 2), new PrefixCodeRange(5, 2), new PrefixCodeRange(9, 2), new PrefixCodeRange(13, 2),
  new PrefixCodeRange(17, 3), new PrefixCodeRange(25, 3), new PrefixCodeRange(33, 3), new PrefixCodeRange(41, 3),
  new PrefixCodeRange(49, 4), new PrefixCodeRange(65, 4), new PrefixCodeRange(81, 4), new PrefixCodeRange(97, 4),
  new PrefixCodeRange(113, 5), new PrefixCodeRange(145, 5), new PrefixCodeRange(177, 5), new PrefixCodeRange(209, 5),
  new PrefixCodeRange(241, 6), new PrefixCodeRange(305, 6), new PrefixCodeRange(369, 7), new PrefixCodeRange(497, 8),
  new PrefixCodeRange(753, 9), new PrefixCodeRange(1265, 10), new PrefixCodeRange(2289, 11), new PrefixCodeRange(4337, 12),
  new PrefixCodeRange(8433, 13), new PrefixCodeRange(16625, 24)
];

exports.kInsertLengthPrefixCode = [
  new PrefixCodeRange(0, 0), new PrefixCodeRange(1, 0), new PrefixCodeRange(2, 0), new PrefixCodeRange(3, 0),
  new PrefixCodeRange(4, 0), new PrefixCodeRange(5, 0), new PrefixCodeRange(6, 1), new PrefixCodeRange(8, 1),
  new PrefixCodeRange(10, 2), new PrefixCodeRange(14, 2), new PrefixCodeRange(18, 3), new PrefixCodeRange(26, 3),
  new PrefixCodeRange(34, 4), new PrefixCodeRange(50, 4), new PrefixCodeRange(66, 5), new PrefixCodeRange(98, 5),
  new PrefixCodeRange(130, 6), new PrefixCodeRange(194, 7), new PrefixCodeRange(322, 8), new PrefixCodeRange(578, 9),
  new PrefixCodeRange(1090, 10), new PrefixCodeRange(2114, 12), new PrefixCodeRange(6210, 14), new PrefixCodeRange(22594, 24),
];

exports.kCopyLengthPrefixCode = [
  new PrefixCodeRange(2, 0), new PrefixCodeRange(3, 0), new PrefixCodeRange(4, 0), new PrefixCodeRange(5, 0),
  new PrefixCodeRange(6, 0), new PrefixCodeRange(7, 0), new PrefixCodeRange(8, 0), new PrefixCodeRange(9, 0),
  new PrefixCodeRange(10, 1), new PrefixCodeRange(12, 1), new PrefixCodeRange(14, 2), new PrefixCodeRange(18, 2),
  new PrefixCodeRange(22, 3), new PrefixCodeRange(30, 3), new PrefixCodeRange(38, 4), new PrefixCodeRange(54, 4),
  new PrefixCodeRange(70, 5), new PrefixCodeRange(102, 5), new PrefixCodeRange(134, 6), new PrefixCodeRange(198, 7),
  new PrefixCodeRange(326, 8), new PrefixCodeRange(582, 9), new PrefixCodeRange(1094, 10), new PrefixCodeRange(2118, 24),
];

exports.kInsertRangeLut = [
  0, 0, 8, 8, 0, 16, 8, 16, 16,
];

exports.kCopyRangeLut = [
  0, 8, 0, 8, 16, 0, 16, 8, 16,
];

},{}],32:[function(require,module,exports){
function BrotliInput(buffer) {
  this.buffer = buffer;
  this.pos = 0;
}

BrotliInput.prototype.read = function(buf, i, count) {
  if (this.pos + count > this.buffer.length) {
    count = this.buffer.length - this.pos;
  }
  
  for (var p = 0; p < count; p++)
    buf[i + p] = this.buffer[this.pos + p];
  
  this.pos += count;
  return count;
}

exports.BrotliInput = BrotliInput;

function BrotliOutput(buf) {
  this.buffer = buf;
  this.pos = 0;
}

BrotliOutput.prototype.write = function(buf, count) {
  if (this.pos + count > this.buffer.length)
    throw new Error('Output buffer is not large enough');
  
  this.buffer.set(buf.subarray(0, count), this.pos);
  this.pos += count;
  return count;
};

exports.BrotliOutput = BrotliOutput;

},{}],33:[function(require,module,exports){
/* Copyright 2013 Google Inc. All Rights Reserved.

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

   Transformations on dictionary words.
*/

var BrotliDictionary = require('./dictionary');

var kIdentity       = 0;
var kOmitLast1      = 1;
var kOmitLast2      = 2;
var kOmitLast3      = 3;
var kOmitLast4      = 4;
var kOmitLast5      = 5;
var kOmitLast6      = 6;
var kOmitLast7      = 7;
var kOmitLast8      = 8;
var kOmitLast9      = 9;
var kUppercaseFirst = 10;
var kUppercaseAll   = 11;
var kOmitFirst1     = 12;
var kOmitFirst2     = 13;
var kOmitFirst3     = 14;
var kOmitFirst4     = 15;
var kOmitFirst5     = 16;
var kOmitFirst6     = 17;
var kOmitFirst7     = 18;
var kOmitFirst8     = 19;
var kOmitFirst9     = 20;

function Transform(prefix, transform, suffix) {
  this.prefix = new Uint8Array(prefix.length);
  this.transform = transform;
  this.suffix = new Uint8Array(suffix.length);
  
  for (var i = 0; i < prefix.length; i++)
    this.prefix[i] = prefix.charCodeAt(i);
  
  for (var i = 0; i < suffix.length; i++)
    this.suffix[i] = suffix.charCodeAt(i);
}

var kTransforms = [
     new Transform(         "", kIdentity,       ""           ),
     new Transform(         "", kIdentity,       " "          ),
     new Transform(        " ", kIdentity,       " "          ),
     new Transform(         "", kOmitFirst1,     ""           ),
     new Transform(         "", kUppercaseFirst, " "          ),
     new Transform(         "", kIdentity,       " the "      ),
     new Transform(        " ", kIdentity,       ""           ),
     new Transform(       "s ", kIdentity,       " "          ),
     new Transform(         "", kIdentity,       " of "       ),
     new Transform(         "", kUppercaseFirst, ""           ),
     new Transform(         "", kIdentity,       " and "      ),
     new Transform(         "", kOmitFirst2,     ""           ),
     new Transform(         "", kOmitLast1,      ""           ),
     new Transform(       ", ", kIdentity,       " "          ),
     new Transform(         "", kIdentity,       ", "         ),
     new Transform(        " ", kUppercaseFirst, " "          ),
     new Transform(         "", kIdentity,       " in "       ),
     new Transform(         "", kIdentity,       " to "       ),
     new Transform(       "e ", kIdentity,       " "          ),
     new Transform(         "", kIdentity,       "\""         ),
     new Transform(         "", kIdentity,       "."          ),
     new Transform(         "", kIdentity,       "\">"        ),
     new Transform(         "", kIdentity,       "\n"         ),
     new Transform(         "", kOmitLast3,      ""           ),
     new Transform(         "", kIdentity,       "]"          ),
     new Transform(         "", kIdentity,       " for "      ),
     new Transform(         "", kOmitFirst3,     ""           ),
     new Transform(         "", kOmitLast2,      ""           ),
     new Transform(         "", kIdentity,       " a "        ),
     new Transform(         "", kIdentity,       " that "     ),
     new Transform(        " ", kUppercaseFirst, ""           ),
     new Transform(         "", kIdentity,       ". "         ),
     new Transform(        ".", kIdentity,       ""           ),
     new Transform(        " ", kIdentity,       ", "         ),
     new Transform(         "", kOmitFirst4,     ""           ),
     new Transform(         "", kIdentity,       " with "     ),
     new Transform(         "", kIdentity,       "'"          ),
     new Transform(         "", kIdentity,       " from "     ),
     new Transform(         "", kIdentity,       " by "       ),
     new Transform(         "", kOmitFirst5,     ""           ),
     new Transform(         "", kOmitFirst6,     ""           ),
     new Transform(    " the ", kIdentity,       ""           ),
     new Transform(         "", kOmitLast4,      ""           ),
     new Transform(         "", kIdentity,       ". The "     ),
     new Transform(         "", kUppercaseAll,   ""           ),
     new Transform(         "", kIdentity,       " on "       ),
     new Transform(         "", kIdentity,       " as "       ),
     new Transform(         "", kIdentity,       " is "       ),
     new Transform(         "", kOmitLast7,      ""           ),
     new Transform(         "", kOmitLast1,      "ing "       ),
     new Transform(         "", kIdentity,       "\n\t"       ),
     new Transform(         "", kIdentity,       ":"          ),
     new Transform(        " ", kIdentity,       ". "         ),
     new Transform(         "", kIdentity,       "ed "        ),
     new Transform(         "", kOmitFirst9,     ""           ),
     new Transform(         "", kOmitFirst7,     ""           ),
     new Transform(         "", kOmitLast6,      ""           ),
     new Transform(         "", kIdentity,       "("          ),
     new Transform(         "", kUppercaseFirst, ", "         ),
     new Transform(         "", kOmitLast8,      ""           ),
     new Transform(         "", kIdentity,       " at "       ),
     new Transform(         "", kIdentity,       "ly "        ),
     new Transform(    " the ", kIdentity,       " of "       ),
     new Transform(         "", kOmitLast5,      ""           ),
     new Transform(         "", kOmitLast9,      ""           ),
     new Transform(        " ", kUppercaseFirst, ", "         ),
     new Transform(         "", kUppercaseFirst, "\""         ),
     new Transform(        ".", kIdentity,       "("          ),
     new Transform(         "", kUppercaseAll,   " "          ),
     new Transform(         "", kUppercaseFirst, "\">"        ),
     new Transform(         "", kIdentity,       "=\""        ),
     new Transform(        " ", kIdentity,       "."          ),
     new Transform(    ".com/", kIdentity,       ""           ),
     new Transform(    " the ", kIdentity,       " of the "   ),
     new Transform(         "", kUppercaseFirst, "'"          ),
     new Transform(         "", kIdentity,       ". This "    ),
     new Transform(         "", kIdentity,       ","          ),
     new Transform(        ".", kIdentity,       " "          ),
     new Transform(         "", kUppercaseFirst, "("          ),
     new Transform(         "", kUppercaseFirst, "."          ),
     new Transform(         "", kIdentity,       " not "      ),
     new Transform(        " ", kIdentity,       "=\""        ),
     new Transform(         "", kIdentity,       "er "        ),
     new Transform(        " ", kUppercaseAll,   " "          ),
     new Transform(         "", kIdentity,       "al "        ),
     new Transform(        " ", kUppercaseAll,   ""           ),
     new Transform(         "", kIdentity,       "='"         ),
     new Transform(         "", kUppercaseAll,   "\""         ),
     new Transform(         "", kUppercaseFirst, ". "         ),
     new Transform(        " ", kIdentity,       "("          ),
     new Transform(         "", kIdentity,       "ful "       ),
     new Transform(        " ", kUppercaseFirst, ". "         ),
     new Transform(         "", kIdentity,       "ive "       ),
     new Transform(         "", kIdentity,       "less "      ),
     new Transform(         "", kUppercaseAll,   "'"          ),
     new Transform(         "", kIdentity,       "est "       ),
     new Transform(        " ", kUppercaseFirst, "."          ),
     new Transform(         "", kUppercaseAll,   "\">"        ),
     new Transform(        " ", kIdentity,       "='"         ),
     new Transform(         "", kUppercaseFirst, ","          ),
     new Transform(         "", kIdentity,       "ize "       ),
     new Transform(         "", kUppercaseAll,   "."          ),
     new Transform( "\xc2\xa0", kIdentity,       ""           ),
     new Transform(        " ", kIdentity,       ","          ),
     new Transform(         "", kUppercaseFirst, "=\""        ),
     new Transform(         "", kUppercaseAll,   "=\""        ),
     new Transform(         "", kIdentity,       "ous "       ),
     new Transform(         "", kUppercaseAll,   ", "         ),
     new Transform(         "", kUppercaseFirst, "='"         ),
     new Transform(        " ", kUppercaseFirst, ","          ),
     new Transform(        " ", kUppercaseAll,   "=\""        ),
     new Transform(        " ", kUppercaseAll,   ", "         ),
     new Transform(         "", kUppercaseAll,   ","          ),
     new Transform(         "", kUppercaseAll,   "("          ),
     new Transform(         "", kUppercaseAll,   ". "         ),
     new Transform(        " ", kUppercaseAll,   "."          ),
     new Transform(         "", kUppercaseAll,   "='"         ),
     new Transform(        " ", kUppercaseAll,   ". "         ),
     new Transform(        " ", kUppercaseFirst, "=\""        ),
     new Transform(        " ", kUppercaseAll,   "='"         ),
     new Transform(        " ", kUppercaseFirst, "='"         )
];

exports.kTransforms = kTransforms;
exports.kNumTransforms = kTransforms.length;

function ToUpperCase(p, i) {
  if (p[i] < 0xc0) {
    if (p[i] >= 97 && p[i] <= 122) {
      p[i] ^= 32;
    }
    return 1;
  }
  
  /* An overly simplified uppercasing model for utf-8. */
  if (p[i] < 0xe0) {
    p[i + 1] ^= 32;
    return 2;
  }
  
  /* An arbitrary transform for three byte characters. */
  p[i + 2] ^= 5;
  return 3;
}

exports.transformDictionaryWord = function(dst, idx, word, len, transform) {
  var prefix = kTransforms[transform].prefix;
  var suffix = kTransforms[transform].suffix;
  var t = kTransforms[transform].transform;
  var skip = t < kOmitFirst1 ? 0 : t - (kOmitFirst1 - 1);
  var i = 0;
  var start_idx = idx;
  var uppercase;
  
  if (skip > len) {
    skip = len;
  }
  
  var prefix_pos = 0;
  while (prefix_pos < prefix.length) {
    dst[idx++] = prefix[prefix_pos++];
  }
  
  word += skip;
  len -= skip;
  
  if (t <= kOmitLast9) {
    len -= t;
  }
  
  for (i = 0; i < len; i++) {
    dst[idx++] = BrotliDictionary.dictionary[word + i];
  }
  
  uppercase = idx - len;
  
  if (t === kUppercaseFirst) {
    ToUpperCase(dst, uppercase);
  } else if (t === kUppercaseAll) {
    while (len > 0) {
      var step = ToUpperCase(dst, uppercase);
      uppercase += step;
      len -= step;
    }
  }
  
  var suffix_pos = 0;
  while (suffix_pos < suffix.length) {
    dst[idx++] = suffix[suffix_pos++];
  }
  
  return idx - start_idx;
}

},{"./dictionary":29}],34:[function(require,module,exports){
module.exports = require('./dec/decode').BrotliDecompressBuffer;

},{"./dec/decode":26}],35:[function(require,module,exports){

},{}],36:[function(require,module,exports){
arguments[4][35][0].apply(exports,arguments)
},{"dup":35}],37:[function(require,module,exports){
(function (Buffer){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')
var customInspectSymbol =
  (typeof Symbol === 'function' && typeof Symbol.for === 'function')
    ? Symbol.for('nodejs.util.inspect.custom')
    : null

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

var K_MAX_LENGTH = 0x7fffffff
exports.kMaxLength = K_MAX_LENGTH

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */
Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()

if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
    typeof console.error === 'function') {
  console.error(
    'This browser lacks typed array (Uint8Array) support which is required by ' +
    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
  )
}

function typedArraySupport () {
  // Can typed array instances can be augmented?
  try {
    var arr = new Uint8Array(1)
    var proto = { foo: function () { return 42 } }
    Object.setPrototypeOf(proto, Uint8Array.prototype)
    Object.setPrototypeOf(arr, proto)
    return arr.foo() === 42
  } catch (e) {
    return false
  }
}

Object.defineProperty(Buffer.prototype, 'parent', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.buffer
  }
})

Object.defineProperty(Buffer.prototype, 'offset', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.byteOffset
  }
})

function createBuffer (length) {
  if (length > K_MAX_LENGTH) {
    throw new RangeError('The value "' + length + '" is invalid for option "size"')
  }
  // Return an augmented `Uint8Array` instance
  var buf = new Uint8Array(length)
  Object.setPrototypeOf(buf, Buffer.prototype)
  return buf
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new TypeError(
        'The "string" argument must be of type string. Received type number'
      )
    }
    return allocUnsafe(arg)
  }
  return from(arg, encodingOrOffset, length)
}

// Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
if (typeof Symbol !== 'undefined' && Symbol.species != null &&
    Buffer[Symbol.species] === Buffer) {
  Object.defineProperty(Buffer, Symbol.species, {
    value: null,
    configurable: true,
    enumerable: false,
    writable: false
  })
}

Buffer.poolSize = 8192 // not used by this implementation

function from (value, encodingOrOffset, length) {
  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset)
  }

  if (ArrayBuffer.isView(value)) {
    return fromArrayLike(value)
  }

  if (value == null) {
    throw new TypeError(
      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
      'or Array-like Object. Received type ' + (typeof value)
    )
  }

  if (isInstance(value, ArrayBuffer) ||
      (value && isInstance(value.buffer, ArrayBuffer))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof value === 'number') {
    throw new TypeError(
      'The "value" argument must not be of type number. Received type number'
    )
  }

  var valueOf = value.valueOf && value.valueOf()
  if (valueOf != null && valueOf !== value) {
    return Buffer.from(valueOf, encodingOrOffset, length)
  }

  var b = fromObject(value)
  if (b) return b

  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&
      typeof value[Symbol.toPrimitive] === 'function') {
    return Buffer.from(
      value[Symbol.toPrimitive]('string'), encodingOrOffset, length
    )
  }

  throw new TypeError(
    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
    'or Array-like Object. Received type ' + (typeof value)
  )
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(value, encodingOrOffset, length)
}

// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype)
Object.setPrototypeOf(Buffer, Uint8Array)

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be of type number')
  } else if (size < 0) {
    throw new RangeError('The value "' + size + '" is invalid for option "size"')
  }
}

function alloc (size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(size).fill(fill, encoding)
      : createBuffer(size).fill(fill)
  }
  return createBuffer(size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(size, fill, encoding)
}

function allocUnsafe (size) {
  assertSize(size)
  return createBuffer(size < 0 ? 0 : checked(size) | 0)
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(size)
}

function fromString (string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('Unknown encoding: ' + encoding)
  }

  var length = byteLength(string, encoding) | 0
  var buf = createBuffer(length)

  var actual = buf.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual)
  }

  return buf
}

function fromArrayLike (array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  var buf = createBuffer(length)
  for (var i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255
  }
  return buf
}

function fromArrayBuffer (array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('"offset" is outside of buffer bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('"length" is outside of buffer bounds')
  }

  var buf
  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array)
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset)
  } else {
    buf = new Uint8Array(array, byteOffset, length)
  }

  // Return an augmented `Uint8Array` instance
  Object.setPrototypeOf(buf, Buffer.prototype)

  return buf
}

function fromObject (obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    var buf = createBuffer(len)

    if (buf.length === 0) {
      return buf
    }

    obj.copy(buf, 0, 0, len)
    return buf
  }

  if (obj.length !== undefined) {
    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
      return createBuffer(0)
    }
    return fromArrayLike(obj)
  }

  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
    return fromArrayLike(obj.data)
  }
}

function checked (length) {
  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= K_MAX_LENGTH) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return b != null && b._isBuffer === true &&
    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
}

Buffer.compare = function compare (a, b) {
  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)
  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError(
      'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
    )
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!Array.isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (isInstance(buf, Uint8Array)) {
      buf = Buffer.from(buf)
    }
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    throw new TypeError(
      'The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' +
      'Received type ' + typeof string
    )
  }

  var len = string.length
  var mustMatch = (arguments.length > 2 && arguments[2] === true)
  if (!mustMatch && len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) {
          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
        }
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.toLocaleString = Buffer.prototype.toString

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()
  if (this.length > max) str += ' ... '
  return '<Buffer ' + str + '>'
}
if (customInspectSymbol) {
  Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (isInstance(target, Uint8Array)) {
    target = Buffer.from(target, target.offset, target.byteLength)
  }
  if (!Buffer.isBuffer(target)) {
    throw new TypeError(
      'The "target" argument must be one of type Buffer or Uint8Array. ' +
      'Received type ' + (typeof target)
    )
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset // Coerce to Number.
  if (numberIsNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  var strLen = string.length

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (numberIsNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset >>> 0
    if (isFinite(length)) {
      length = length >>> 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
        : (firstByte > 0xBF) ? 2
          : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += hexSliceLookupTable[buf[i]]
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf = this.subarray(start, end)
  // Return an augmented `Uint8Array` instance
  Object.setPrototypeOf(newBuf, Buffer.prototype)

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset + 3] = (value >>> 24)
  this[offset + 2] = (value >>> 16)
  this[offset + 1] = (value >>> 8)
  this[offset] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  this[offset + 2] = (value >>> 16)
  this[offset + 3] = (value >>> 24)
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start

  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
    // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end)
  } else if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (var i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, end),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if ((encoding === 'utf8' && code < 128) ||
          encoding === 'latin1') {
        // Fast path: If `val` fits into a single byte, use that numeric value.
        val = code
      }
    }
  } else if (typeof val === 'number') {
    val = val & 255
  } else if (typeof val === 'boolean') {
    val = Number(val)
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : Buffer.from(val, encoding)
    var len = bytes.length
    if (len === 0) {
      throw new TypeError('The value "' + val +
        '" is invalid for argument "value"')
    }
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node takes equal signs as end of the Base64 encoding
  str = str.split('=')[0]
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = str.trim().replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function isInstance (obj, type) {
  return obj instanceof type ||
    (obj != null && obj.constructor != null && obj.constructor.name != null &&
      obj.constructor.name === type.name)
}
function numberIsNaN (obj) {
  // For IE11 support
  return obj !== obj // eslint-disable-line no-self-compare
}

// Create lookup table for `toString('hex')`
// See: https://github.com/feross/buffer/issues/219
var hexSliceLookupTable = (function () {
  var alphabet = '0123456789abcdef'
  var table = new Array(256)
  for (var i = 0; i < 16; ++i) {
    var i16 = i * 16
    for (var j = 0; j < 16; ++j) {
      table[i16 + j] = alphabet[i] + alphabet[j]
    }
  }
  return table
})()

}).call(this,require("buffer").Buffer)
},{"base64-js":22,"buffer":37,"ieee754":169}],38:[function(require,module,exports){
(function (Buffer){
var clone = (function() {
'use strict';

/**
 * Clones (copies) an Object using deep copying.
 *
 * This function supports circular references by default, but if you are certain
 * there are no circular references in your object, you can save some CPU time
 * by calling clone(obj, false).
 *
 * Caution: if `circular` is false and `parent` contains circular references,
 * your program may enter an infinite loop and crash.
 *
 * @param `parent` - the object to be cloned
 * @param `circular` - set to true if the object to be cloned may contain
 *    circular references. (optional - true by default)
 * @param `depth` - set to a number if the object is only to be cloned to
 *    a particular depth. (optional - defaults to Infinity)
 * @param `prototype` - sets the prototype to be used when cloning an object.
 *    (optional - defaults to parent prototype).
*/
function clone(parent, circular, depth, prototype) {
  var filter;
  if (typeof circular === 'object') {
    depth = circular.depth;
    prototype = circular.prototype;
    filter = circular.filter;
    circular = circular.circular
  }
  // maintain two arrays for circular references, where corresponding parents
  // and children have the same index
  var allParents = [];
  var allChildren = [];

  var useBuffer = typeof Buffer != 'undefined';

  if (typeof circular == 'undefined')
    circular = true;

  if (typeof depth == 'undefined')
    depth = Infinity;

  // recurse this function so we don't reset allParents and allChildren
  function _clone(parent, depth) {
    // cloning null always returns null
    if (parent === null)
      return null;

    if (depth == 0)
      return parent;

    var child;
    var proto;
    if (typeof parent != 'object') {
      return parent;
    }

    if (clone.__isArray(parent)) {
      child = [];
    } else if (clone.__isRegExp(parent)) {
      child = new RegExp(parent.source, __getRegExpFlags(parent));
      if (parent.lastIndex) child.lastIndex = parent.lastIndex;
    } else if (clone.__isDate(parent)) {
      child = new Date(parent.getTime());
    } else if (useBuffer && Buffer.isBuffer(parent)) {
      if (Buffer.allocUnsafe) {
        // Node.js >= 4.5.0
        child = Buffer.allocUnsafe(parent.length);
      } else {
        // Older Node.js versions
        child = new Buffer(parent.length);
      }
      parent.copy(child);
      return child;
    } else {
      if (typeof prototype == 'undefined') {
        proto = Object.getPrototypeOf(parent);
        child = Object.create(proto);
      }
      else {
        child = Object.create(prototype);
        proto = prototype;
      }
    }

    if (circular) {
      var index = allParents.indexOf(parent);

      if (index != -1) {
        return allChildren[index];
      }
      allParents.push(parent);
      allChildren.push(child);
    }

    for (var i in parent) {
      var attrs;
      if (proto) {
        attrs = Object.getOwnPropertyDescriptor(proto, i);
      }

      if (attrs && attrs.set == null) {
        continue;
      }
      child[i] = _clone(parent[i], depth - 1);
    }

    return child;
  }

  return _clone(parent, depth);
}

/**
 * Simple flat clone using prototype, accepts only objects, usefull for property
 * override on FLAT configuration object (no nested props).
 *
 * USE WITH CAUTION! This may not behave as you wish if you do not know how this
 * works.
 */
clone.clonePrototype = function clonePrototype(parent) {
  if (parent === null)
    return null;

  var c = function () {};
  c.prototype = parent;
  return new c();
};

// private utility functions

function __objToStr(o) {
  return Object.prototype.toString.call(o);
};
clone.__objToStr = __objToStr;

function __isDate(o) {
  return typeof o === 'object' && __objToStr(o) === '[object Date]';
};
clone.__isDate = __isDate;

function __isArray(o) {
  return typeof o === 'object' && __objToStr(o) === '[object Array]';
};
clone.__isArray = __isArray;

function __isRegExp(o) {
  return typeof o === 'object' && __objToStr(o) === '[object RegExp]';
};
clone.__isRegExp = __isRegExp;

function __getRegExpFlags(re) {
  var flags = '';
  if (re.global) flags += 'g';
  if (re.ignoreCase) flags += 'i';
  if (re.multiline) flags += 'm';
  return flags;
};
clone.__getRegExpFlags = __getRegExpFlags;

return clone;
})();

if (typeof module === 'object' && module.exports) {
  module.exports = clone;
}

}).call(this,require("buffer").Buffer)
},{"buffer":37}],39:[function(require,module,exports){
require('../../modules/es6.string.iterator');
require('../../modules/es6.array.from');
module.exports = require('../../modules/_core').Array.from;

},{"../../modules/_core":69,"../../modules/es6.array.from":134,"../../modules/es6.string.iterator":149}],40:[function(require,module,exports){
require('../modules/web.dom.iterable');
require('../modules/es6.string.iterator');
module.exports = require('../modules/core.get-iterator');

},{"../modules/core.get-iterator":133,"../modules/es6.string.iterator":149,"../modules/web.dom.iterable":159}],41:[function(require,module,exports){
require('../modules/es6.object.to-string');
require('../modules/es6.string.iterator');
require('../modules/web.dom.iterable');
require('../modules/es6.map');
require('../modules/es7.map.to-json');
require('../modules/es7.map.of');
require('../modules/es7.map.from');
module.exports = require('../modules/_core').Map;

},{"../modules/_core":69,"../modules/es6.map":136,"../modules/es6.object.to-string":146,"../modules/es6.string.iterator":149,"../modules/es7.map.from":151,"../modules/es7.map.of":152,"../modules/es7.map.to-json":153,"../modules/web.dom.iterable":159}],42:[function(require,module,exports){
require('../../modules/es6.number.epsilon');
module.exports = Math.pow(2, -52);

},{"../../modules/es6.number.epsilon":137}],43:[function(require,module,exports){
require('../../modules/es6.object.assign');
module.exports = require('../../modules/_core').Object.assign;

},{"../../modules/_core":69,"../../modules/es6.object.assign":138}],44:[function(require,module,exports){
require('../../modules/es6.object.create');
var $Object = require('../../modules/_core').Object;
module.exports = function create(P, D) {
  return $Object.create(P, D);
};

},{"../../modules/_core":69,"../../modules/es6.object.create":139}],45:[function(require,module,exports){
require('../../modules/es6.object.define-properties');
var $Object = require('../../modules/_core').Object;
module.exports = function defineProperties(T, D) {
  return $Object.defineProperties(T, D);
};

},{"../../modules/_core":69,"../../modules/es6.object.define-properties":140}],46:[function(require,module,exports){
require('../../modules/es6.object.define-property');
var $Object = require('../../modules/_core').Object;
module.exports = function defineProperty(it, key, desc) {
  return $Object.defineProperty(it, key, desc);
};

},{"../../modules/_core":69,"../../modules/es6.object.define-property":141}],47:[function(require,module,exports){
require('../../modules/es6.object.freeze');
module.exports = require('../../modules/_core').Object.freeze;

},{"../../modules/_core":69,"../../modules/es6.object.freeze":142}],48:[function(require,module,exports){
require('../../modules/es6.object.get-own-property-descriptor');
var $Object = require('../../modules/_core').Object;
module.exports = function getOwnPropertyDescriptor(it, key) {
  return $Object.getOwnPropertyDescriptor(it, key);
};

},{"../../modules/_core":69,"../../modules/es6.object.get-own-property-descriptor":143}],49:[function(require,module,exports){
require('../../modules/es6.object.keys');
module.exports = require('../../modules/_core').Object.keys;

},{"../../modules/_core":69,"../../modules/es6.object.keys":144}],50:[function(require,module,exports){
require('../../modules/es6.object.set-prototype-of');
module.exports = require('../../modules/_core').Object.setPrototypeOf;

},{"../../modules/_core":69,"../../modules/es6.object.set-prototype-of":145}],51:[function(require,module,exports){
require('../modules/es6.object.to-string');
require('../modules/es6.string.iterator');
require('../modules/web.dom.iterable');
require('../modules/es6.set');
require('../modules/es7.set.to-json');
require('../modules/es7.set.of');
require('../modules/es7.set.from');
module.exports = require('../modules/_core').Set;

},{"../modules/_core":69,"../modules/es6.object.to-string":146,"../modules/es6.set":147,"../modules/es6.string.iterator":149,"../modules/es7.set.from":154,"../modules/es7.set.of":155,"../modules/es7.set.to-json":156,"../modules/web.dom.iterable":159}],52:[function(require,module,exports){
require('../../modules/es6.string.from-code-point');
module.exports = require('../../modules/_core').String.fromCodePoint;

},{"../../modules/_core":69,"../../modules/es6.string.from-code-point":148}],53:[function(require,module,exports){
require('../../modules/es6.symbol');
require('../../modules/es6.object.to-string');
require('../../modules/es7.symbol.async-iterator');
require('../../modules/es7.symbol.observable');
module.exports = require('../../modules/_core').Symbol;

},{"../../modules/_core":69,"../../modules/es6.object.to-string":146,"../../modules/es6.symbol":150,"../../modules/es7.symbol.async-iterator":157,"../../modules/es7.symbol.observable":158}],54:[function(require,module,exports){
require('../../modules/es6.string.iterator');
require('../../modules/web.dom.iterable');
module.exports = require('../../modules/_wks-ext').f('iterator');

},{"../../modules/_wks-ext":130,"../../modules/es6.string.iterator":149,"../../modules/web.dom.iterable":159}],55:[function(require,module,exports){
module.exports = function (it) {
  if (typeof it != 'function') throw TypeError(it + ' is not a function!');
  return it;
};

},{}],56:[function(require,module,exports){
module.exports = function () { /* empty */ };

},{}],57:[function(require,module,exports){
module.exports = function (it, Constructor, name, forbiddenField) {
  if (!(it instanceof Constructor) || (forbiddenField !== undefined && forbiddenField in it)) {
    throw TypeError(name + ': incorrect invocation!');
  } return it;
};

},{}],58:[function(require,module,exports){
var isObject = require('./_is-object');
module.exports = function (it) {
  if (!isObject(it)) throw TypeError(it + ' is not an object!');
  return it;
};

},{"./_is-object":88}],59:[function(require,module,exports){
var forOf = require('./_for-of');

module.exports = function (iter, ITERATOR) {
  var result = [];
  forOf(iter, false, result.push, result, ITERATOR);
  return result;
};

},{"./_for-of":79}],60:[function(require,module,exports){
// false -> Array#indexOf
// true  -> Array#includes
var toIObject = require('./_to-iobject');
var toLength = require('./_to-length');
var toAbsoluteIndex = require('./_to-absolute-index');
module.exports = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIObject($this);
    var length = toLength(O.length);
    var index = toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare
    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare
      if (value != value) return true;
    // Array#indexOf ignores holes, Array#includes - not
    } else for (;length > index; index++) if (IS_INCLUDES || index in O) {
      if (O[index] === el) return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};

},{"./_to-absolute-index":121,"./_to-iobject":123,"./_to-length":124}],61:[function(require,module,exports){
// 0 -> Array#forEach
// 1 -> Array#map
// 2 -> Array#filter
// 3 -> Array#some
// 4 -> Array#every
// 5 -> Array#find
// 6 -> Array#findIndex
var ctx = require('./_ctx');
var IObject = require('./_iobject');
var toObject = require('./_to-object');
var toLength = require('./_to-length');
var asc = require('./_array-species-create');
module.exports = function (TYPE, $create) {
  var IS_MAP = TYPE == 1;
  var IS_FILTER = TYPE == 2;
  var IS_SOME = TYPE == 3;
  var IS_EVERY = TYPE == 4;
  var IS_FIND_INDEX = TYPE == 6;
  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
  var create = $create || asc;
  return function ($this, callbackfn, that) {
    var O = toObject($this);
    var self = IObject(O);
    var f = ctx(callbackfn, that, 3);
    var length = toLength(self.length);
    var index = 0;
    var result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined;
    var val, res;
    for (;length > index; index++) if (NO_HOLES || index in self) {
      val = self[index];
      res = f(val, index, O);
      if (TYPE) {
        if (IS_MAP) result[index] = res;   // map
        else if (res) switch (TYPE) {
          case 3: return true;             // some
          case 5: return val;              // find
          case 6: return index;            // findIndex
          case 2: result.push(val);        // filter
        } else if (IS_EVERY) return false; // every
      }
    }
    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
  };
};

},{"./_array-species-create":63,"./_ctx":71,"./_iobject":85,"./_to-length":124,"./_to-object":125}],62:[function(require,module,exports){
var isObject = require('./_is-object');
var isArray = require('./_is-array');
var SPECIES = require('./_wks')('species');

module.exports = function (original) {
  var C;
  if (isArray(original)) {
    C = original.constructor;
    // cross-realm fallback
    if (typeof C == 'function' && (C === Array || isArray(C.prototype))) C = undefined;
    if (isObject(C)) {
      C = C[SPECIES];
      if (C === null) C = undefined;
    }
  } return C === undefined ? Array : C;
};

},{"./_is-array":87,"./_is-object":88,"./_wks":131}],63:[function(require,module,exports){
// 9.4.2.3 ArraySpeciesCreate(originalArray, length)
var speciesConstructor = require('./_array-species-constructor');

module.exports = function (original, length) {
  return new (speciesConstructor(original))(length);
};

},{"./_array-species-constructor":62}],64:[function(require,module,exports){
// getting tag from 19.1.3.6 Object.prototype.toString()
var cof = require('./_cof');
var TAG = require('./_wks')('toStringTag');
// ES3 wrong here
var ARG = cof(function () { return arguments; }()) == 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function (it, key) {
  try {
    return it[key];
  } catch (e) { /* empty */ }
};

module.exports = function (it) {
  var O, T, B;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T
    // builtinTag case
    : ARG ? cof(O)
    // ES3 arguments fallback
    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
};

},{"./_cof":65,"./_wks":131}],65:[function(require,module,exports){
var toString = {}.toString;

module.exports = function (it) {
  return toString.call(it).slice(8, -1);
};

},{}],66:[function(require,module,exports){
'use strict';
var dP = require('./_object-dp').f;
var create = require('./_object-create');
var redefineAll = require('./_redefine-all');
var ctx = require('./_ctx');
var anInstance = require('./_an-instance');
var forOf = require('./_for-of');
var $iterDefine = require('./_iter-define');
var step = require('./_iter-step');
var setSpecies = require('./_set-species');
var DESCRIPTORS = require('./_descriptors');
var fastKey = require('./_meta').fastKey;
var validate = require('./_validate-collection');
var SIZE = DESCRIPTORS ? '_s' : 'size';

var getEntry = function (that, key) {
  // fast case
  var index = fastKey(key);
  var entry;
  if (index !== 'F') return that._i[index];
  // frozen object case
  for (entry = that._f; entry; entry = entry.n) {
    if (entry.k == key) return entry;
  }
};

module.exports = {
  getConstructor: function (wrapper, NAME, IS_MAP, ADDER) {
    var C = wrapper(function (that, iterable) {
      anInstance(that, C, NAME, '_i');
      that._t = NAME;         // collection type
      that._i = create(null); // index
      that._f = undefined;    // first entry
      that._l = undefined;    // last entry
      that[SIZE] = 0;         // size
      if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
    });
    redefineAll(C.prototype, {
      // 23.1.3.1 Map.prototype.clear()
      // 23.2.3.2 Set.prototype.clear()
      clear: function clear() {
        for (var that = validate(this, NAME), data = that._i, entry = that._f; entry; entry = entry.n) {
          entry.r = true;
          if (entry.p) entry.p = entry.p.n = undefined;
          delete data[entry.i];
        }
        that._f = that._l = undefined;
        that[SIZE] = 0;
      },
      // 23.1.3.3 Map.prototype.delete(key)
      // 23.2.3.4 Set.prototype.delete(value)
      'delete': function (key) {
        var that = validate(this, NAME);
        var entry = getEntry(that, key);
        if (entry) {
          var next = entry.n;
          var prev = entry.p;
          delete that._i[entry.i];
          entry.r = true;
          if (prev) prev.n = next;
          if (next) next.p = prev;
          if (that._f == entry) that._f = next;
          if (that._l == entry) that._l = prev;
          that[SIZE]--;
        } return !!entry;
      },
      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
      forEach: function forEach(callbackfn /* , that = undefined */) {
        validate(this, NAME);
        var f = ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);
        var entry;
        while (entry = entry ? entry.n : this._f) {
          f(entry.v, entry.k, this);
          // revert to the last existing entry
          while (entry && entry.r) entry = entry.p;
        }
      },
      // 23.1.3.7 Map.prototype.has(key)
      // 23.2.3.7 Set.prototype.has(value)
      has: function has(key) {
        return !!getEntry(validate(this, NAME), key);
      }
    });
    if (DESCRIPTORS) dP(C.prototype, 'size', {
      get: function () {
        return validate(this, NAME)[SIZE];
      }
    });
    return C;
  },
  def: function (that, key, value) {
    var entry = getEntry(that, key);
    var prev, index;
    // change existing entry
    if (entry) {
      entry.v = value;
    // create new entry
    } else {
      that._l = entry = {
        i: index = fastKey(key, true), // <- index
        k: key,                        // <- key
        v: value,                      // <- value
        p: prev = that._l,             // <- previous entry
        n: undefined,                  // <- next entry
        r: false                       // <- removed
      };
      if (!that._f) that._f = entry;
      if (prev) prev.n = entry;
      that[SIZE]++;
      // add to index
      if (index !== 'F') that._i[index] = entry;
    } return that;
  },
  getEntry: getEntry,
  setStrong: function (C, NAME, IS_MAP) {
    // add .keys, .values, .entries, [@@iterator]
    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
    $iterDefine(C, NAME, function (iterated, kind) {
      this._t = validate(iterated, NAME); // target
      this._k = kind;                     // kind
      this._l = undefined;                // previous
    }, function () {
      var that = this;
      var kind = that._k;
      var entry = that._l;
      // revert to the last existing entry
      while (entry && entry.r) entry = entry.p;
      // get next entry
      if (!that._t || !(that._l = entry = entry ? entry.n : that._t._f)) {
        // or finish the iteration
        that._t = undefined;
        return step(1);
      }
      // return step by kind
      if (kind == 'keys') return step(0, entry.k);
      if (kind == 'values') return step(0, entry.v);
      return step(0, [entry.k, entry.v]);
    }, IS_MAP ? 'entries' : 'values', !IS_MAP, true);

    // add [@@species], 23.1.2.2, 23.2.2.2
    setSpecies(NAME);
  }
};

},{"./_an-instance":57,"./_ctx":71,"./_descriptors":73,"./_for-of":79,"./_iter-define":91,"./_iter-step":93,"./_meta":96,"./_object-create":98,"./_object-dp":99,"./_redefine-all":111,"./_set-species":116,"./_validate-collection":128}],67:[function(require,module,exports){
// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var classof = require('./_classof');
var from = require('./_array-from-iterable');
module.exports = function (NAME) {
  return function toJSON() {
    if (classof(this) != NAME) throw TypeError(NAME + "#toJSON isn't generic");
    return from(this);
  };
};

},{"./_array-from-iterable":59,"./_classof":64}],68:[function(require,module,exports){
'use strict';
var global = require('./_global');
var $export = require('./_export');
var meta = require('./_meta');
var fails = require('./_fails');
var hide = require('./_hide');
var redefineAll = require('./_redefine-all');
var forOf = require('./_for-of');
var anInstance = require('./_an-instance');
var isObject = require('./_is-object');
var setToStringTag = require('./_set-to-string-tag');
var dP = require('./_object-dp').f;
var each = require('./_array-methods')(0);
var DESCRIPTORS = require('./_descriptors');

module.exports = function (NAME, wrapper, methods, common, IS_MAP, IS_WEAK) {
  var Base = global[NAME];
  var C = Base;
  var ADDER = IS_MAP ? 'set' : 'add';
  var proto = C && C.prototype;
  var O = {};
  if (!DESCRIPTORS || typeof C != 'function' || !(IS_WEAK || proto.forEach && !fails(function () {
    new C().entries().next();
  }))) {
    // create collection constructor
    C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
    redefineAll(C.prototype, methods);
    meta.NEED = true;
  } else {
    C = wrapper(function (target, iterable) {
      anInstance(target, C, NAME, '_c');
      target._c = new Base();
      if (iterable != undefined) forOf(iterable, IS_MAP, target[ADDER], target);
    });
    each('add,clear,delete,forEach,get,has,set,keys,values,entries,toJSON'.split(','), function (KEY) {
      var IS_ADDER = KEY == 'add' || KEY == 'set';
      if (KEY in proto && !(IS_WEAK && KEY == 'clear')) hide(C.prototype, KEY, function (a, b) {
        anInstance(this, C, KEY);
        if (!IS_ADDER && IS_WEAK && !isObject(a)) return KEY == 'get' ? undefined : false;
        var result = this._c[KEY](a === 0 ? 0 : a, b);
        return IS_ADDER ? this : result;
      });
    });
    IS_WEAK || dP(C.prototype, 'size', {
      get: function () {
        return this._c.size;
      }
    });
  }

  setToStringTag(C, NAME);

  O[NAME] = C;
  $export($export.G + $export.W + $export.F, O);

  if (!IS_WEAK) common.setStrong(C, NAME, IS_MAP);

  return C;
};

},{"./_an-instance":57,"./_array-methods":61,"./_descriptors":73,"./_export":77,"./_fails":78,"./_for-of":79,"./_global":80,"./_hide":82,"./_is-object":88,"./_meta":96,"./_object-dp":99,"./_redefine-all":111,"./_set-to-string-tag":117}],69:[function(require,module,exports){
var core = module.exports = { version: '2.6.10' };
if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef

},{}],70:[function(require,module,exports){
'use strict';
var $defineProperty = require('./_object-dp');
var createDesc = require('./_property-desc');

module.exports = function (object, index, value) {
  if (index in object) $defineProperty.f(object, index, createDesc(0, value));
  else object[index] = value;
};

},{"./_object-dp":99,"./_property-desc":110}],71:[function(require,module,exports){
// optional / simple context binding
var aFunction = require('./_a-function');
module.exports = function (fn, that, length) {
  aFunction(fn);
  if (that === undefined) return fn;
  switch (length) {
    case 1: return function (a) {
      return fn.call(that, a);
    };
    case 2: return function (a, b) {
      return fn.call(that, a, b);
    };
    case 3: return function (a, b, c) {
      return fn.call(that, a, b, c);
    };
  }
  return function (/* ...args */) {
    return fn.apply(that, arguments);
  };
};

},{"./_a-function":55}],72:[function(require,module,exports){
// 7.2.1 RequireObjectCoercible(argument)
module.exports = function (it) {
  if (it == undefined) throw TypeError("Can't call method on  " + it);
  return it;
};

},{}],73:[function(require,module,exports){
// Thank's IE8 for his funny defineProperty
module.exports = !require('./_fails')(function () {
  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;
});

},{"./_fails":78}],74:[function(require,module,exports){
var isObject = require('./_is-object');
var document = require('./_global').document;
// typeof document.createElement is 'object' in old IE
var is = isObject(document) && isObject(document.createElement);
module.exports = function (it) {
  return is ? document.createElement(it) : {};
};

},{"./_global":80,"./_is-object":88}],75:[function(require,module,exports){
// IE 8- don't enum bug keys
module.exports = (
  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
).split(',');

},{}],76:[function(require,module,exports){
// all enumerable object keys, includes symbols
var getKeys = require('./_object-keys');
var gOPS = require('./_object-gops');
var pIE = require('./_object-pie');
module.exports = function (it) {
  var result = getKeys(it);
  var getSymbols = gOPS.f;
  if (getSymbols) {
    var symbols = getSymbols(it);
    var isEnum = pIE.f;
    var i = 0;
    var key;
    while (symbols.length > i) if (isEnum.call(it, key = symbols[i++])) result.push(key);
  } return result;
};

},{"./_object-gops":104,"./_object-keys":107,"./_object-pie":108}],77:[function(require,module,exports){
var global = require('./_global');
var core = require('./_core');
var ctx = require('./_ctx');
var hide = require('./_hide');
var has = require('./_has');
var PROTOTYPE = 'prototype';

var $export = function (type, name, source) {
  var IS_FORCED = type & $export.F;
  var IS_GLOBAL = type & $export.G;
  var IS_STATIC = type & $export.S;
  var IS_PROTO = type & $export.P;
  var IS_BIND = type & $export.B;
  var IS_WRAP = type & $export.W;
  var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});
  var expProto = exports[PROTOTYPE];
  var target = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE];
  var key, own, out;
  if (IS_GLOBAL) source = name;
  for (key in source) {
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined;
    if (own && has(exports, key)) continue;
    // export native or passed
    out = own ? target[key] : source[key];
    // prevent global pollution for namespaces
    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]
    // bind timers to global for call from export context
    : IS_BIND && own ? ctx(out, global)
    // wrap global constructors for prevent change them in library
    : IS_WRAP && target[key] == out ? (function (C) {
      var F = function (a, b, c) {
        if (this instanceof C) {
          switch (arguments.length) {
            case 0: return new C();
            case 1: return new C(a);
            case 2: return new C(a, b);
          } return new C(a, b, c);
        } return C.apply(this, arguments);
      };
      F[PROTOTYPE] = C[PROTOTYPE];
      return F;
    // make static versions for prototype methods
    })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
    // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%
    if (IS_PROTO) {
      (exports.virtual || (exports.virtual = {}))[key] = out;
      // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%
      if (type & $export.R && expProto && !expProto[key]) hide(expProto, key, out);
    }
  }
};
// type bitmap
$export.F = 1;   // forced
$export.G = 2;   // global
$export.S = 4;   // static
$export.P = 8;   // proto
$export.B = 16;  // bind
$export.W = 32;  // wrap
$export.U = 64;  // safe
$export.R = 128; // real proto method for `library`
module.exports = $export;

},{"./_core":69,"./_ctx":71,"./_global":80,"./_has":81,"./_hide":82}],78:[function(require,module,exports){
module.exports = function (exec) {
  try {
    return !!exec();
  } catch (e) {
    return true;
  }
};

},{}],79:[function(require,module,exports){
var ctx = require('./_ctx');
var call = require('./_iter-call');
var isArrayIter = require('./_is-array-iter');
var anObject = require('./_an-object');
var toLength = require('./_to-length');
var getIterFn = require('./core.get-iterator-method');
var BREAK = {};
var RETURN = {};
var exports = module.exports = function (iterable, entries, fn, that, ITERATOR) {
  var iterFn = ITERATOR ? function () { return iterable; } : getIterFn(iterable);
  var f = ctx(fn, that, entries ? 2 : 1);
  var index = 0;
  var length, step, iterator, result;
  if (typeof iterFn != 'function') throw TypeError(iterable + ' is not iterable!');
  // fast case for arrays with default iterator
  if (isArrayIter(iterFn)) for (length = toLength(iterable.length); length > index; index++) {
    result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
    if (result === BREAK || result === RETURN) return result;
  } else for (iterator = iterFn.call(iterable); !(step = iterator.next()).done;) {
    result = call(iterator, f, step.value, entries);
    if (result === BREAK || result === RETURN) return result;
  }
};
exports.BREAK = BREAK;
exports.RETURN = RETURN;

},{"./_an-object":58,"./_ctx":71,"./_is-array-iter":86,"./_iter-call":89,"./_to-length":124,"./core.get-iterator-method":132}],80:[function(require,module,exports){
// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math
  ? window : typeof self != 'undefined' && self.Math == Math ? self
  // eslint-disable-next-line no-new-func
  : Function('return this')();
if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef

},{}],81:[function(require,module,exports){
var hasOwnProperty = {}.hasOwnProperty;
module.exports = function (it, key) {
  return hasOwnProperty.call(it, key);
};

},{}],82:[function(require,module,exports){
var dP = require('./_object-dp');
var createDesc = require('./_property-desc');
module.exports = require('./_descriptors') ? function (object, key, value) {
  return dP.f(object, key, createDesc(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};

},{"./_descriptors":73,"./_object-dp":99,"./_property-desc":110}],83:[function(require,module,exports){
var document = require('./_global').document;
module.exports = document && document.documentElement;

},{"./_global":80}],84:[function(require,module,exports){
module.exports = !require('./_descriptors') && !require('./_fails')(function () {
  return Object.defineProperty(require('./_dom-create')('div'), 'a', { get: function () { return 7; } }).a != 7;
});

},{"./_descriptors":73,"./_dom-create":74,"./_fails":78}],85:[function(require,module,exports){
// fallback for non-array-like ES3 and non-enumerable old V8 strings
var cof = require('./_cof');
// eslint-disable-next-line no-prototype-builtins
module.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
  return cof(it) == 'String' ? it.split('') : Object(it);
};

},{"./_cof":65}],86:[function(require,module,exports){
// check on default Array iterator
var Iterators = require('./_iterators');
var ITERATOR = require('./_wks')('iterator');
var ArrayProto = Array.prototype;

module.exports = function (it) {
  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
};

},{"./_iterators":94,"./_wks":131}],87:[function(require,module,exports){
// 7.2.2 IsArray(argument)
var cof = require('./_cof');
module.exports = Array.isArray || function isArray(arg) {
  return cof(arg) == 'Array';
};

},{"./_cof":65}],88:[function(require,module,exports){
module.exports = function (it) {
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};

},{}],89:[function(require,module,exports){
// call something on iterator step with safe closing on error
var anObject = require('./_an-object');
module.exports = function (iterator, fn, value, entries) {
  try {
    return entries ? fn(anObject(value)[0], value[1]) : fn(value);
  // 7.4.6 IteratorClose(iterator, completion)
  } catch (e) {
    var ret = iterator['return'];
    if (ret !== undefined) anObject(ret.call(iterator));
    throw e;
  }
};

},{"./_an-object":58}],90:[function(require,module,exports){
'use strict';
var create = require('./_object-create');
var descriptor = require('./_property-desc');
var setToStringTag = require('./_set-to-string-tag');
var IteratorPrototype = {};

// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
require('./_hide')(IteratorPrototype, require('./_wks')('iterator'), function () { return this; });

module.exports = function (Constructor, NAME, next) {
  Constructor.prototype = create(IteratorPrototype, { next: descriptor(1, next) });
  setToStringTag(Constructor, NAME + ' Iterator');
};

},{"./_hide":82,"./_object-create":98,"./_property-desc":110,"./_set-to-string-tag":117,"./_wks":131}],91:[function(require,module,exports){
'use strict';
var LIBRARY = require('./_library');
var $export = require('./_export');
var redefine = require('./_redefine');
var hide = require('./_hide');
var Iterators = require('./_iterators');
var $iterCreate = require('./_iter-create');
var setToStringTag = require('./_set-to-string-tag');
var getPrototypeOf = require('./_object-gpo');
var ITERATOR = require('./_wks')('iterator');
var BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`
var FF_ITERATOR = '@@iterator';
var KEYS = 'keys';
var VALUES = 'values';

var returnThis = function () { return this; };

module.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
  $iterCreate(Constructor, NAME, next);
  var getMethod = function (kind) {
    if (!BUGGY && kind in proto) return proto[kind];
    switch (kind) {
      case KEYS: return function keys() { return new Constructor(this, kind); };
      case VALUES: return function values() { return new Constructor(this, kind); };
    } return function entries() { return new Constructor(this, kind); };
  };
  var TAG = NAME + ' Iterator';
  var DEF_VALUES = DEFAULT == VALUES;
  var VALUES_BUG = false;
  var proto = Base.prototype;
  var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
  var $default = $native || getMethod(DEFAULT);
  var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;
  var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;
  var methods, key, IteratorPrototype;
  // Fix native
  if ($anyNative) {
    IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));
    if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
      // Set @@toStringTag to native iterators
      setToStringTag(IteratorPrototype, TAG, true);
      // fix for some old engines
      if (!LIBRARY && typeof IteratorPrototype[ITERATOR] != 'function') hide(IteratorPrototype, ITERATOR, returnThis);
    }
  }
  // fix Array#{values, @@iterator}.name in V8 / FF
  if (DEF_VALUES && $native && $native.name !== VALUES) {
    VALUES_BUG = true;
    $default = function values() { return $native.call(this); };
  }
  // Define iterator
  if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
    hide(proto, ITERATOR, $default);
  }
  // Plug for library
  Iterators[NAME] = $default;
  Iterators[TAG] = returnThis;
  if (DEFAULT) {
    methods = {
      values: DEF_VALUES ? $default : getMethod(VALUES),
      keys: IS_SET ? $default : getMethod(KEYS),
      entries: $entries
    };
    if (FORCED) for (key in methods) {
      if (!(key in proto)) redefine(proto, key, methods[key]);
    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
  }
  return methods;
};

},{"./_export":77,"./_hide":82,"./_iter-create":90,"./_iterators":94,"./_library":95,"./_object-gpo":105,"./_redefine":112,"./_set-to-string-tag":117,"./_wks":131}],92:[function(require,module,exports){
var ITERATOR = require('./_wks')('iterator');
var SAFE_CLOSING = false;

try {
  var riter = [7][ITERATOR]();
  riter['return'] = function () { SAFE_CLOSING = true; };
  // eslint-disable-next-line no-throw-literal
  Array.from(riter, function () { throw 2; });
} catch (e) { /* empty */ }

module.exports = function (exec, skipClosing) {
  if (!skipClosing && !SAFE_CLOSING) return false;
  var safe = false;
  try {
    var arr = [7];
    var iter = arr[ITERATOR]();
    iter.next = function () { return { done: safe = true }; };
    arr[ITERATOR] = function () { return iter; };
    exec(arr);
  } catch (e) { /* empty */ }
  return safe;
};

},{"./_wks":131}],93:[function(require,module,exports){
module.exports = function (done, value) {
  return { value: value, done: !!done };
};

},{}],94:[function(require,module,exports){
module.exports = {};

},{}],95:[function(require,module,exports){
module.exports = true;

},{}],96:[function(require,module,exports){
var META = require('./_uid')('meta');
var isObject = require('./_is-object');
var has = require('./_has');
var setDesc = require('./_object-dp').f;
var id = 0;
var isExtensible = Object.isExtensible || function () {
  return true;
};
var FREEZE = !require('./_fails')(function () {
  return isExtensible(Object.preventExtensions({}));
});
var setMeta = function (it) {
  setDesc(it, META, { value: {
    i: 'O' + ++id, // object ID
    w: {}          // weak collections IDs
  } });
};
var fastKey = function (it, create) {
  // return primitive with prefix
  if (!isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return 'F';
    // not necessary to add metadata
    if (!create) return 'E';
    // add missing metadata
    setMeta(it);
  // return object ID
  } return it[META].i;
};
var getWeak = function (it, create) {
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return true;
    // not necessary to add metadata
    if (!create) return false;
    // add missing metadata
    setMeta(it);
  // return hash weak collections IDs
  } return it[META].w;
};
// add metadata on freeze-family methods calling
var onFreeze = function (it) {
  if (FREEZE && meta.NEED && isExtensible(it) && !has(it, META)) setMeta(it);
  return it;
};
var meta = module.exports = {
  KEY: META,
  NEED: false,
  fastKey: fastKey,
  getWeak: getWeak,
  onFreeze: onFreeze
};

},{"./_fails":78,"./_has":81,"./_is-object":88,"./_object-dp":99,"./_uid":127}],97:[function(require,module,exports){
'use strict';
// 19.1.2.1 Object.assign(target, source, ...)
var DESCRIPTORS = require('./_descriptors');
var getKeys = require('./_object-keys');
var gOPS = require('./_object-gops');
var pIE = require('./_object-pie');
var toObject = require('./_to-object');
var IObject = require('./_iobject');
var $assign = Object.assign;

// should work with symbols and should have deterministic property order (V8 bug)
module.exports = !$assign || require('./_fails')(function () {
  var A = {};
  var B = {};
  // eslint-disable-next-line no-undef
  var S = Symbol();
  var K = 'abcdefghijklmnopqrst';
  A[S] = 7;
  K.split('').forEach(function (k) { B[k] = k; });
  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
}) ? function assign(target, source) { // eslint-disable-line no-unused-vars
  var T = toObject(target);
  var aLen = arguments.length;
  var index = 1;
  var getSymbols = gOPS.f;
  var isEnum = pIE.f;
  while (aLen > index) {
    var S = IObject(arguments[index++]);
    var keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S);
    var length = keys.length;
    var j = 0;
    var key;
    while (length > j) {
      key = keys[j++];
      if (!DESCRIPTORS || isEnum.call(S, key)) T[key] = S[key];
    }
  } return T;
} : $assign;

},{"./_descriptors":73,"./_fails":78,"./_iobject":85,"./_object-gops":104,"./_object-keys":107,"./_object-pie":108,"./_to-object":125}],98:[function(require,module,exports){
// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
var anObject = require('./_an-object');
var dPs = require('./_object-dps');
var enumBugKeys = require('./_enum-bug-keys');
var IE_PROTO = require('./_shared-key')('IE_PROTO');
var Empty = function () { /* empty */ };
var PROTOTYPE = 'prototype';

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var createDict = function () {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = require('./_dom-create')('iframe');
  var i = enumBugKeys.length;
  var lt = '<';
  var gt = '>';
  var iframeDocument;
  iframe.style.display = 'none';
  require('./_html').appendChild(iframe);
  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
  // createDict = iframe.contentWindow.Object;
  // html.removeChild(iframe);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
  iframeDocument.close();
  createDict = iframeDocument.F;
  while (i--) delete createDict[PROTOTYPE][enumBugKeys[i]];
  return createDict();
};

module.exports = Object.create || function create(O, Properties) {
  var result;
  if (O !== null) {
    Empty[PROTOTYPE] = anObject(O);
    result = new Empty();
    Empty[PROTOTYPE] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO] = O;
  } else result = createDict();
  return Properties === undefined ? result : dPs(result, Properties);
};

},{"./_an-object":58,"./_dom-create":74,"./_enum-bug-keys":75,"./_html":83,"./_object-dps":100,"./_shared-key":118}],99:[function(require,module,exports){
var anObject = require('./_an-object');
var IE8_DOM_DEFINE = require('./_ie8-dom-define');
var toPrimitive = require('./_to-primitive');
var dP = Object.defineProperty;

exports.f = require('./_descriptors') ? Object.defineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return dP(O, P, Attributes);
  } catch (e) { /* empty */ }
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};

},{"./_an-object":58,"./_descriptors":73,"./_ie8-dom-define":84,"./_to-primitive":126}],100:[function(require,module,exports){
var dP = require('./_object-dp');
var anObject = require('./_an-object');
var getKeys = require('./_object-keys');

module.exports = require('./_descriptors') ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject(O);
  var keys = getKeys(Properties);
  var length = keys.length;
  var i = 0;
  var P;
  while (length > i) dP.f(O, P = keys[i++], Properties[P]);
  return O;
};

},{"./_an-object":58,"./_descriptors":73,"./_object-dp":99,"./_object-keys":107}],101:[function(require,module,exports){
var pIE = require('./_object-pie');
var createDesc = require('./_property-desc');
var toIObject = require('./_to-iobject');
var toPrimitive = require('./_to-primitive');
var has = require('./_has');
var IE8_DOM_DEFINE = require('./_ie8-dom-define');
var gOPD = Object.getOwnPropertyDescriptor;

exports.f = require('./_descriptors') ? gOPD : function getOwnPropertyDescriptor(O, P) {
  O = toIObject(O);
  P = toPrimitive(P, true);
  if (IE8_DOM_DEFINE) try {
    return gOPD(O, P);
  } catch (e) { /* empty */ }
  if (has(O, P)) return createDesc(!pIE.f.call(O, P), O[P]);
};

},{"./_descriptors":73,"./_has":81,"./_ie8-dom-define":84,"./_object-pie":108,"./_property-desc":110,"./_to-iobject":123,"./_to-primitive":126}],102:[function(require,module,exports){
// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
var toIObject = require('./_to-iobject');
var gOPN = require('./_object-gopn').f;
var toString = {}.toString;

var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
  ? Object.getOwnPropertyNames(window) : [];

var getWindowNames = function (it) {
  try {
    return gOPN(it);
  } catch (e) {
    return windowNames.slice();
  }
};

module.exports.f = function getOwnPropertyNames(it) {
  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));
};

},{"./_object-gopn":103,"./_to-iobject":123}],103:[function(require,module,exports){
// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
var $keys = require('./_object-keys-internal');
var hiddenKeys = require('./_enum-bug-keys').concat('length', 'prototype');

exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return $keys(O, hiddenKeys);
};

},{"./_enum-bug-keys":75,"./_object-keys-internal":106}],104:[function(require,module,exports){
exports.f = Object.getOwnPropertySymbols;

},{}],105:[function(require,module,exports){
// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
var has = require('./_has');
var toObject = require('./_to-object');
var IE_PROTO = require('./_shared-key')('IE_PROTO');
var ObjectProto = Object.prototype;

module.exports = Object.getPrototypeOf || function (O) {
  O = toObject(O);
  if (has(O, IE_PROTO)) return O[IE_PROTO];
  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
    return O.constructor.prototype;
  } return O instanceof Object ? ObjectProto : null;
};

},{"./_has":81,"./_shared-key":118,"./_to-object":125}],106:[function(require,module,exports){
var has = require('./_has');
var toIObject = require('./_to-iobject');
var arrayIndexOf = require('./_array-includes')(false);
var IE_PROTO = require('./_shared-key')('IE_PROTO');

module.exports = function (object, names) {
  var O = toIObject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) if (key != IE_PROTO) has(O, key) && result.push(key);
  // Don't enum bug & hidden keys
  while (names.length > i) if (has(O, key = names[i++])) {
    ~arrayIndexOf(result, key) || result.push(key);
  }
  return result;
};

},{"./_array-includes":60,"./_has":81,"./_shared-key":118,"./_to-iobject":123}],107:[function(require,module,exports){
// 19.1.2.14 / 15.2.3.14 Object.keys(O)
var $keys = require('./_object-keys-internal');
var enumBugKeys = require('./_enum-bug-keys');

module.exports = Object.keys || function keys(O) {
  return $keys(O, enumBugKeys);
};

},{"./_enum-bug-keys":75,"./_object-keys-internal":106}],108:[function(require,module,exports){
exports.f = {}.propertyIsEnumerable;

},{}],109:[function(require,module,exports){
// most Object methods by ES6 should accept primitives
var $export = require('./_export');
var core = require('./_core');
var fails = require('./_fails');
module.exports = function (KEY, exec) {
  var fn = (core.Object || {})[KEY] || Object[KEY];
  var exp = {};
  exp[KEY] = exec(fn);
  $export($export.S + $export.F * fails(function () { fn(1); }), 'Object', exp);
};

},{"./_core":69,"./_export":77,"./_fails":78}],110:[function(require,module,exports){
module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};

},{}],111:[function(require,module,exports){
var hide = require('./_hide');
module.exports = function (target, src, safe) {
  for (var key in src) {
    if (safe && target[key]) target[key] = src[key];
    else hide(target, key, src[key]);
  } return target;
};

},{"./_hide":82}],112:[function(require,module,exports){
module.exports = require('./_hide');

},{"./_hide":82}],113:[function(require,module,exports){
'use strict';
// https://tc39.github.io/proposal-setmap-offrom/
var $export = require('./_export');
var aFunction = require('./_a-function');
var ctx = require('./_ctx');
var forOf = require('./_for-of');

module.exports = function (COLLECTION) {
  $export($export.S, COLLECTION, { from: function from(source /* , mapFn, thisArg */) {
    var mapFn = arguments[1];
    var mapping, A, n, cb;
    aFunction(this);
    mapping = mapFn !== undefined;
    if (mapping) aFunction(mapFn);
    if (source == undefined) return new this();
    A = [];
    if (mapping) {
      n = 0;
      cb = ctx(mapFn, arguments[2], 2);
      forOf(source, false, function (nextItem) {
        A.push(cb(nextItem, n++));
      });
    } else {
      forOf(source, false, A.push, A);
    }
    return new this(A);
  } });
};

},{"./_a-function":55,"./_ctx":71,"./_export":77,"./_for-of":79}],114:[function(require,module,exports){
'use strict';
// https://tc39.github.io/proposal-setmap-offrom/
var $export = require('./_export');

module.exports = function (COLLECTION) {
  $export($export.S, COLLECTION, { of: function of() {
    var length = arguments.length;
    var A = new Array(length);
    while (length--) A[length] = arguments[length];
    return new this(A);
  } });
};

},{"./_export":77}],115:[function(require,module,exports){
// Works with __proto__ only. Old v8 can't work with null proto objects.
/* eslint-disable no-proto */
var isObject = require('./_is-object');
var anObject = require('./_an-object');
var check = function (O, proto) {
  anObject(O);
  if (!isObject(proto) && proto !== null) throw TypeError(proto + ": can't set as prototype!");
};
module.exports = {
  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
    function (test, buggy, set) {
      try {
        set = require('./_ctx')(Function.call, require('./_object-gopd').f(Object.prototype, '__proto__').set, 2);
        set(test, []);
        buggy = !(test instanceof Array);
      } catch (e) { buggy = true; }
      return function setPrototypeOf(O, proto) {
        check(O, proto);
        if (buggy) O.__proto__ = proto;
        else set(O, proto);
        return O;
      };
    }({}, false) : undefined),
  check: check
};

},{"./_an-object":58,"./_ctx":71,"./_is-object":88,"./_object-gopd":101}],116:[function(require,module,exports){
'use strict';
var global = require('./_global');
var core = require('./_core');
var dP = require('./_object-dp');
var DESCRIPTORS = require('./_descriptors');
var SPECIES = require('./_wks')('species');

module.exports = function (KEY) {
  var C = typeof core[KEY] == 'function' ? core[KEY] : global[KEY];
  if (DESCRIPTORS && C && !C[SPECIES]) dP.f(C, SPECIES, {
    configurable: true,
    get: function () { return this; }
  });
};

},{"./_core":69,"./_descriptors":73,"./_global":80,"./_object-dp":99,"./_wks":131}],117:[function(require,module,exports){
var def = require('./_object-dp').f;
var has = require('./_has');
var TAG = require('./_wks')('toStringTag');

module.exports = function (it, tag, stat) {
  if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag });
};

},{"./_has":81,"./_object-dp":99,"./_wks":131}],118:[function(require,module,exports){
var shared = require('./_shared')('keys');
var uid = require('./_uid');
module.exports = function (key) {
  return shared[key] || (shared[key] = uid(key));
};

},{"./_shared":119,"./_uid":127}],119:[function(require,module,exports){
var core = require('./_core');
var global = require('./_global');
var SHARED = '__core-js_shared__';
var store = global[SHARED] || (global[SHARED] = {});

(module.exports = function (key, value) {
  return store[key] || (store[key] = value !== undefined ? value : {});
})('versions', []).push({
  version: core.version,
  mode: require('./_library') ? 'pure' : 'global',
  copyright: '© 2019 Denis Pushkarev (zloirock.ru)'
});

},{"./_core":69,"./_global":80,"./_library":95}],120:[function(require,module,exports){
var toInteger = require('./_to-integer');
var defined = require('./_defined');
// true  -> String#at
// false -> String#codePointAt
module.exports = function (TO_STRING) {
  return function (that, pos) {
    var s = String(defined(that));
    var i = toInteger(pos);
    var l = s.length;
    var a, b;
    if (i < 0 || i >= l) return TO_STRING ? '' : undefined;
    a = s.charCodeAt(i);
    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
      ? TO_STRING ? s.charAt(i) : a
      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
  };
};

},{"./_defined":72,"./_to-integer":122}],121:[function(require,module,exports){
var toInteger = require('./_to-integer');
var max = Math.max;
var min = Math.min;
module.exports = function (index, length) {
  index = toInteger(index);
  return index < 0 ? max(index + length, 0) : min(index, length);
};

},{"./_to-integer":122}],122:[function(require,module,exports){
// 7.1.4 ToInteger
var ceil = Math.ceil;
var floor = Math.floor;
module.exports = function (it) {
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
};

},{}],123:[function(require,module,exports){
// to indexed object, toObject with fallback for non-array-like ES3 strings
var IObject = require('./_iobject');
var defined = require('./_defined');
module.exports = function (it) {
  return IObject(defined(it));
};

},{"./_defined":72,"./_iobject":85}],124:[function(require,module,exports){
// 7.1.15 ToLength
var toInteger = require('./_to-integer');
var min = Math.min;
module.exports = function (it) {
  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
};

},{"./_to-integer":122}],125:[function(require,module,exports){
// 7.1.13 ToObject(argument)
var defined = require('./_defined');
module.exports = function (it) {
  return Object(defined(it));
};

},{"./_defined":72}],126:[function(require,module,exports){
// 7.1.1 ToPrimitive(input [, PreferredType])
var isObject = require('./_is-object');
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
module.exports = function (it, S) {
  if (!isObject(it)) return it;
  var fn, val;
  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;
  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  throw TypeError("Can't convert object to primitive value");
};

},{"./_is-object":88}],127:[function(require,module,exports){
var id = 0;
var px = Math.random();
module.exports = function (key) {
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
};

},{}],128:[function(require,module,exports){
var isObject = require('./_is-object');
module.exports = function (it, TYPE) {
  if (!isObject(it) || it._t !== TYPE) throw TypeError('Incompatible receiver, ' + TYPE + ' required!');
  return it;
};

},{"./_is-object":88}],129:[function(require,module,exports){
var global = require('./_global');
var core = require('./_core');
var LIBRARY = require('./_library');
var wksExt = require('./_wks-ext');
var defineProperty = require('./_object-dp').f;
module.exports = function (name) {
  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});
  if (name.charAt(0) != '_' && !(name in $Symbol)) defineProperty($Symbol, name, { value: wksExt.f(name) });
};

},{"./_core":69,"./_global":80,"./_library":95,"./_object-dp":99,"./_wks-ext":130}],130:[function(require,module,exports){
exports.f = require('./_wks');

},{"./_wks":131}],131:[function(require,module,exports){
var store = require('./_shared')('wks');
var uid = require('./_uid');
var Symbol = require('./_global').Symbol;
var USE_SYMBOL = typeof Symbol == 'function';

var $exports = module.exports = function (name) {
  return store[name] || (store[name] =
    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
};

$exports.store = store;

},{"./_global":80,"./_shared":119,"./_uid":127}],132:[function(require,module,exports){
var classof = require('./_classof');
var ITERATOR = require('./_wks')('iterator');
var Iterators = require('./_iterators');
module.exports = require('./_core').getIteratorMethod = function (it) {
  if (it != undefined) return it[ITERATOR]
    || it['@@iterator']
    || Iterators[classof(it)];
};

},{"./_classof":64,"./_core":69,"./_iterators":94,"./_wks":131}],133:[function(require,module,exports){
var anObject = require('./_an-object');
var get = require('./core.get-iterator-method');
module.exports = require('./_core').getIterator = function (it) {
  var iterFn = get(it);
  if (typeof iterFn != 'function') throw TypeError(it + ' is not iterable!');
  return anObject(iterFn.call(it));
};

},{"./_an-object":58,"./_core":69,"./core.get-iterator-method":132}],134:[function(require,module,exports){
'use strict';
var ctx = require('./_ctx');
var $export = require('./_export');
var toObject = require('./_to-object');
var call = require('./_iter-call');
var isArrayIter = require('./_is-array-iter');
var toLength = require('./_to-length');
var createProperty = require('./_create-property');
var getIterFn = require('./core.get-iterator-method');

$export($export.S + $export.F * !require('./_iter-detect')(function (iter) { Array.from(iter); }), 'Array', {
  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
  from: function from(arrayLike /* , mapfn = undefined, thisArg = undefined */) {
    var O = toObject(arrayLike);
    var C = typeof this == 'function' ? this : Array;
    var aLen = arguments.length;
    var mapfn = aLen > 1 ? arguments[1] : undefined;
    var mapping = mapfn !== undefined;
    var index = 0;
    var iterFn = getIterFn(O);
    var length, result, step, iterator;
    if (mapping) mapfn = ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2);
    // if object isn't iterable or it's array with default iterator - use simple case
    if (iterFn != undefined && !(C == Array && isArrayIter(iterFn))) {
      for (iterator = iterFn.call(O), result = new C(); !(step = iterator.next()).done; index++) {
        createProperty(result, index, mapping ? call(iterator, mapfn, [step.value, index], true) : step.value);
      }
    } else {
      length = toLength(O.length);
      for (result = new C(length); length > index; index++) {
        createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);
      }
    }
    result.length = index;
    return result;
  }
});

},{"./_create-property":70,"./_ctx":71,"./_export":77,"./_is-array-iter":86,"./_iter-call":89,"./_iter-detect":92,"./_to-length":124,"./_to-object":125,"./core.get-iterator-method":132}],135:[function(require,module,exports){
'use strict';
var addToUnscopables = require('./_add-to-unscopables');
var step = require('./_iter-step');
var Iterators = require('./_iterators');
var toIObject = require('./_to-iobject');

// 22.1.3.4 Array.prototype.entries()
// 22.1.3.13 Array.prototype.keys()
// 22.1.3.29 Array.prototype.values()
// 22.1.3.30 Array.prototype[@@iterator]()
module.exports = require('./_iter-define')(Array, 'Array', function (iterated, kind) {
  this._t = toIObject(iterated); // target
  this._i = 0;                   // next index
  this._k = kind;                // kind
// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var kind = this._k;
  var index = this._i++;
  if (!O || index >= O.length) {
    this._t = undefined;
    return step(1);
  }
  if (kind == 'keys') return step(0, index);
  if (kind == 'values') return step(0, O[index]);
  return step(0, [index, O[index]]);
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
Iterators.Arguments = Iterators.Array;

addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');

},{"./_add-to-unscopables":56,"./_iter-define":91,"./_iter-step":93,"./_iterators":94,"./_to-iobject":123}],136:[function(require,module,exports){
'use strict';
var strong = require('./_collection-strong');
var validate = require('./_validate-collection');
var MAP = 'Map';

// 23.1 Map Objects
module.exports = require('./_collection')(MAP, function (get) {
  return function Map() { return get(this, arguments.length > 0 ? arguments[0] : undefined); };
}, {
  // 23.1.3.6 Map.prototype.get(key)
  get: function get(key) {
    var entry = strong.getEntry(validate(this, MAP), key);
    return entry && entry.v;
  },
  // 23.1.3.9 Map.prototype.set(key, value)
  set: function set(key, value) {
    return strong.def(validate(this, MAP), key === 0 ? 0 : key, value);
  }
}, strong, true);

},{"./_collection":68,"./_collection-strong":66,"./_validate-collection":128}],137:[function(require,module,exports){
// 20.1.2.1 Number.EPSILON
var $export = require('./_export');

$export($export.S, 'Number', { EPSILON: Math.pow(2, -52) });

},{"./_export":77}],138:[function(require,module,exports){
// 19.1.3.1 Object.assign(target, source)
var $export = require('./_export');

$export($export.S + $export.F, 'Object', { assign: require('./_object-assign') });

},{"./_export":77,"./_object-assign":97}],139:[function(require,module,exports){
var $export = require('./_export');
// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
$export($export.S, 'Object', { create: require('./_object-create') });

},{"./_export":77,"./_object-create":98}],140:[function(require,module,exports){
var $export = require('./_export');
// 19.1.2.3 / 15.2.3.7 Object.defineProperties(O, Properties)
$export($export.S + $export.F * !require('./_descriptors'), 'Object', { defineProperties: require('./_object-dps') });

},{"./_descriptors":73,"./_export":77,"./_object-dps":100}],141:[function(require,module,exports){
var $export = require('./_export');
// 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)
$export($export.S + $export.F * !require('./_descriptors'), 'Object', { defineProperty: require('./_object-dp').f });

},{"./_descriptors":73,"./_export":77,"./_object-dp":99}],142:[function(require,module,exports){
// 19.1.2.5 Object.freeze(O)
var isObject = require('./_is-object');
var meta = require('./_meta').onFreeze;

require('./_object-sap')('freeze', function ($freeze) {
  return function freeze(it) {
    return $freeze && isObject(it) ? $freeze(meta(it)) : it;
  };
});

},{"./_is-object":88,"./_meta":96,"./_object-sap":109}],143:[function(require,module,exports){
// 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
var toIObject = require('./_to-iobject');
var $getOwnPropertyDescriptor = require('./_object-gopd').f;

require('./_object-sap')('getOwnPropertyDescriptor', function () {
  return function getOwnPropertyDescriptor(it, key) {
    return $getOwnPropertyDescriptor(toIObject(it), key);
  };
});

},{"./_object-gopd":101,"./_object-sap":109,"./_to-iobject":123}],144:[function(require,module,exports){
// 19.1.2.14 Object.keys(O)
var toObject = require('./_to-object');
var $keys = require('./_object-keys');

require('./_object-sap')('keys', function () {
  return function keys(it) {
    return $keys(toObject(it));
  };
});

},{"./_object-keys":107,"./_object-sap":109,"./_to-object":125}],145:[function(require,module,exports){
// 19.1.3.19 Object.setPrototypeOf(O, proto)
var $export = require('./_export');
$export($export.S, 'Object', { setPrototypeOf: require('./_set-proto').set });

},{"./_export":77,"./_set-proto":115}],146:[function(require,module,exports){
arguments[4][35][0].apply(exports,arguments)
},{"dup":35}],147:[function(require,module,exports){
'use strict';
var strong = require('./_collection-strong');
var validate = require('./_validate-collection');
var SET = 'Set';

// 23.2 Set Objects
module.exports = require('./_collection')(SET, function (get) {
  return function Set() { return get(this, arguments.length > 0 ? arguments[0] : undefined); };
}, {
  // 23.2.3.1 Set.prototype.add(value)
  add: function add(value) {
    return strong.def(validate(this, SET), value = value === 0 ? 0 : value, value);
  }
}, strong);

},{"./_collection":68,"./_collection-strong":66,"./_validate-collection":128}],148:[function(require,module,exports){
var $export = require('./_export');
var toAbsoluteIndex = require('./_to-absolute-index');
var fromCharCode = String.fromCharCode;
var $fromCodePoint = String.fromCodePoint;

// length should be 1, old FF problem
$export($export.S + $export.F * (!!$fromCodePoint && $fromCodePoint.length != 1), 'String', {
  // 21.1.2.2 String.fromCodePoint(...codePoints)
  fromCodePoint: function fromCodePoint(x) { // eslint-disable-line no-unused-vars
    var res = [];
    var aLen = arguments.length;
    var i = 0;
    var code;
    while (aLen > i) {
      code = +arguments[i++];
      if (toAbsoluteIndex(code, 0x10ffff) !== code) throw RangeError(code + ' is not a valid code point');
      res.push(code < 0x10000
        ? fromCharCode(code)
        : fromCharCode(((code -= 0x10000) >> 10) + 0xd800, code % 0x400 + 0xdc00)
      );
    } return res.join('');
  }
});

},{"./_export":77,"./_to-absolute-index":121}],149:[function(require,module,exports){
'use strict';
var $at = require('./_string-at')(true);

// 21.1.3.27 String.prototype[@@iterator]()
require('./_iter-define')(String, 'String', function (iterated) {
  this._t = String(iterated); // target
  this._i = 0;                // next index
// 21.1.5.2.1 %StringIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var index = this._i;
  var point;
  if (index >= O.length) return { value: undefined, done: true };
  point = $at(O, index);
  this._i += point.length;
  return { value: point, done: false };
});

},{"./_iter-define":91,"./_string-at":120}],150:[function(require,module,exports){
'use strict';
// ECMAScript 6 symbols shim
var global = require('./_global');
var has = require('./_has');
var DESCRIPTORS = require('./_descriptors');
var $export = require('./_export');
var redefine = require('./_redefine');
var META = require('./_meta').KEY;
var $fails = require('./_fails');
var shared = require('./_shared');
var setToStringTag = require('./_set-to-string-tag');
var uid = require('./_uid');
var wks = require('./_wks');
var wksExt = require('./_wks-ext');
var wksDefine = require('./_wks-define');
var enumKeys = require('./_enum-keys');
var isArray = require('./_is-array');
var anObject = require('./_an-object');
var isObject = require('./_is-object');
var toObject = require('./_to-object');
var toIObject = require('./_to-iobject');
var toPrimitive = require('./_to-primitive');
var createDesc = require('./_property-desc');
var _create = require('./_object-create');
var gOPNExt = require('./_object-gopn-ext');
var $GOPD = require('./_object-gopd');
var $GOPS = require('./_object-gops');
var $DP = require('./_object-dp');
var $keys = require('./_object-keys');
var gOPD = $GOPD.f;
var dP = $DP.f;
var gOPN = gOPNExt.f;
var $Symbol = global.Symbol;
var $JSON = global.JSON;
var _stringify = $JSON && $JSON.stringify;
var PROTOTYPE = 'prototype';
var HIDDEN = wks('_hidden');
var TO_PRIMITIVE = wks('toPrimitive');
var isEnum = {}.propertyIsEnumerable;
var SymbolRegistry = shared('symbol-registry');
var AllSymbols = shared('symbols');
var OPSymbols = shared('op-symbols');
var ObjectProto = Object[PROTOTYPE];
var USE_NATIVE = typeof $Symbol == 'function' && !!$GOPS.f;
var QObject = global.QObject;
// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;

// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
var setSymbolDesc = DESCRIPTORS && $fails(function () {
  return _create(dP({}, 'a', {
    get: function () { return dP(this, 'a', { value: 7 }).a; }
  })).a != 7;
}) ? function (it, key, D) {
  var protoDesc = gOPD(ObjectProto, key);
  if (protoDesc) delete ObjectProto[key];
  dP(it, key, D);
  if (protoDesc && it !== ObjectProto) dP(ObjectProto, key, protoDesc);
} : dP;

var wrap = function (tag) {
  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);
  sym._k = tag;
  return sym;
};

var isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function (it) {
  return typeof it == 'symbol';
} : function (it) {
  return it instanceof $Symbol;
};

var $defineProperty = function defineProperty(it, key, D) {
  if (it === ObjectProto) $defineProperty(OPSymbols, key, D);
  anObject(it);
  key = toPrimitive(key, true);
  anObject(D);
  if (has(AllSymbols, key)) {
    if (!D.enumerable) {
      if (!has(it, HIDDEN)) dP(it, HIDDEN, createDesc(1, {}));
      it[HIDDEN][key] = true;
    } else {
      if (has(it, HIDDEN) && it[HIDDEN][key]) it[HIDDEN][key] = false;
      D = _create(D, { enumerable: createDesc(0, false) });
    } return setSymbolDesc(it, key, D);
  } return dP(it, key, D);
};
var $defineProperties = function defineProperties(it, P) {
  anObject(it);
  var keys = enumKeys(P = toIObject(P));
  var i = 0;
  var l = keys.length;
  var key;
  while (l > i) $defineProperty(it, key = keys[i++], P[key]);
  return it;
};
var $create = function create(it, P) {
  return P === undefined ? _create(it) : $defineProperties(_create(it), P);
};
var $propertyIsEnumerable = function propertyIsEnumerable(key) {
  var E = isEnum.call(this, key = toPrimitive(key, true));
  if (this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return false;
  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
};
var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) {
  it = toIObject(it);
  key = toPrimitive(key, true);
  if (it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return;
  var D = gOPD(it, key);
  if (D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) D.enumerable = true;
  return D;
};
var $getOwnPropertyNames = function getOwnPropertyNames(it) {
  var names = gOPN(toIObject(it));
  var result = [];
  var i = 0;
  var key;
  while (names.length > i) {
    if (!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META) result.push(key);
  } return result;
};
var $getOwnPropertySymbols = function getOwnPropertySymbols(it) {
  var IS_OP = it === ObjectProto;
  var names = gOPN(IS_OP ? OPSymbols : toIObject(it));
  var result = [];
  var i = 0;
  var key;
  while (names.length > i) {
    if (has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true)) result.push(AllSymbols[key]);
  } return result;
};

// 19.4.1.1 Symbol([description])
if (!USE_NATIVE) {
  $Symbol = function Symbol() {
    if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor!');
    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);
    var $set = function (value) {
      if (this === ObjectProto) $set.call(OPSymbols, value);
      if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
      setSymbolDesc(this, tag, createDesc(1, value));
    };
    if (DESCRIPTORS && setter) setSymbolDesc(ObjectProto, tag, { configurable: true, set: $set });
    return wrap(tag);
  };
  redefine($Symbol[PROTOTYPE], 'toString', function toString() {
    return this._k;
  });

  $GOPD.f = $getOwnPropertyDescriptor;
  $DP.f = $defineProperty;
  require('./_object-gopn').f = gOPNExt.f = $getOwnPropertyNames;
  require('./_object-pie').f = $propertyIsEnumerable;
  $GOPS.f = $getOwnPropertySymbols;

  if (DESCRIPTORS && !require('./_library')) {
    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
  }

  wksExt.f = function (name) {
    return wrap(wks(name));
  };
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, { Symbol: $Symbol });

for (var es6Symbols = (
  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'
).split(','), j = 0; es6Symbols.length > j;)wks(es6Symbols[j++]);

for (var wellKnownSymbols = $keys(wks.store), k = 0; wellKnownSymbols.length > k;) wksDefine(wellKnownSymbols[k++]);

$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {
  // 19.4.2.1 Symbol.for(key)
  'for': function (key) {
    return has(SymbolRegistry, key += '')
      ? SymbolRegistry[key]
      : SymbolRegistry[key] = $Symbol(key);
  },
  // 19.4.2.5 Symbol.keyFor(sym)
  keyFor: function keyFor(sym) {
    if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol!');
    for (var key in SymbolRegistry) if (SymbolRegistry[key] === sym) return key;
  },
  useSetter: function () { setter = true; },
  useSimple: function () { setter = false; }
});

$export($export.S + $export.F * !USE_NATIVE, 'Object', {
  // 19.1.2.2 Object.create(O [, Properties])
  create: $create,
  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
  defineProperty: $defineProperty,
  // 19.1.2.3 Object.defineProperties(O, Properties)
  defineProperties: $defineProperties,
  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
  // 19.1.2.7 Object.getOwnPropertyNames(O)
  getOwnPropertyNames: $getOwnPropertyNames,
  // 19.1.2.8 Object.getOwnPropertySymbols(O)
  getOwnPropertySymbols: $getOwnPropertySymbols
});

// Chrome 38 and 39 `Object.getOwnPropertySymbols` fails on primitives
// https://bugs.chromium.org/p/v8/issues/detail?id=3443
var FAILS_ON_PRIMITIVES = $fails(function () { $GOPS.f(1); });

$export($export.S + $export.F * FAILS_ON_PRIMITIVES, 'Object', {
  getOwnPropertySymbols: function getOwnPropertySymbols(it) {
    return $GOPS.f(toObject(it));
  }
});

// 24.3.2 JSON.stringify(value [, replacer [, space]])
$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function () {
  var S = $Symbol();
  // MS Edge converts symbol values to JSON as {}
  // WebKit converts symbol values to JSON as null
  // V8 throws on boxed symbols
  return _stringify([S]) != '[null]' || _stringify({ a: S }) != '{}' || _stringify(Object(S)) != '{}';
})), 'JSON', {
  stringify: function stringify(it) {
    var args = [it];
    var i = 1;
    var replacer, $replacer;
    while (arguments.length > i) args.push(arguments[i++]);
    $replacer = replacer = args[1];
    if (!isObject(replacer) && it === undefined || isSymbol(it)) return; // IE8 returns string on undefined
    if (!isArray(replacer)) replacer = function (key, value) {
      if (typeof $replacer == 'function') value = $replacer.call(this, key, value);
      if (!isSymbol(value)) return value;
    };
    args[1] = replacer;
    return _stringify.apply($JSON, args);
  }
});

// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)
$Symbol[PROTOTYPE][TO_PRIMITIVE] || require('./_hide')($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
// 19.4.3.5 Symbol.prototype[@@toStringTag]
setToStringTag($Symbol, 'Symbol');
// 20.2.1.9 Math[@@toStringTag]
setToStringTag(Math, 'Math', true);
// 24.3.3 JSON[@@toStringTag]
setToStringTag(global.JSON, 'JSON', true);

},{"./_an-object":58,"./_descriptors":73,"./_enum-keys":76,"./_export":77,"./_fails":78,"./_global":80,"./_has":81,"./_hide":82,"./_is-array":87,"./_is-object":88,"./_library":95,"./_meta":96,"./_object-create":98,"./_object-dp":99,"./_object-gopd":101,"./_object-gopn":103,"./_object-gopn-ext":102,"./_object-gops":104,"./_object-keys":107,"./_object-pie":108,"./_property-desc":110,"./_redefine":112,"./_set-to-string-tag":117,"./_shared":119,"./_to-iobject":123,"./_to-object":125,"./_to-primitive":126,"./_uid":127,"./_wks":131,"./_wks-define":129,"./_wks-ext":130}],151:[function(require,module,exports){
// https://tc39.github.io/proposal-setmap-offrom/#sec-map.from
require('./_set-collection-from')('Map');

},{"./_set-collection-from":113}],152:[function(require,module,exports){
// https://tc39.github.io/proposal-setmap-offrom/#sec-map.of
require('./_set-collection-of')('Map');

},{"./_set-collection-of":114}],153:[function(require,module,exports){
// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var $export = require('./_export');

$export($export.P + $export.R, 'Map', { toJSON: require('./_collection-to-json')('Map') });

},{"./_collection-to-json":67,"./_export":77}],154:[function(require,module,exports){
// https://tc39.github.io/proposal-setmap-offrom/#sec-set.from
require('./_set-collection-from')('Set');

},{"./_set-collection-from":113}],155:[function(require,module,exports){
// https://tc39.github.io/proposal-setmap-offrom/#sec-set.of
require('./_set-collection-of')('Set');

},{"./_set-collection-of":114}],156:[function(require,module,exports){
// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var $export = require('./_export');

$export($export.P + $export.R, 'Set', { toJSON: require('./_collection-to-json')('Set') });

},{"./_collection-to-json":67,"./_export":77}],157:[function(require,module,exports){
require('./_wks-define')('asyncIterator');

},{"./_wks-define":129}],158:[function(require,module,exports){
require('./_wks-define')('observable');

},{"./_wks-define":129}],159:[function(require,module,exports){
require('./es6.array.iterator');
var global = require('./_global');
var hide = require('./_hide');
var Iterators = require('./_iterators');
var TO_STRING_TAG = require('./_wks')('toStringTag');

var DOMIterables = ('CSSRuleList,CSSStyleDeclaration,CSSValueList,ClientRectList,DOMRectList,DOMStringList,' +
  'DOMTokenList,DataTransferItemList,FileList,HTMLAllCollection,HTMLCollection,HTMLFormElement,HTMLSelectElement,' +
  'MediaList,MimeTypeArray,NamedNodeMap,NodeList,PaintRequestList,Plugin,PluginArray,SVGLengthList,SVGNumberList,' +
  'SVGPathSegList,SVGPointList,SVGStringList,SVGTransformList,SourceBufferList,StyleSheetList,TextTrackCueList,' +
  'TextTrackList,TouchList').split(',');

for (var i = 0; i < DOMIterables.length; i++) {
  var NAME = DOMIterables[i];
  var Collection = global[NAME];
  var proto = Collection && Collection.prototype;
  if (proto && !proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME);
  Iterators[NAME] = Iterators.Array;
}

},{"./_global":80,"./_hide":82,"./_iterators":94,"./_wks":131,"./es6.array.iterator":135}],160:[function(require,module,exports){
(function (Buffer){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.

function isArray(arg) {
  if (Array.isArray) {
    return Array.isArray(arg);
  }
  return objectToString(arg) === '[object Array]';
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = Buffer.isBuffer;

function objectToString(o) {
  return Object.prototype.toString.call(o);
}

}).call(this,{"isBuffer":require("../../is-buffer/index.js")})
},{"../../is-buffer/index.js":172}],161:[function(require,module,exports){
var objectKeys = require('object-keys');
var isArguments = require('is-arguments');
var is = require('object-is');
var isRegex = require('is-regex');
var flags = require('regexp.prototype.flags');
var isDate = require('is-date-object');

var getTime = Date.prototype.getTime;

function deepEqual(actual, expected, options) {
  var opts = options || {};

  // 7.1. All identical values are equivalent, as determined by ===.
  if (opts.strict ? is(actual, expected) : actual === expected) {
    return true;
  }

  // 7.3. Other pairs that do not both pass typeof value == 'object', equivalence is determined by ==.
  if (!actual || !expected || (typeof actual !== 'object' && typeof expected !== 'object')) {
    return opts.strict ? is(actual, expected) : actual == expected;
  }

  /*
   * 7.4. For all other Object pairs, including Array objects, equivalence is
   * determined by having the same number of owned properties (as verified
   * with Object.prototype.hasOwnProperty.call), the same set of keys
   * (although not necessarily the same order), equivalent values for every
   * corresponding key, and an identical 'prototype' property. Note: this
   * accounts for both named and indexed properties on Arrays.
   */
  // eslint-disable-next-line no-use-before-define
  return objEquiv(actual, expected, opts);
}

function isUndefinedOrNull(value) {
  return value === null || value === undefined;
}

function isBuffer(x) {
  if (!x || typeof x !== 'object' || typeof x.length !== 'number') {
    return false;
  }
  if (typeof x.copy !== 'function' || typeof x.slice !== 'function') {
    return false;
  }
  if (x.length > 0 && typeof x[0] !== 'number') {
    return false;
  }
  return true;
}

function objEquiv(a, b, opts) {
  /* eslint max-statements: [2, 50] */
  var i, key;
  if (typeof a !== typeof b) { return false; }
  if (isUndefinedOrNull(a) || isUndefinedOrNull(b)) { return false; }

  // an identical 'prototype' property.
  if (a.prototype !== b.prototype) { return false; }

  if (isArguments(a) !== isArguments(b)) { return false; }

  var aIsRegex = isRegex(a);
  var bIsRegex = isRegex(b);
  if (aIsRegex !== bIsRegex) { return false; }
  if (aIsRegex || bIsRegex) {
    return a.source === b.source && flags(a) === flags(b);
  }

  if (isDate(a) && isDate(b)) {
    return getTime.call(a) === getTime.call(b);
  }

  var aIsBuffer = isBuffer(a);
  var bIsBuffer = isBuffer(b);
  if (aIsBuffer !== bIsBuffer) { return false; }
  if (aIsBuffer || bIsBuffer) { // && would work too, because both are true or both false here
    if (a.length !== b.length) { return false; }
    for (i = 0; i < a.length; i++) {
      if (a[i] !== b[i]) { return false; }
    }
    return true;
  }

  if (typeof a !== typeof b) { return false; }

  try {
    var ka = objectKeys(a);
    var kb = objectKeys(b);
  } catch (e) { // happens when one is a string literal and the other isn't
    return false;
  }
  // having the same number of owned properties (keys incorporates hasOwnProperty)
  if (ka.length !== kb.length) { return false; }

  // the same set of keys (although not necessarily the same order),
  ka.sort();
  kb.sort();
  // ~~~cheap key test
  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] != kb[i]) { return false; }
  }
  // equivalent values for every corresponding key, and ~~~possibly expensive deep test
  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!deepEqual(a[key], b[key], opts)) { return false; }
  }

  return true;
}

module.exports = deepEqual;

},{"is-arguments":171,"is-date-object":173,"is-regex":174,"object-is":176,"object-keys":178,"regexp.prototype.flags":198}],162:[function(require,module,exports){
'use strict';

var keys = require('object-keys');
var hasSymbols = typeof Symbol === 'function' && typeof Symbol('foo') === 'symbol';

var toStr = Object.prototype.toString;
var concat = Array.prototype.concat;
var origDefineProperty = Object.defineProperty;

var isFunction = function (fn) {
	return typeof fn === 'function' && toStr.call(fn) === '[object Function]';
};

var arePropertyDescriptorsSupported = function () {
	var obj = {};
	try {
		origDefineProperty(obj, 'x', { enumerable: false, value: obj });
		// eslint-disable-next-line no-unused-vars, no-restricted-syntax
		for (var _ in obj) { // jscs:ignore disallowUnusedVariables
			return false;
		}
		return obj.x === obj;
	} catch (e) { /* this is IE 8. */
		return false;
	}
};
var supportsDescriptors = origDefineProperty && arePropertyDescriptorsSupported();

var defineProperty = function (object, name, value, predicate) {
	if (name in object && (!isFunction(predicate) || !predicate())) {
		return;
	}
	if (supportsDescriptors) {
		origDefineProperty(object, name, {
			configurable: true,
			enumerable: false,
			value: value,
			writable: true
		});
	} else {
		object[name] = value;
	}
};

var defineProperties = function (object, map) {
	var predicates = arguments.length > 2 ? arguments[2] : {};
	var props = keys(map);
	if (hasSymbols) {
		props = concat.call(props, Object.getOwnPropertySymbols(map));
	}
	for (var i = 0; i < props.length; i += 1) {
		defineProperty(object, props[i], map[props[i]], predicates[props[i]]);
	}
};

defineProperties.supportsDescriptors = !!supportsDescriptors;

module.exports = defineProperties;

},{"object-keys":178}],163:[function(require,module,exports){
'use strict';

var INITIAL_STATE = 1;
var FAIL_STATE = 0;
/**
 * A StateMachine represents a deterministic finite automaton.
 * It can perform matches over a sequence of values, similar to a regular expression.
 */

class StateMachine {
  constructor(dfa) {
    this.stateTable = dfa.stateTable;
    this.accepting = dfa.accepting;
    this.tags = dfa.tags;
  }
  /**
   * Returns an iterable object that yields pattern matches over the input sequence.
   * Matches are of the form [startIndex, endIndex, tags].
   */


  match(str) {
    var self = this;
    return {
      *[Symbol.iterator]() {
        var state = INITIAL_STATE;
        var startRun = null;
        var lastAccepting = null;
        var lastState = null;

        for (var p = 0; p < str.length; p++) {
          var c = str[p];
          lastState = state;
          state = self.stateTable[state][c];

          if (state === FAIL_STATE) {
            // yield the last match if any
            if (startRun != null && lastAccepting != null && lastAccepting >= startRun) {
              yield [startRun, lastAccepting, self.tags[lastState]];
            } // reset the state as if we started over from the initial state


            state = self.stateTable[INITIAL_STATE][c];
            startRun = null;
          } // start a run if not in the failure state


          if (state !== FAIL_STATE && startRun == null) {
            startRun = p;
          } // if accepting, mark the potential match end


          if (self.accepting[state]) {
            lastAccepting = p;
          } // reset the state to the initial state if we get into the failure state


          if (state === FAIL_STATE) {
            state = INITIAL_STATE;
          }
        } // yield the last match if any


        if (startRun != null && lastAccepting != null && lastAccepting >= startRun) {
          yield [startRun, lastAccepting, self.tags[state]];
        }
      }

    };
  }
  /**
   * For each match over the input sequence, action functions matching
   * the tag definitions in the input pattern are called with the startIndex,
   * endIndex, and sub-match sequence.
   */


  apply(str, actions) {
    for (var [start, end, tags] of this.match(str)) {
      for (var tag of tags) {
        if (typeof actions[tag] === 'function') {
          actions[tag](start, end, str.slice(start, end + 1));
        }
      }
    }
  }

}

module.exports = StateMachine;


},{}],164:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var objectCreate = Object.create || objectCreatePolyfill
var objectKeys = Object.keys || objectKeysPolyfill
var bind = Function.prototype.bind || functionBindPolyfill

function EventEmitter() {
  if (!this._events || !Object.prototype.hasOwnProperty.call(this, '_events')) {
    this._events = objectCreate(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;

var hasDefineProperty;
try {
  var o = {};
  if (Object.defineProperty) Object.defineProperty(o, 'x', { value: 0 });
  hasDefineProperty = o.x === 0;
} catch (err) { hasDefineProperty = false }
if (hasDefineProperty) {
  Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
    enumerable: true,
    get: function() {
      return defaultMaxListeners;
    },
    set: function(arg) {
      // check whether the input is a positive number (whose value is zero or
      // greater and not a NaN).
      if (typeof arg !== 'number' || arg < 0 || arg !== arg)
        throw new TypeError('"defaultMaxListeners" must be a positive number');
      defaultMaxListeners = arg;
    }
  });
} else {
  EventEmitter.defaultMaxListeners = defaultMaxListeners;
}

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || isNaN(n))
    throw new TypeError('"n" argument must be a positive number');
  this._maxListeners = n;
  return this;
};

function $getMaxListeners(that) {
  if (that._maxListeners === undefined)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return $getMaxListeners(this);
};

// These standalone emit* functions are used to optimize calling of event
// handlers for fast cases because emit() itself often has a variable number of
// arguments and can be deoptimized because of that. These functions always have
// the same number of arguments and thus do not get deoptimized, so the code
// inside them can execute faster.
function emitNone(handler, isFn, self) {
  if (isFn)
    handler.call(self);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self);
  }
}
function emitOne(handler, isFn, self, arg1) {
  if (isFn)
    handler.call(self, arg1);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self, arg1);
  }
}
function emitTwo(handler, isFn, self, arg1, arg2) {
  if (isFn)
    handler.call(self, arg1, arg2);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self, arg1, arg2);
  }
}
function emitThree(handler, isFn, self, arg1, arg2, arg3) {
  if (isFn)
    handler.call(self, arg1, arg2, arg3);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self, arg1, arg2, arg3);
  }
}

function emitMany(handler, isFn, self, args) {
  if (isFn)
    handler.apply(self, args);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].apply(self, args);
  }
}

EventEmitter.prototype.emit = function emit(type) {
  var er, handler, len, args, i, events;
  var doError = (type === 'error');

  events = this._events;
  if (events)
    doError = (doError && events.error == null);
  else if (!doError)
    return false;

  // If there is no 'error' event listener then throw.
  if (doError) {
    if (arguments.length > 1)
      er = arguments[1];
    if (er instanceof Error) {
      throw er; // Unhandled 'error' event
    } else {
      // At least give some kind of context to the user
      var err = new Error('Unhandled "error" event. (' + er + ')');
      err.context = er;
      throw err;
    }
    return false;
  }

  handler = events[type];

  if (!handler)
    return false;

  var isFn = typeof handler === 'function';
  len = arguments.length;
  switch (len) {
      // fast cases
    case 1:
      emitNone(handler, isFn, this);
      break;
    case 2:
      emitOne(handler, isFn, this, arguments[1]);
      break;
    case 3:
      emitTwo(handler, isFn, this, arguments[1], arguments[2]);
      break;
    case 4:
      emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);
      break;
      // slower
    default:
      args = new Array(len - 1);
      for (i = 1; i < len; i++)
        args[i - 1] = arguments[i];
      emitMany(handler, isFn, this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  if (typeof listener !== 'function')
    throw new TypeError('"listener" argument must be a function');

  events = target._events;
  if (!events) {
    events = target._events = objectCreate(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener) {
      target.emit('newListener', type,
          listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (!existing) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] =
          prepend ? [listener, existing] : [existing, listener];
    } else {
      // If we've already got an array, just append.
      if (prepend) {
        existing.unshift(listener);
      } else {
        existing.push(listener);
      }
    }

    // Check for listener leak
    if (!existing.warned) {
      m = $getMaxListeners(target);
      if (m && m > 0 && existing.length > m) {
        existing.warned = true;
        var w = new Error('Possible EventEmitter memory leak detected. ' +
            existing.length + ' "' + String(type) + '" listeners ' +
            'added. Use emitter.setMaxListeners() to ' +
            'increase limit.');
        w.name = 'MaxListenersExceededWarning';
        w.emitter = target;
        w.type = type;
        w.count = existing.length;
        if (typeof console === 'object' && console.warn) {
          console.warn('%s: %s', w.name, w.message);
        }
      }
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener =
    function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };

function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    switch (arguments.length) {
      case 0:
        return this.listener.call(this.target);
      case 1:
        return this.listener.call(this.target, arguments[0]);
      case 2:
        return this.listener.call(this.target, arguments[0], arguments[1]);
      case 3:
        return this.listener.call(this.target, arguments[0], arguments[1],
            arguments[2]);
      default:
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; ++i)
          args[i] = arguments[i];
        this.listener.apply(this.target, args);
    }
  }
}

function _onceWrap(target, type, listener) {
  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
  var wrapped = bind.call(onceWrapper, state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  if (typeof listener !== 'function')
    throw new TypeError('"listener" argument must be a function');
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener =
    function prependOnceListener(type, listener) {
      if (typeof listener !== 'function')
        throw new TypeError('"listener" argument must be a function');
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };

// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener =
    function removeListener(type, listener) {
      var list, events, position, i, originalListener;

      if (typeof listener !== 'function')
        throw new TypeError('"listener" argument must be a function');

      events = this._events;
      if (!events)
        return this;

      list = events[type];
      if (!list)
        return this;

      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = objectCreate(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit('removeListener', type, list.listener || listener);
        }
      } else if (typeof list !== 'function') {
        position = -1;

        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }

        if (position < 0)
          return this;

        if (position === 0)
          list.shift();
        else
          spliceOne(list, position);

        if (list.length === 1)
          events[type] = list[0];

        if (events.removeListener)
          this.emit('removeListener', type, originalListener || listener);
      }

      return this;
    };

EventEmitter.prototype.removeAllListeners =
    function removeAllListeners(type) {
      var listeners, events, i;

      events = this._events;
      if (!events)
        return this;

      // not listening for removeListener, no need to emit
      if (!events.removeListener) {
        if (arguments.length === 0) {
          this._events = objectCreate(null);
          this._eventsCount = 0;
        } else if (events[type]) {
          if (--this._eventsCount === 0)
            this._events = objectCreate(null);
          else
            delete events[type];
        }
        return this;
      }

      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        var keys = objectKeys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = objectCreate(null);
        this._eventsCount = 0;
        return this;
      }

      listeners = events[type];

      if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
      } else if (listeners) {
        // LIFO order
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }

      return this;
    };

function _listeners(target, type, unwrap) {
  var events = target._events;

  if (!events)
    return [];

  var evlistener = events[type];
  if (!evlistener)
    return [];

  if (typeof evlistener === 'function')
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];

  return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
};

// About 1.5x faster than the two-arg version of Array#splice().
function spliceOne(list, index) {
  for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1)
    list[i] = list[k];
  list.pop();
}

function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i)
    copy[i] = arr[i];
  return copy;
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}

function objectCreatePolyfill(proto) {
  var F = function() {};
  F.prototype = proto;
  return new F;
}
function objectKeysPolyfill(obj) {
  var keys = [];
  for (var k in obj) if (Object.prototype.hasOwnProperty.call(obj, k)) {
    keys.push(k);
  }
  return k;
}
function functionBindPolyfill(context) {
  var fn = this;
  return function () {
    return fn.apply(context, arguments);
  };
}

},{}],165:[function(require,module,exports){
(function (process,Buffer){
'use strict';
function _interopDefault(ex) {
    return ex && typeof ex === 'object' && 'default' in ex ? ex['default'] : ex;
}
var r = _interopDefault(require('restructure'));
var _Object$getOwnPropertyDescriptor = _interopDefault(require('babel-runtime/core-js/object/get-own-property-descriptor'));
var _getIterator = _interopDefault(require('babel-runtime/core-js/get-iterator'));
var _Object$freeze = _interopDefault(require('babel-runtime/core-js/object/freeze'));
var _typeof = _interopDefault(require('babel-runtime/helpers/typeof'));
var _Object$keys = _interopDefault(require('babel-runtime/core-js/object/keys'));
var _Object$defineProperty = _interopDefault(require('babel-runtime/core-js/object/define-property'));
var _classCallCheck = _interopDefault(require('babel-runtime/helpers/classCallCheck'));
var _createClass = _interopDefault(require('babel-runtime/helpers/createClass'));
var _Map = _interopDefault(require('babel-runtime/core-js/map'));
var _possibleConstructorReturn = _interopDefault(require('babel-runtime/helpers/possibleConstructorReturn'));
var _inherits = _interopDefault(require('babel-runtime/helpers/inherits'));
var restructure_src_utils = require('restructure/src/utils');
var _Object$defineProperties = _interopDefault(require('babel-runtime/core-js/object/define-properties'));
var isEqual = _interopDefault(require('deep-equal'));
var _Object$assign = _interopDefault(require('babel-runtime/core-js/object/assign'));
var _String$fromCodePoint = _interopDefault(require('babel-runtime/core-js/string/from-code-point'));
var _Array$from = _interopDefault(require('babel-runtime/core-js/array/from'));
var _Set = _interopDefault(require('babel-runtime/core-js/set'));
var unicode = _interopDefault(require('unicode-properties'));
var UnicodeTrie = _interopDefault(require('unicode-trie'));
var StateMachine = _interopDefault(require('dfa'));
var _Number$EPSILON = _interopDefault(require('babel-runtime/core-js/number/epsilon'));
var cloneDeep = _interopDefault(require('clone'));
var inflate = _interopDefault(require('tiny-inflate'));
var brotli = _interopDefault(require('brotli/decompress'));
var fontkit = {};
fontkit.logErrors = false;
var formats = [];
fontkit.registerFormat = function (format) {
    formats.push(format);
};
fontkit.openSync = function (filename, postscriptName) {
    var buffer = fs.readFileSync(filename);
    return fontkit.create(buffer, postscriptName);
};
fontkit.open = function (filename, postscriptName, callback) {
    if (typeof postscriptName === 'function') {
        callback = postscriptName;
        postscriptName = null;
    }
    fs.readFile(filename, function (err, buffer) {
        if (err) {
            return callback(err);
        }
        try {
            var font = fontkit.create(buffer, postscriptName);
        } catch (e) {
            return callback(e);
        }
        return callback(null, font);
    });
    return;
};
fontkit.create = function (buffer, postscriptName) {
    for (var i = 0; i < formats.length; i++) {
        var format = formats[i];
        if (format.probe(buffer)) {
            var font = new format(new r.DecodeStream(buffer));
            if (postscriptName) {
                return font.getFont(postscriptName);
            }
            return font;
        }
    }
    throw new Error('Unknown font format');
};
fontkit.defaultLanguage = 'en';
fontkit.setDefaultLanguage = function () {
    var lang = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'en';
    fontkit.defaultLanguage = lang;
};
function cache(target, key, descriptor) {
    if (descriptor.get) {
        var get = descriptor.get;
        descriptor.get = function () {
            var value = get.call(this);
            _Object$defineProperty(this, key, { value: value });
            return value;
        };
    } else if (typeof descriptor.value === 'function') {
        var fn = descriptor.value;
        return {
            get: function get() {
                var cache = new _Map();
                function memoized() {
                    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
                        args[_key] = arguments[_key];
                    }
                    var key = args.length > 0 ? args[0] : 'value';
                    if (cache.has(key)) {
                        return cache.get(key);
                    }
                    var result = fn.apply(this, args);
                    cache.set(key, result);
                    return result;
                }
                ;
                _Object$defineProperty(this, key, { value: memoized });
                return memoized;
            }
        };
    }
}
var SubHeader = new r.Struct({
        firstCode: r.uint16,
        entryCount: r.uint16,
        idDelta: r.int16,
        idRangeOffset: r.uint16
    });
var CmapGroup = new r.Struct({
        startCharCode: r.uint32,
        endCharCode: r.uint32,
        glyphID: r.uint32
    });
var UnicodeValueRange = new r.Struct({
        startUnicodeValue: r.uint24,
        additionalCount: r.uint8
    });
var UVSMapping = new r.Struct({
        unicodeValue: r.uint24,
        glyphID: r.uint16
    });
var DefaultUVS = new r.Array(UnicodeValueRange, r.uint32);
var NonDefaultUVS = new r.Array(UVSMapping, r.uint32);
var VarSelectorRecord = new r.Struct({
        varSelector: r.uint24,
        defaultUVS: new r.Pointer(r.uint32, DefaultUVS, { type: 'parent' }),
        nonDefaultUVS: new r.Pointer(r.uint32, NonDefaultUVS, { type: 'parent' })
    });
var CmapSubtable = new r.VersionedStruct(r.uint16, {
        0: {
            length: r.uint16,
            language: r.uint16,
            codeMap: new r.LazyArray(r.uint8, 256)
        },
        2: {
            length: r.uint16,
            language: r.uint16,
            subHeaderKeys: new r.Array(r.uint16, 256),
            subHeaderCount: function subHeaderCount(t) {
                return Math.max.apply(Math, t.subHeaderKeys);
            },
            subHeaders: new r.LazyArray(SubHeader, 'subHeaderCount'),
            glyphIndexArray: new r.LazyArray(r.uint16, 'subHeaderCount')
        },
        4: {
            length: r.uint16,
            language: r.uint16,
            segCountX2: r.uint16,
            segCount: function segCount(t) {
                return t.segCountX2 >> 1;
            },
            searchRange: r.uint16,
            entrySelector: r.uint16,
            rangeShift: r.uint16,
            endCode: new r.LazyArray(r.uint16, 'segCount'),
            reservedPad: new r.Reserved(r.uint16),
            startCode: new r.LazyArray(r.uint16, 'segCount'),
            idDelta: new r.LazyArray(r.int16, 'segCount'),
            idRangeOffset: new r.LazyArray(r.uint16, 'segCount'),
            glyphIndexArray: new r.LazyArray(r.uint16, function (t) {
                return (t.length - t._currentOffset) / 2;
            })
        },
        6: {
            length: r.uint16,
            language: r.uint16,
            firstCode: r.uint16,
            entryCount: r.uint16,
            glyphIndices: new r.LazyArray(r.uint16, 'entryCount')
        },
        8: {
            reserved: new r.Reserved(r.uint16),
            length: r.uint32,
            language: r.uint16,
            is32: new r.LazyArray(r.uint8, 8192),
            nGroups: r.uint32,
            groups: new r.LazyArray(CmapGroup, 'nGroups')
        },
        10: {
            reserved: new r.Reserved(r.uint16),
            length: r.uint32,
            language: r.uint32,
            firstCode: r.uint32,
            entryCount: r.uint32,
            glyphIndices: new r.LazyArray(r.uint16, 'numChars')
        },
        12: {
            reserved: new r.Reserved(r.uint16),
            length: r.uint32,
            language: r.uint32,
            nGroups: r.uint32,
            groups: new r.LazyArray(CmapGroup, 'nGroups')
        },
        13: {
            reserved: new r.Reserved(r.uint16),
            length: r.uint32,
            language: r.uint32,
            nGroups: r.uint32,
            groups: new r.LazyArray(CmapGroup, 'nGroups')
        },
        14: {
            length: r.uint32,
            numRecords: r.uint32,
            varSelectors: new r.LazyArray(VarSelectorRecord, 'numRecords')
        }
    });
var CmapEntry = new r.Struct({
        platformID: r.uint16,
        encodingID: r.uint16,
        table: new r.Pointer(r.uint32, CmapSubtable, {
            type: 'parent',
            lazy: true
        })
    });
var cmap = new r.Struct({
        version: r.uint16,
        numSubtables: r.uint16,
        tables: new r.Array(CmapEntry, 'numSubtables')
    });
var head = new r.Struct({
        version: r.int32,
        revision: r.int32,
        checkSumAdjustment: r.uint32,
        magicNumber: r.uint32,
        flags: r.uint16,
        unitsPerEm: r.uint16,
        created: new r.Array(r.int32, 2),
        modified: new r.Array(r.int32, 2),
        xMin: r.int16,
        yMin: r.int16,
        xMax: r.int16,
        yMax: r.int16,
        macStyle: new r.Bitfield(r.uint16, [
            'bold',
            'italic',
            'underline',
            'outline',
            'shadow',
            'condensed',
            'extended'
        ]),
        lowestRecPPEM: r.uint16,
        fontDirectionHint: r.int16,
        indexToLocFormat: r.int16,
        glyphDataFormat: r.int16
    });
var hhea = new r.Struct({
        version: r.int32,
        ascent: r.int16,
        descent: r.int16,
        lineGap: r.int16,
        advanceWidthMax: r.uint16,
        minLeftSideBearing: r.int16,
        minRightSideBearing: r.int16,
        xMaxExtent: r.int16,
        caretSlopeRise: r.int16,
        caretSlopeRun: r.int16,
        caretOffset: r.int16,
        reserved: new r.Reserved(r.int16, 4),
        metricDataFormat: r.int16,
        numberOfMetrics: r.uint16
    });
var HmtxEntry = new r.Struct({
        advance: r.uint16,
        bearing: r.int16
    });
var hmtx = new r.Struct({
        metrics: new r.LazyArray(HmtxEntry, function (t) {
            return t.parent.hhea.numberOfMetrics;
        }),
        bearings: new r.LazyArray(r.int16, function (t) {
            return t.parent.maxp.numGlyphs - t.parent.hhea.numberOfMetrics;
        })
    });
var maxp = new r.Struct({
        version: r.int32,
        numGlyphs: r.uint16,
        maxPoints: r.uint16,
        maxContours: r.uint16,
        maxComponentPoints: r.uint16,
        maxComponentContours: r.uint16,
        maxZones: r.uint16,
        maxTwilightPoints: r.uint16,
        maxStorage: r.uint16,
        maxFunctionDefs: r.uint16,
        maxInstructionDefs: r.uint16,
        maxStackElements: r.uint16,
        maxSizeOfInstructions: r.uint16,
        maxComponentElements: r.uint16,
        maxComponentDepth: r.uint16
    });
function getEncoding(platformID, encodingID) {
    var languageID = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    if (platformID === 1 && MAC_LANGUAGE_ENCODINGS[languageID]) {
        return MAC_LANGUAGE_ENCODINGS[languageID];
    }
    return ENCODINGS[platformID][encodingID];
}
var ENCODINGS = [
        [
            'utf16be',
            'utf16be',
            'utf16be',
            'utf16be',
            'utf16be',
            'utf16be'
        ],
        [
            'macroman',
            'shift-jis',
            'big5',
            'euc-kr',
            'iso-8859-6',
            'iso-8859-8',
            'macgreek',
            'maccyrillic',
            'symbol',
            'Devanagari',
            'Gurmukhi',
            'Gujarati',
            'Oriya',
            'Bengali',
            'Tamil',
            'Telugu',
            'Kannada',
            'Malayalam',
            'Sinhalese',
            'Burmese',
            'Khmer',
            'macthai',
            'Laotian',
            'Georgian',
            'Armenian',
            'gb-2312-80',
            'Tibetan',
            'Mongolian',
            'Geez',
            'maccenteuro',
            'Vietnamese',
            'Sindhi'
        ],
        ['ascii'],
        [
            'symbol',
            'utf16be',
            'shift-jis',
            'gb18030',
            'big5',
            'wansung',
            'johab',
            null,
            null,
            null,
            'utf16be'
        ]
    ];
var MAC_LANGUAGE_ENCODINGS = {
        15: 'maciceland',
        17: 'macturkish',
        18: 'maccroatian',
        24: 'maccenteuro',
        25: 'maccenteuro',
        26: 'maccenteuro',
        27: 'maccenteuro',
        28: 'maccenteuro',
        30: 'maciceland',
        37: 'macromania',
        38: 'maccenteuro',
        39: 'maccenteuro',
        40: 'maccenteuro',
        143: 'macinuit',
        146: 'macgaelic'
    };
var LANGUAGES = [
        [],
        {
            0: 'en',
            30: 'fo',
            60: 'ks',
            90: 'rw',
            1: 'fr',
            31: 'fa',
            61: 'ku',
            91: 'rn',
            2: 'de',
            32: 'ru',
            62: 'sd',
            92: 'ny',
            3: 'it',
            33: 'zh',
            63: 'bo',
            93: 'mg',
            4: 'nl',
            34: 'nl-BE',
            64: 'ne',
            94: 'eo',
            5: 'sv',
            35: 'ga',
            65: 'sa',
            128: 'cy',
            6: 'es',
            36: 'sq',
            66: 'mr',
            129: 'eu',
            7: 'da',
            37: 'ro',
            67: 'bn',
            130: 'ca',
            8: 'pt',
            38: 'cz',
            68: 'as',
            131: 'la',
            9: 'no',
            39: 'sk',
            69: 'gu',
            132: 'qu',
            10: 'he',
            40: 'si',
            70: 'pa',
            133: 'gn',
            11: 'ja',
            41: 'yi',
            71: 'or',
            134: 'ay',
            12: 'ar',
            42: 'sr',
            72: 'ml',
            135: 'tt',
            13: 'fi',
            43: 'mk',
            73: 'kn',
            136: 'ug',
            14: 'el',
            44: 'bg',
            74: 'ta',
            137: 'dz',
            15: 'is',
            45: 'uk',
            75: 'te',
            138: 'jv',
            16: 'mt',
            46: 'be',
            76: 'si',
            139: 'su',
            17: 'tr',
            47: 'uz',
            77: 'my',
            140: 'gl',
            18: 'hr',
            48: 'kk',
            78: 'km',
            141: 'af',
            19: 'zh-Hant',
            49: 'az-Cyrl',
            79: 'lo',
            142: 'br',
            20: 'ur',
            50: 'az-Arab',
            80: 'vi',
            143: 'iu',
            21: 'hi',
            51: 'hy',
            81: 'id',
            144: 'gd',
            22: 'th',
            52: 'ka',
            82: 'tl',
            145: 'gv',
            23: 'ko',
            53: 'mo',
            83: 'ms',
            146: 'ga',
            24: 'lt',
            54: 'ky',
            84: 'ms-Arab',
            147: 'to',
            25: 'pl',
            55: 'tg',
            85: 'am',
            148: 'el-polyton',
            26: 'hu',
            56: 'tk',
            86: 'ti',
            149: 'kl',
            27: 'es',
            57: 'mn-CN',
            87: 'om',
            150: 'az',
            28: 'lv',
            58: 'mn',
            88: 'so',
            151: 'nn',
            29: 'se',
            59: 'ps',
            89: 'sw'
        },
        [],
        {
            1078: 'af',
            16393: 'en-IN',
            1159: 'rw',
            1074: 'tn',
            1052: 'sq',
            6153: 'en-IE',
            1089: 'sw',
            1115: 'si',
            1156: 'gsw',
            8201: 'en-JM',
            1111: 'kok',
            1051: 'sk',
            1118: 'am',
            17417: 'en-MY',
            1042: 'ko',
            1060: 'sl',
            5121: 'ar-DZ',
            5129: 'en-NZ',
            1088: 'ky',
            11274: 'es-AR',
            15361: 'ar-BH',
            13321: 'en-PH',
            1108: 'lo',
            16394: 'es-BO',
            3073: 'ar',
            18441: 'en-SG',
            1062: 'lv',
            13322: 'es-CL',
            2049: 'ar-IQ',
            7177: 'en-ZA',
            1063: 'lt',
            9226: 'es-CO',
            11265: 'ar-JO',
            11273: 'en-TT',
            2094: 'dsb',
            5130: 'es-CR',
            13313: 'ar-KW',
            2057: 'en-GB',
            1134: 'lb',
            7178: 'es-DO',
            12289: 'ar-LB',
            1033: 'en',
            1071: 'mk',
            12298: 'es-EC',
            4097: 'ar-LY',
            12297: 'en-ZW',
            2110: 'ms-BN',
            17418: 'es-SV',
            6145: 'ary',
            1061: 'et',
            1086: 'ms',
            4106: 'es-GT',
            8193: 'ar-OM',
            1080: 'fo',
            1100: 'ml',
            18442: 'es-HN',
            16385: 'ar-QA',
            1124: 'fil',
            1082: 'mt',
            2058: 'es-MX',
            1025: 'ar-SA',
            1035: 'fi',
            1153: 'mi',
            19466: 'es-NI',
            10241: 'ar-SY',
            2060: 'fr-BE',
            1146: 'arn',
            6154: 'es-PA',
            7169: 'aeb',
            3084: 'fr-CA',
            1102: 'mr',
            15370: 'es-PY',
            14337: 'ar-AE',
            1036: 'fr',
            1148: 'moh',
            10250: 'es-PE',
            9217: 'ar-YE',
            5132: 'fr-LU',
            1104: 'mn',
            20490: 'es-PR',
            1067: 'hy',
            6156: 'fr-MC',
            2128: 'mn-CN',
            3082: 'es',
            1101: 'as',
            4108: 'fr-CH',
            1121: 'ne',
            1034: 'es',
            2092: 'az-Cyrl',
            1122: 'fy',
            1044: 'nb',
            21514: 'es-US',
            1068: 'az',
            1110: 'gl',
            2068: 'nn',
            14346: 'es-UY',
            1133: 'ba',
            1079: 'ka',
            1154: 'oc',
            8202: 'es-VE',
            1069: 'eu',
            3079: 'de-AT',
            1096: 'or',
            2077: 'sv-FI',
            1059: 'be',
            1031: 'de',
            1123: 'ps',
            1053: 'sv',
            2117: 'bn',
            5127: 'de-LI',
            1045: 'pl',
            1114: 'syr',
            1093: 'bn-IN',
            4103: 'de-LU',
            1046: 'pt',
            1064: 'tg',
            8218: 'bs-Cyrl',
            2055: 'de-CH',
            2070: 'pt-PT',
            2143: 'tzm',
            5146: 'bs',
            1032: 'el',
            1094: 'pa',
            1097: 'ta',
            1150: 'br',
            1135: 'kl',
            1131: 'qu-BO',
            1092: 'tt',
            1026: 'bg',
            1095: 'gu',
            2155: 'qu-EC',
            1098: 'te',
            1027: 'ca',
            1128: 'ha',
            3179: 'qu',
            1054: 'th',
            3076: 'zh-HK',
            1037: 'he',
            1048: 'ro',
            1105: 'bo',
            5124: 'zh-MO',
            1081: 'hi',
            1047: 'rm',
            1055: 'tr',
            2052: 'zh',
            1038: 'hu',
            1049: 'ru',
            1090: 'tk',
            4100: 'zh-SG',
            1039: 'is',
            9275: 'smn',
            1152: 'ug',
            1028: 'zh-TW',
            1136: 'ig',
            4155: 'smj-NO',
            1058: 'uk',
            1155: 'co',
            1057: 'id',
            5179: 'smj',
            1070: 'hsb',
            1050: 'hr',
            1117: 'iu',
            3131: 'se-FI',
            1056: 'ur',
            4122: 'hr-BA',
            2141: 'iu-Latn',
            1083: 'se',
            2115: 'uz-Cyrl',
            1029: 'cs',
            2108: 'ga',
            2107: 'se-SE',
            1091: 'uz',
            1030: 'da',
            1076: 'xh',
            8251: 'sms',
            1066: 'vi',
            1164: 'prs',
            1077: 'zu',
            6203: 'sma-NO',
            1106: 'cy',
            1125: 'dv',
            1040: 'it',
            7227: 'sms',
            1160: 'wo',
            2067: 'nl-BE',
            2064: 'it-CH',
            1103: 'sa',
            1157: 'sah',
            1043: 'nl',
            1041: 'ja',
            7194: 'sr-Cyrl-BA',
            1144: 'ii',
            3081: 'en-AU',
            1099: 'kn',
            3098: 'sr',
            1130: 'yo',
            10249: 'en-BZ',
            1087: 'kk',
            6170: 'sr-Latn-BA',
            4105: 'en-CA',
            1107: 'km',
            2074: 'sr-Latn',
            9225: 'en-029',
            1158: 'quc',
            1132: 'nso'
        }
    ];
var NameRecord = new r.Struct({
        platformID: r.uint16,
        encodingID: r.uint16,
        languageID: r.uint16,
        nameID: r.uint16,
        length: r.uint16,
        string: new r.Pointer(r.uint16, new r.String('length', function (t) {
            return getEncoding(t.platformID, t.encodingID, t.languageID);
        }), {
            type: 'parent',
            relativeTo: 'parent.stringOffset',
            allowNull: false
        })
    });
var LangTagRecord = new r.Struct({
        length: r.uint16,
        tag: new r.Pointer(r.uint16, new r.String('length', 'utf16be'), {
            type: 'parent',
            relativeTo: 'stringOffset'
        })
    });
var NameTable = new r.VersionedStruct(r.uint16, {
        0: {
            count: r.uint16,
            stringOffset: r.uint16,
            records: new r.Array(NameRecord, 'count')
        },
        1: {
            count: r.uint16,
            stringOffset: r.uint16,
            records: new r.Array(NameRecord, 'count'),
            langTagCount: r.uint16,
            langTags: new r.Array(LangTagRecord, 'langTagCount')
        }
    });
var NAMES = [
        'copyright',
        'fontFamily',
        'fontSubfamily',
        'uniqueSubfamily',
        'fullName',
        'version',
        'postscriptName',
        'trademark',
        'manufacturer',
        'designer',
        'description',
        'vendorURL',
        'designerURL',
        'license',
        'licenseURL',
        null,
        'preferredFamily',
        'preferredSubfamily',
        'compatibleFull',
        'sampleText',
        'postscriptCIDFontName',
        'wwsFamilyName',
        'wwsSubfamilyName'
    ];
NameTable.process = function (stream) {
    var records = {};
    for (var _iterator = this.records, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _getIterator(_iterator);;) {
        var _ref;
        if (_isArray) {
            if (_i >= _iterator.length)
                break;
            _ref = _iterator[_i++];
        } else {
            _i = _iterator.next();
            if (_i.done)
                break;
            _ref = _i.value;
        }
        var record = _ref;
        var language = LANGUAGES[record.platformID][record.languageID];
        if (language == null && this.langTags != null && record.languageID >= 32768) {
            language = this.langTags[record.languageID - 32768].tag;
        }
        if (language == null) {
            language = record.platformID + '-' + record.languageID;
        }
        var key = record.nameID >= 256 ? 'fontFeatures' : NAMES[record.nameID] || record.nameID;
        if (records[key] == null) {
            records[key] = {};
        }
        var obj = records[key];
        if (record.nameID >= 256) {
            obj = obj[record.nameID] || (obj[record.nameID] = {});
        }
        if (typeof record.string === 'string' || typeof obj[language] !== 'string') {
            obj[language] = record.string;
        }
    }
    this.records = records;
};
NameTable.preEncode = function () {
    if (Array.isArray(this.records))
        return;
    this.version = 0;
    var records = [];
    for (var key in this.records) {
        var val = this.records[key];
        if (key === 'fontFeatures')
            continue;
        records.push({
            platformID: 3,
            encodingID: 1,
            languageID: 1033,
            nameID: NAMES.indexOf(key),
            length: Buffer.byteLength(val.en, 'utf16le'),
            string: val.en
        });
        if (key === 'postscriptName') {
            records.push({
                platformID: 1,
                encodingID: 0,
                languageID: 0,
                nameID: NAMES.indexOf(key),
                length: val.en.length,
                string: val.en
            });
        }
    }
    this.records = records;
    this.count = records.length;
    this.stringOffset = NameTable.size(this, null, false);
};
var OS2 = new r.VersionedStruct(r.uint16, {
        header: {
            xAvgCharWidth: r.int16,
            usWeightClass: r.uint16,
            usWidthClass: r.uint16,
            fsType: new r.Bitfield(r.uint16, [
                null,
                'noEmbedding',
                'viewOnly',
                'editable',
                null,
                null,
                null,
                null,
                'noSubsetting',
                'bitmapOnly'
            ]),
            ySubscriptXSize: r.int16,
            ySubscriptYSize: r.int16,
            ySubscriptXOffset: r.int16,
            ySubscriptYOffset: r.int16,
            ySuperscriptXSize: r.int16,
            ySuperscriptYSize: r.int16,
            ySuperscriptXOffset: r.int16,
            ySuperscriptYOffset: r.int16,
            yStrikeoutSize: r.int16,
            yStrikeoutPosition: r.int16,
            sFamilyClass: r.int16,
            panose: new r.Array(r.uint8, 10),
            ulCharRange: new r.Array(r.uint32, 4),
            vendorID: new r.String(4),
            fsSelection: new r.Bitfield(r.uint16, [
                'italic',
                'underscore',
                'negative',
                'outlined',
                'strikeout',
                'bold',
                'regular',
                'useTypoMetrics',
                'wws',
                'oblique'
            ]),
            usFirstCharIndex: r.uint16,
            usLastCharIndex: r.uint16
        },
        0: {},
        1: {
            typoAscender: r.int16,
            typoDescender: r.int16,
            typoLineGap: r.int16,
            winAscent: r.uint16,
            winDescent: r.uint16,
            codePageRange: new r.Array(r.uint32, 2)
        },
        2: {
            typoAscender: r.int16,
            typoDescender: r.int16,
            typoLineGap: r.int16,
            winAscent: r.uint16,
            winDescent: r.uint16,
            codePageRange: new r.Array(r.uint32, 2),
            xHeight: r.int16,
            capHeight: r.int16,
            defaultChar: r.uint16,
            breakChar: r.uint16,
            maxContent: r.uint16
        },
        5: {
            typoAscender: r.int16,
            typoDescender: r.int16,
            typoLineGap: r.int16,
            winAscent: r.uint16,
            winDescent: r.uint16,
            codePageRange: new r.Array(r.uint32, 2),
            xHeight: r.int16,
            capHeight: r.int16,
            defaultChar: r.uint16,
            breakChar: r.uint16,
            maxContent: r.uint16,
            usLowerOpticalPointSize: r.uint16,
            usUpperOpticalPointSize: r.uint16
        }
    });
var versions = OS2.versions;
versions[3] = versions[4] = versions[2];
var post = new r.VersionedStruct(r.fixed32, {
        header: {
            italicAngle: r.fixed32,
            underlinePosition: r.int16,
            underlineThickness: r.int16,
            isFixedPitch: r.uint32,
            minMemType42: r.uint32,
            maxMemType42: r.uint32,
            minMemType1: r.uint32,
            maxMemType1: r.uint32
        },
        1: {},
        2: {
            numberOfGlyphs: r.uint16,
            glyphNameIndex: new r.Array(r.uint16, 'numberOfGlyphs'),
            names: new r.Array(new r.String(r.uint8))
        },
        2.5: {
            numberOfGlyphs: r.uint16,
            offsets: new r.Array(r.uint8, 'numberOfGlyphs')
        },
        3: {},
        4: {
            map: new r.Array(r.uint32, function (t) {
                return t.parent.maxp.numGlyphs;
            })
        }
    });
var cvt = new r.Struct({ controlValues: new r.Array(r.int16) });
var fpgm = new r.Struct({ instructions: new r.Array(r.uint8) });
var loca = new r.VersionedStruct('head.indexToLocFormat', {
        0: { offsets: new r.Array(r.uint16) },
        1: { offsets: new r.Array(r.uint32) }
    });
loca.process = function () {
    if (this.version === 0) {
        for (var i = 0; i < this.offsets.length; i++) {
            this.offsets[i] <<= 1;
        }
    }
};
loca.preEncode = function () {
    if (this.version === 0) {
        for (var i = 0; i < this.offsets.length; i++) {
            this.offsets[i] >>>= 1;
        }
    }
};
var prep = new r.Struct({ controlValueProgram: new r.Array(r.uint8) });
var glyf = new r.Array(new r.Buffer());
var CFFIndex = function () {
        function CFFIndex(type) {
            _classCallCheck(this, CFFIndex);
            this.type = type;
        }
        CFFIndex.prototype.getCFFVersion = function getCFFVersion(ctx) {
            while (ctx && !ctx.hdrSize) {
                ctx = ctx.parent;
            }
            return ctx ? ctx.version : -1;
        };
        CFFIndex.prototype.decode = function decode(stream, parent) {
            var version = this.getCFFVersion(parent);
            var count = version >= 2 ? stream.readUInt32BE() : stream.readUInt16BE();
            if (count === 0) {
                return [];
            }
            var offSize = stream.readUInt8();
            var offsetType = void 0;
            if (offSize === 1) {
                offsetType = r.uint8;
            } else if (offSize === 2) {
                offsetType = r.uint16;
            } else if (offSize === 3) {
                offsetType = r.uint24;
            } else if (offSize === 4) {
                offsetType = r.uint32;
            } else {
                throw new Error('Bad offset size in CFFIndex: ' + offSize + ' ' + stream.pos);
            }
            var ret = [];
            var startPos = stream.pos + (count + 1) * offSize - 1;
            var start = offsetType.decode(stream);
            for (var i = 0; i < count; i++) {
                var end = offsetType.decode(stream);
                if (this.type != null) {
                    var pos = stream.pos;
                    stream.pos = startPos + start;
                    parent.length = end - start;
                    ret.push(this.type.decode(stream, parent));
                    stream.pos = pos;
                } else {
                    ret.push({
                        offset: startPos + start,
                        length: end - start
                    });
                }
                start = end;
            }
            stream.pos = startPos + start;
            return ret;
        };
        CFFIndex.prototype.size = function size(arr, parent) {
            var size = 2;
            if (arr.length === 0) {
                return size;
            }
            var type = this.type || new r.Buffer();
            var offset = 1;
            for (var i = 0; i < arr.length; i++) {
                var item = arr[i];
                offset += type.size(item, parent);
            }
            var offsetType = void 0;
            if (offset <= 255) {
                offsetType = r.uint8;
            } else if (offset <= 65535) {
                offsetType = r.uint16;
            } else if (offset <= 16777215) {
                offsetType = r.uint24;
            } else if (offset <= 4294967295) {
                offsetType = r.uint32;
            } else {
                throw new Error('Bad offset in CFFIndex');
            }
            size += 1 + offsetType.size() * (arr.length + 1);
            size += offset - 1;
            return size;
        };
        CFFIndex.prototype.encode = function encode(stream, arr, parent) {
            stream.writeUInt16BE(arr.length);
            if (arr.length === 0) {
                return;
            }
            var type = this.type || new r.Buffer();
            var sizes = [];
            var offset = 1;
            for (var _iterator = arr, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _getIterator(_iterator);;) {
                var _ref;
                if (_isArray) {
                    if (_i >= _iterator.length)
                        break;
                    _ref = _iterator[_i++];
                } else {
                    _i = _iterator.next();
                    if (_i.done)
                        break;
                    _ref = _i.value;
                }
                var item = _ref;
                var s = type.size(item, parent);
                sizes.push(s);
                offset += s;
            }
            var offsetType = void 0;
            if (offset <= 255) {
                offsetType = r.uint8;
            } else if (offset <= 65535) {
                offsetType = r.uint16;
            } else if (offset <= 16777215) {
                offsetType = r.uint24;
            } else if (offset <= 4294967295) {
                offsetType = r.uint32;
            } else {
                throw new Error('Bad offset in CFFIndex');
            }
            stream.writeUInt8(offsetType.size());
            offset = 1;
            offsetType.encode(stream, offset);
            for (var _iterator2 = sizes, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _getIterator(_iterator2);;) {
                var _ref2;
                if (_isArray2) {
                    if (_i2 >= _iterator2.length)
                        break;
                    _ref2 = _iterator2[_i2++];
                } else {
                    _i2 = _iterator2.next();
                    if (_i2.done)
                        break;
                    _ref2 = _i2.value;
                }
                var size = _ref2;
                offset += size;
                offsetType.encode(stream, offset);
            }
            for (var _iterator3 = arr, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _getIterator(_iterator3);;) {
                var _ref3;
                if (_isArray3) {
                    if (_i3 >= _iterator3.length)
                        break;
                    _ref3 = _iterator3[_i3++];
                } else {
                    _i3 = _iterator3.next();
                    if (_i3.done)
                        break;
                    _ref3 = _i3.value;
                }
                var _item = _ref3;
                type.encode(stream, _item, parent);
            }
            return;
        };
        return CFFIndex;
    }();
var FLOAT_EOF = 15;
var FLOAT_LOOKUP = [
        '0',
        '1',
        '2',
        '3',
        '4',
        '5',
        '6',
        '7',
        '8',
        '9',
        '.',
        'E',
        'E-',
        null,
        '-'
    ];
var FLOAT_ENCODE_LOOKUP = {
        '.': 10,
        'E': 11,
        'E-': 12,
        '-': 14
    };
var CFFOperand = function () {
        function CFFOperand() {
            _classCallCheck(this, CFFOperand);
        }
        CFFOperand.decode = function decode(stream, value) {
            if (32 <= value && value <= 246) {
                return value - 139;
            }
            if (247 <= value && value <= 250) {
                return (value - 247) * 256 + stream.readUInt8() + 108;
            }
            if (251 <= value && value <= 254) {
                return -(value - 251) * 256 - stream.readUInt8() - 108;
            }
            if (value === 28) {
                return stream.readInt16BE();
            }
            if (value === 29) {
                return stream.readInt32BE();
            }
            if (value === 30) {
                var str = '';
                while (true) {
                    var b = stream.readUInt8();
                    var n1 = b >> 4;
                    if (n1 === FLOAT_EOF) {
                        break;
                    }
                    str += FLOAT_LOOKUP[n1];
                    var n2 = b & 15;
                    if (n2 === FLOAT_EOF) {
                        break;
                    }
                    str += FLOAT_LOOKUP[n2];
                }
                return parseFloat(str);
            }
            return null;
        };
        CFFOperand.size = function size(value) {
            if (value.forceLarge) {
                value = 32768;
            }
            if ((value | 0) !== value) {
                var str = '' + value;
                return 1 + Math.ceil((str.length + 1) / 2);
            } else if (-107 <= value && value <= 107) {
                return 1;
            } else if (108 <= value && value <= 1131 || -1131 <= value && value <= -108) {
                return 2;
            } else if (-32768 <= value && value <= 32767) {
                return 3;
            } else {
                return 5;
            }
        };
        CFFOperand.encode = function encode(stream, value) {
            var val = Number(value);
            if (value.forceLarge) {
                stream.writeUInt8(29);
                return stream.writeInt32BE(val);
            } else if ((val | 0) !== val) {
                stream.writeUInt8(30);
                var str = '' + val;
                for (var i = 0; i < str.length; i += 2) {
                    var c1 = str[i];
                    var n1 = FLOAT_ENCODE_LOOKUP[c1] || +c1;
                    if (i === str.length - 1) {
                        var n2 = FLOAT_EOF;
                    } else {
                        var c2 = str[i + 1];
                        var n2 = FLOAT_ENCODE_LOOKUP[c2] || +c2;
                    }
                    stream.writeUInt8(n1 << 4 | n2 & 15);
                }
                if (n2 !== FLOAT_EOF) {
                    return stream.writeUInt8(FLOAT_EOF << 4);
                }
            } else if (-107 <= val && val <= 107) {
                return stream.writeUInt8(val + 139);
            } else if (108 <= val && val <= 1131) {
                val -= 108;
                stream.writeUInt8((val >> 8) + 247);
                return stream.writeUInt8(val & 255);
            } else if (-1131 <= val && val <= -108) {
                val = -val - 108;
                stream.writeUInt8((val >> 8) + 251);
                return stream.writeUInt8(val & 255);
            } else if (-32768 <= val && val <= 32767) {
                stream.writeUInt8(28);
                return stream.writeInt16BE(val);
            } else {
                stream.writeUInt8(29);
                return stream.writeInt32BE(val);
            }
        };
        return CFFOperand;
    }();
var CFFDict = function () {
        function CFFDict() {
            var ops = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
            _classCallCheck(this, CFFDict);
            this.ops = ops;
            this.fields = {};
            for (var _iterator = ops, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _getIterator(_iterator);;) {
                var _ref;
                if (_isArray) {
                    if (_i >= _iterator.length)
                        break;
                    _ref = _iterator[_i++];
                } else {
                    _i = _iterator.next();
                    if (_i.done)
                        break;
                    _ref = _i.value;
                }
                var field = _ref;
                var key = Array.isArray(field[0]) ? field[0][0] << 8 | field[0][1] : field[0];
                this.fields[key] = field;
            }
        }
        CFFDict.prototype.decodeOperands = function decodeOperands(type, stream, ret, operands) {
            var _this = this;
            if (Array.isArray(type)) {
                return operands.map(function (op, i) {
                    return _this.decodeOperands(type[i], stream, ret, [op]);
                });
            } else if (type.decode != null) {
                return type.decode(stream, ret, operands);
            } else {
                switch (type) {
                case 'number':
                case 'offset':
                case 'sid':
                    return operands[0];
                case 'boolean':
                    return !!operands[0];
                default:
                    return operands;
                }
            }
        };
        CFFDict.prototype.encodeOperands = function encodeOperands(type, stream, ctx, operands) {
            var _this2 = this;
            if (Array.isArray(type)) {
                return operands.map(function (op, i) {
                    return _this2.encodeOperands(type[i], stream, ctx, op)[0];
                });
            } else if (type.encode != null) {
                return type.encode(stream, operands, ctx);
            } else if (typeof operands === 'number') {
                return [operands];
            } else if (typeof operands === 'boolean') {
                return [+operands];
            } else if (Array.isArray(operands)) {
                return operands;
            } else {
                return [operands];
            }
        };
        CFFDict.prototype.decode = function decode(stream, parent) {
            var end = stream.pos + parent.length;
            var ret = {};
            var operands = [];
            _Object$defineProperties(ret, {
                parent: { value: parent },
                _startOffset: { value: stream.pos }
            });
            for (var key in this.fields) {
                var field = this.fields[key];
                ret[field[1]] = field[3];
            }
            while (stream.pos < end) {
                var b = stream.readUInt8();
                if (b < 28) {
                    if (b === 12) {
                        b = b << 8 | stream.readUInt8();
                    }
                    var _field = this.fields[b];
                    if (!_field) {
                        throw new Error('Unknown operator ' + b);
                    }
                    var val = this.decodeOperands(_field[2], stream, ret, operands);
                    if (val != null) {
                        if (val instanceof restructure_src_utils.PropertyDescriptor) {
                            _Object$defineProperty(ret, _field[1], val);
                        } else {
                            ret[_field[1]] = val;
                        }
                    }
                    operands = [];
                } else {
                    operands.push(CFFOperand.decode(stream, b));
                }
            }
            return ret;
        };
        CFFDict.prototype.size = function size(dict, parent) {
            var includePointers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
            var ctx = {
                    parent: parent,
                    val: dict,
                    pointerSize: 0,
                    startOffset: parent.startOffset || 0
                };
            var len = 0;
            for (var k in this.fields) {
                var field = this.fields[k];
                var val = dict[field[1]];
                if (val == null || isEqual(val, field[3])) {
                    continue;
                }
                var operands = this.encodeOperands(field[2], null, ctx, val);
                for (var _iterator2 = operands, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _getIterator(_iterator2);;) {
                    var _ref2;
                    if (_isArray2) {
                        if (_i2 >= _iterator2.length)
                            break;
                        _ref2 = _iterator2[_i2++];
                    } else {
                        _i2 = _iterator2.next();
                        if (_i2.done)
                            break;
                        _ref2 = _i2.value;
                    }
                    var op = _ref2;
                    len += CFFOperand.size(op);
                }
                var key = Array.isArray(field[0]) ? field[0] : [field[0]];
                len += key.length;
            }
            if (includePointers) {
                len += ctx.pointerSize;
            }
            return len;
        };
        CFFDict.prototype.encode = function encode(stream, dict, parent) {
            var ctx = {
                    pointers: [],
                    startOffset: stream.pos,
                    parent: parent,
                    val: dict,
                    pointerSize: 0
                };
            ctx.pointerOffset = stream.pos + this.size(dict, ctx, false);
            for (var _iterator3 = this.ops, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _getIterator(_iterator3);;) {
                var _ref3;
                if (_isArray3) {
                    if (_i3 >= _iterator3.length)
                        break;
                    _ref3 = _iterator3[_i3++];
                } else {
                    _i3 = _iterator3.next();
                    if (_i3.done)
                        break;
                    _ref3 = _i3.value;
                }
                var field = _ref3;
                var val = dict[field[1]];
                if (val == null || isEqual(val, field[3])) {
                    continue;
                }
                var operands = this.encodeOperands(field[2], stream, ctx, val);
                for (var _iterator4 = operands, _isArray4 = Array.isArray(_iterator4), _i4 = 0, _iterator4 = _isArray4 ? _iterator4 : _getIterator(_iterator4);;) {
                    var _ref4;
                    if (_isArray4) {
                        if (_i4 >= _iterator4.length)
                            break;
                        _ref4 = _iterator4[_i4++];
                    } else {
                        _i4 = _iterator4.next();
                        if (_i4.done)
                            break;
                        _ref4 = _i4.value;
                    }
                    var op = _ref4;
                    CFFOperand.encode(stream, op);
                }
                var key = Array.isArray(field[0]) ? field[0] : [field[0]];
                for (var _iterator5 = key, _isArray5 = Array.isArray(_iterator5), _i5 = 0, _iterator5 = _isArray5 ? _iterator5 : _getIterator(_iterator5);;) {
                    var _ref5;
                    if (_isArray5) {
                        if (_i5 >= _iterator5.length)
                            break;
                        _ref5 = _iterator5[_i5++];
                    } else {
                        _i5 = _iterator5.next();
                        if (_i5.done)
                            break;
                        _ref5 = _i5.value;
                    }
                    var _op = _ref5;
                    stream.writeUInt8(_op);
                }
            }
            var i = 0;
            while (i < ctx.pointers.length) {
                var ptr = ctx.pointers[i++];
                ptr.type.encode(stream, ptr.val, ptr.parent);
            }
            return;
        };
        return CFFDict;
    }();
var CFFPointer = function (_r$Pointer) {
        _inherits(CFFPointer, _r$Pointer);
        function CFFPointer(type) {
            var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
            _classCallCheck(this, CFFPointer);
            if (options.type == null) {
                options.type = 'global';
            }
            return _possibleConstructorReturn(this, _r$Pointer.call(this, null, type, options));
        }
        CFFPointer.prototype.decode = function decode(stream, parent, operands) {
            this.offsetType = {
                decode: function decode() {
                    return operands[0];
                }
            };
            return _r$Pointer.prototype.decode.call(this, stream, parent, operands);
        };
        CFFPointer.prototype.encode = function encode(stream, value, ctx) {
            if (!stream) {
                this.offsetType = {
                    size: function size() {
                        return 0;
                    }
                };
                this.size(value, ctx);
                return [new Ptr(0)];
            }
            var ptr = null;
            this.offsetType = {
                encode: function encode(stream, val) {
                    return ptr = val;
                }
            };
            _r$Pointer.prototype.encode.call(this, stream, value, ctx);
            return [new Ptr(ptr)];
        };
        return CFFPointer;
    }(r.Pointer);
var Ptr = function () {
        function Ptr(val) {
            _classCallCheck(this, Ptr);
            this.val = val;
            this.forceLarge = true;
        }
        Ptr.prototype.valueOf = function valueOf() {
            return this.val;
        };
        return Ptr;
    }();
var CFFBlendOp = function () {
        function CFFBlendOp() {
            _classCallCheck(this, CFFBlendOp);
        }
        CFFBlendOp.decode = function decode(stream, parent, operands) {
            var numBlends = operands.pop();
            while (operands.length > numBlends) {
                operands.pop();
            }
        };
        return CFFBlendOp;
    }();
var CFFPrivateDict = new CFFDict([
        [
            6,
            'BlueValues',
            'delta',
            null
        ],
        [
            7,
            'OtherBlues',
            'delta',
            null
        ],
        [
            8,
            'FamilyBlues',
            'delta',
            null
        ],
        [
            9,
            'FamilyOtherBlues',
            'delta',
            null
        ],
        [
            [
                12,
                9
            ],
            'BlueScale',
            'number',
            0.039625
        ],
        [
            [
                12,
                10
            ],
            'BlueShift',
            'number',
            7
        ],
        [
            [
                12,
                11
            ],
            'BlueFuzz',
            'number',
            1
        ],
        [
            10,
            'StdHW',
            'number',
            null
        ],
        [
            11,
            'StdVW',
            'number',
            null
        ],
        [
            [
                12,
                12
            ],
            'StemSnapH',
            'delta',
            null
        ],
        [
            [
                12,
                13
            ],
            'StemSnapV',
            'delta',
            null
        ],
        [
            [
                12,
                14
            ],
            'ForceBold',
            'boolean',
            false
        ],
        [
            [
                12,
                17
            ],
            'LanguageGroup',
            'number',
            0
        ],
        [
            [
                12,
                18
            ],
            'ExpansionFactor',
            'number',
            0.06
        ],
        [
            [
                12,
                19
            ],
            'initialRandomSeed',
            'number',
            0
        ],
        [
            20,
            'defaultWidthX',
            'number',
            0
        ],
        [
            21,
            'nominalWidthX',
            'number',
            0
        ],
        [
            22,
            'vsindex',
            'number',
            0
        ],
        [
            23,
            'blend',
            CFFBlendOp,
            null
        ],
        [
            19,
            'Subrs',
            new CFFPointer(new CFFIndex(), { type: 'local' }),
            null
        ]
    ]);
var standardStrings = [
        '.notdef',
        'space',
        'exclam',
        'quotedbl',
        'numbersign',
        'dollar',
        'percent',
        'ampersand',
        'quoteright',
        'parenleft',
        'parenright',
        'asterisk',
        'plus',
        'comma',
        'hyphen',
        'period',
        'slash',
        'zero',
        'one',
        'two',
        'three',
        'four',
        'five',
        'six',
        'seven',
        'eight',
        'nine',
        'colon',
        'semicolon',
        'less',
        'equal',
        'greater',
        'question',
        'at',
        'A',
        'B',
        'C',
        'D',
        'E',
        'F',
        'G',
        'H',
        'I',
        'J',
        'K',
        'L',
        'M',
        'N',
        'O',
        'P',
        'Q',
        'R',
        'S',
        'T',
        'U',
        'V',
        'W',
        'X',
        'Y',
        'Z',
        'bracketleft',
        'backslash',
        'bracketright',
        'asciicircum',
        'underscore',
        'quoteleft',
        'a',
        'b',
        'c',
        'd',
        'e',
        'f',
        'g',
        'h',
        'i',
        'j',
        'k',
        'l',
        'm',
        'n',
        'o',
        'p',
        'q',
        'r',
        's',
        't',
        'u',
        'v',
        'w',
        'x',
        'y',
        'z',
        'braceleft',
        'bar',
        'braceright',
        'asciitilde',
        'exclamdown',
        'cent',
        'sterling',
        'fraction',
        'yen',
        'florin',
        'section',
        'currency',
        'quotesingle',
        'quotedblleft',
        'guillemotleft',
        'guilsinglleft',
        'guilsinglright',
        'fi',
        'fl',
        'endash',
        'dagger',
        'daggerdbl',
        'periodcentered',
        'paragraph',
        'bullet',
        'quotesinglbase',
        'quotedblbase',
        'quotedblright',
        'guillemotright',
        'ellipsis',
        'perthousand',
        'questiondown',
        'grave',
        'acute',
        'circumflex',
        'tilde',
        'macron',
        'breve',
        'dotaccent',
        'dieresis',
        'ring',
        'cedilla',
        'hungarumlaut',
        'ogonek',
        'caron',
        'emdash',
        'AE',
        'ordfeminine',
        'Lslash',
        'Oslash',
        'OE',
        'ordmasculine',
        'ae',
        'dotlessi',
        'lslash',
        'oslash',
        'oe',
        'germandbls',
        'onesuperior',
        'logicalnot',
        'mu',
        'trademark',
        'Eth',
        'onehalf',
        'plusminus',
        'Thorn',
        'onequarter',
        'divide',
        'brokenbar',
        'degree',
        'thorn',
        'threequarters',
        'twosuperior',
        'registered',
        'minus',
        'eth',
        'multiply',
        'threesuperior',
        'copyright',
        'Aacute',
        'Acircumflex',
        'Adieresis',
        'Agrave',
        'Aring',
        'Atilde',
        'Ccedilla',
        'Eacute',
        'Ecircumflex',
        'Edieresis',
        'Egrave',
        'Iacute',
        'Icircumflex',
        'Idieresis',
        'Igrave',
        'Ntilde',
        'Oacute',
        'Ocircumflex',
        'Odieresis',
        'Ograve',
        'Otilde',
        'Scaron',
        'Uacute',
        'Ucircumflex',
        'Udieresis',
        'Ugrave',
        'Yacute',
        'Ydieresis',
        'Zcaron',
        'aacute',
        'acircumflex',
        'adieresis',
        'agrave',
        'aring',
        'atilde',
        'ccedilla',
        'eacute',
        'ecircumflex',
        'edieresis',
        'egrave',
        'iacute',
        'icircumflex',
        'idieresis',
        'igrave',
        'ntilde',
        'oacute',
        'ocircumflex',
        'odieresis',
        'ograve',
        'otilde',
        'scaron',
        'uacute',
        'ucircumflex',
        'udieresis',
        'ugrave',
        'yacute',
        'ydieresis',
        'zcaron',
        'exclamsmall',
        'Hungarumlautsmall',
        'dollaroldstyle',
        'dollarsuperior',
        'ampersandsmall',
        'Acutesmall',
        'parenleftsuperior',
        'parenrightsuperior',
        'twodotenleader',
        'onedotenleader',
        'zerooldstyle',
        'oneoldstyle',
        'twooldstyle',
        'threeoldstyle',
        'fouroldstyle',
        'fiveoldstyle',
        'sixoldstyle',
        'sevenoldstyle',
        'eightoldstyle',
        'nineoldstyle',
        'commasuperior',
        'threequartersemdash',
        'periodsuperior',
        'questionsmall',
        'asuperior',
        'bsuperior',
        'centsuperior',
        'dsuperior',
        'esuperior',
        'isuperior',
        'lsuperior',
        'msuperior',
        'nsuperior',
        'osuperior',
        'rsuperior',
        'ssuperior',
        'tsuperior',
        'ff',
        'ffi',
        'ffl',
        'parenleftinferior',
        'parenrightinferior',
        'Circumflexsmall',
        'hyphensuperior',
        'Gravesmall',
        'Asmall',
        'Bsmall',
        'Csmall',
        'Dsmall',
        'Esmall',
        'Fsmall',
        'Gsmall',
        'Hsmall',
        'Ismall',
        'Jsmall',
        'Ksmall',
        'Lsmall',
        'Msmall',
        'Nsmall',
        'Osmall',
        'Psmall',
        'Qsmall',
        'Rsmall',
        'Ssmall',
        'Tsmall',
        'Usmall',
        'Vsmall',
        'Wsmall',
        'Xsmall',
        'Ysmall',
        'Zsmall',
        'colonmonetary',
        'onefitted',
        'rupiah',
        'Tildesmall',
        'exclamdownsmall',
        'centoldstyle',
        'Lslashsmall',
        'Scaronsmall',
        'Zcaronsmall',
        'Dieresissmall',
        'Brevesmall',
        'Caronsmall',
        'Dotaccentsmall',
        'Macronsmall',
        'figuredash',
        'hypheninferior',
        'Ogoneksmall',
        'Ringsmall',
        'Cedillasmall',
        'questiondownsmall',
        'oneeighth',
        'threeeighths',
        'fiveeighths',
        'seveneighths',
        'onethird',
        'twothirds',
        'zerosuperior',
        'foursuperior',
        'fivesuperior',
        'sixsuperior',
        'sevensuperior',
        'eightsuperior',
        'ninesuperior',
        'zeroinferior',
        'oneinferior',
        'twoinferior',
        'threeinferior',
        'fourinferior',
        'fiveinferior',
        'sixinferior',
        'seveninferior',
        'eightinferior',
        'nineinferior',
        'centinferior',
        'dollarinferior',
        'periodinferior',
        'commainferior',
        'Agravesmall',
        'Aacutesmall',
        'Acircumflexsmall',
        'Atildesmall',
        'Adieresissmall',
        'Aringsmall',
        'AEsmall',
        'Ccedillasmall',
        'Egravesmall',
        'Eacutesmall',
        'Ecircumflexsmall',
        'Edieresissmall',
        'Igravesmall',
        'Iacutesmall',
        'Icircumflexsmall',
        'Idieresissmall',
        'Ethsmall',
        'Ntildesmall',
        'Ogravesmall',
        'Oacutesmall',
        'Ocircumflexsmall',
        'Otildesmall',
        'Odieresissmall',
        'OEsmall',
        'Oslashsmall',
        'Ugravesmall',
        'Uacutesmall',
        'Ucircumflexsmall',
        'Udieresissmall',
        'Yacutesmall',
        'Thornsmall',
        'Ydieresissmall',
        '001.000',
        '001.001',
        '001.002',
        '001.003',
        'Black',
        'Bold',
        'Book',
        'Light',
        'Medium',
        'Regular',
        'Roman',
        'Semibold'
    ];
var StandardEncoding = [
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        'space',
        'exclam',
        'quotedbl',
        'numbersign',
        'dollar',
        'percent',
        'ampersand',
        'quoteright',
        'parenleft',
        'parenright',
        'asterisk',
        'plus',
        'comma',
        'hyphen',
        'period',
        'slash',
        'zero',
        'one',
        'two',
        'three',
        'four',
        'five',
        'six',
        'seven',
        'eight',
        'nine',
        'colon',
        'semicolon',
        'less',
        'equal',
        'greater',
        'question',
        'at',
        'A',
        'B',
        'C',
        'D',
        'E',
        'F',
        'G',
        'H',
        'I',
        'J',
        'K',
        'L',
        'M',
        'N',
        'O',
        'P',
        'Q',
        'R',
        'S',
        'T',
        'U',
        'V',
        'W',
        'X',
        'Y',
        'Z',
        'bracketleft',
        'backslash',
        'bracketright',
        'asciicircum',
        'underscore',
        'quoteleft',
        'a',
        'b',
        'c',
        'd',
        'e',
        'f',
        'g',
        'h',
        'i',
        'j',
        'k',
        'l',
        'm',
        'n',
        'o',
        'p',
        'q',
        'r',
        's',
        't',
        'u',
        'v',
        'w',
        'x',
        'y',
        'z',
        'braceleft',
        'bar',
        'braceright',
        'asciitilde',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        'exclamdown',
        'cent',
        'sterling',
        'fraction',
        'yen',
        'florin',
        'section',
        'currency',
        'quotesingle',
        'quotedblleft',
        'guillemotleft',
        'guilsinglleft',
        'guilsinglright',
        'fi',
        'fl',
        '',
        'endash',
        'dagger',
        'daggerdbl',
        'periodcentered',
        '',
        'paragraph',
        'bullet',
        'quotesinglbase',
        'quotedblbase',
        'quotedblright',
        'guillemotright',
        'ellipsis',
        'perthousand',
        '',
        'questiondown',
        '',
        'grave',
        'acute',
        'circumflex',
        'tilde',
        'macron',
        'breve',
        'dotaccent',
        'dieresis',
        '',
        'ring',
        'cedilla',
        '',
        'hungarumlaut',
        'ogonek',
        'caron',
        'emdash',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        'AE',
        '',
        'ordfeminine',
        '',
        '',
        '',
        '',
        'Lslash',
        'Oslash',
        'OE',
        'ordmasculine',
        '',
        '',
        '',
        '',
        '',
        'ae',
        '',
        '',
        '',
        'dotlessi',
        '',
        '',
        'lslash',
        'oslash',
        'oe',
        'germandbls'
    ];
var ExpertEncoding = [
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        'space',
        'exclamsmall',
        'Hungarumlautsmall',
        '',
        'dollaroldstyle',
        'dollarsuperior',
        'ampersandsmall',
        'Acutesmall',
        'parenleftsuperior',
        'parenrightsuperior',
        'twodotenleader',
        'onedotenleader',
        'comma',
        'hyphen',
        'period',
        'fraction',
        'zerooldstyle',
        'oneoldstyle',
        'twooldstyle',
        'threeoldstyle',
        'fouroldstyle',
        'fiveoldstyle',
        'sixoldstyle',
        'sevenoldstyle',
        'eightoldstyle',
        'nineoldstyle',
        'colon',
        'semicolon',
        'commasuperior',
        'threequartersemdash',
        'periodsuperior',
        'questionsmall',
        '',
        'asuperior',
        'bsuperior',
        'centsuperior',
        'dsuperior',
        'esuperior',
        '',
        '',
        'isuperior',
        '',
        '',
        'lsuperior',
        'msuperior',
        'nsuperior',
        'osuperior',
        '',
        '',
        'rsuperior',
        'ssuperior',
        'tsuperior',
        '',
        'ff',
        'fi',
        'fl',
        'ffi',
        'ffl',
        'parenleftinferior',
        '',
        'parenrightinferior',
        'Circumflexsmall',
        'hyphensuperior',
        'Gravesmall',
        'Asmall',
        'Bsmall',
        'Csmall',
        'Dsmall',
        'Esmall',
        'Fsmall',
        'Gsmall',
        'Hsmall',
        'Ismall',
        'Jsmall',
        'Ksmall',
        'Lsmall',
        'Msmall',
        'Nsmall',
        'Osmall',
        'Psmall',
        'Qsmall',
        'Rsmall',
        'Ssmall',
        'Tsmall',
        'Usmall',
        'Vsmall',
        'Wsmall',
        'Xsmall',
        'Ysmall',
        'Zsmall',
        'colonmonetary',
        'onefitted',
        'rupiah',
        'Tildesmall',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        'exclamdownsmall',
        'centoldstyle',
        'Lslashsmall',
        '',
        '',
        'Scaronsmall',
        'Zcaronsmall',
        'Dieresissmall',
        'Brevesmall',
        'Caronsmall',
        '',
        'Dotaccentsmall',
        '',
        '',
        'Macronsmall',
        '',
        '',
        'figuredash',
        'hypheninferior',
        '',
        '',
        'Ogoneksmall',
        'Ringsmall',
        'Cedillasmall',
        '',
        '',
        '',
        'onequarter',
        'onehalf',
        'threequarters',
        'questiondownsmall',
        'oneeighth',
        'threeeighths',
        'fiveeighths',
        'seveneighths',
        'onethird',
        'twothirds',
        '',
        '',
        'zerosuperior',
        'onesuperior',
        'twosuperior',
        'threesuperior',
        'foursuperior',
        'fivesuperior',
        'sixsuperior',
        'sevensuperior',
        'eightsuperior',
        'ninesuperior',
        'zeroinferior',
        'oneinferior',
        'twoinferior',
        'threeinferior',
        'fourinferior',
        'fiveinferior',
        'sixinferior',
        'seveninferior',
        'eightinferior',
        'nineinferior',
        'centinferior',
        'dollarinferior',
        'periodinferior',
        'commainferior',
        'Agravesmall',
        'Aacutesmall',
        'Acircumflexsmall',
        'Atildesmall',
        'Adieresissmall',
        'Aringsmall',
        'AEsmall',
        'Ccedillasmall',
        'Egravesmall',
        'Eacutesmall',
        'Ecircumflexsmall',
        'Edieresissmall',
        'Igravesmall',
        'Iacutesmall',
        'Icircumflexsmall',
        'Idieresissmall',
        'Ethsmall',
        'Ntildesmall',
        'Ogravesmall',
        'Oacutesmall',
        'Ocircumflexsmall',
        'Otildesmall',
        'Odieresissmall',
        'OEsmall',
        'Oslashsmall',
        'Ugravesmall',
        'Uacutesmall',
        'Ucircumflexsmall',
        'Udieresissmall',
        'Yacutesmall',
        'Thornsmall',
        'Ydieresissmall'
    ];
var ISOAdobeCharset = [
        '.notdef',
        'space',
        'exclam',
        'quotedbl',
        'numbersign',
        'dollar',
        'percent',
        'ampersand',
        'quoteright',
        'parenleft',
        'parenright',
        'asterisk',
        'plus',
        'comma',
        'hyphen',
        'period',
        'slash',
        'zero',
        'one',
        'two',
        'three',
        'four',
        'five',
        'six',
        'seven',
        'eight',
        'nine',
        'colon',
        'semicolon',
        'less',
        'equal',
        'greater',
        'question',
        'at',
        'A',
        'B',
        'C',
        'D',
        'E',
        'F',
        'G',
        'H',
        'I',
        'J',
        'K',
        'L',
        'M',
        'N',
        'O',
        'P',
        'Q',
        'R',
        'S',
        'T',
        'U',
        'V',
        'W',
        'X',
        'Y',
        'Z',
        'bracketleft',
        'backslash',
        'bracketright',
        'asciicircum',
        'underscore',
        'quoteleft',
        'a',
        'b',
        'c',
        'd',
        'e',
        'f',
        'g',
        'h',
        'i',
        'j',
        'k',
        'l',
        'm',
        'n',
        'o',
        'p',
        'q',
        'r',
        's',
        't',
        'u',
        'v',
        'w',
        'x',
        'y',
        'z',
        'braceleft',
        'bar',
        'braceright',
        'asciitilde',
        'exclamdown',
        'cent',
        'sterling',
        'fraction',
        'yen',
        'florin',
        'section',
        'currency',
        'quotesingle',
        'quotedblleft',
        'guillemotleft',
        'guilsinglleft',
        'guilsinglright',
        'fi',
        'fl',
        'endash',
        'dagger',
        'daggerdbl',
        'periodcentered',
        'paragraph',
        'bullet',
        'quotesinglbase',
        'quotedblbase',
        'quotedblright',
        'guillemotright',
        'ellipsis',
        'perthousand',
        'questiondown',
        'grave',
        'acute',
        'circumflex',
        'tilde',
        'macron',
        'breve',
        'dotaccent',
        'dieresis',
        'ring',
        'cedilla',
        'hungarumlaut',
        'ogonek',
        'caron',
        'emdash',
        'AE',
        'ordfeminine',
        'Lslash',
        'Oslash',
        'OE',
        'ordmasculine',
        'ae',
        'dotlessi',
        'lslash',
        'oslash',
        'oe',
        'germandbls',
        'onesuperior',
        'logicalnot',
        'mu',
        'trademark',
        'Eth',
        'onehalf',
        'plusminus',
        'Thorn',
        'onequarter',
        'divide',
        'brokenbar',
        'degree',
        'thorn',
        'threequarters',
        'twosuperior',
        'registered',
        'minus',
        'eth',
        'multiply',
        'threesuperior',
        'copyright',
        'Aacute',
        'Acircumflex',
        'Adieresis',
        'Agrave',
        'Aring',
        'Atilde',
        'Ccedilla',
        'Eacute',
        'Ecircumflex',
        'Edieresis',
        'Egrave',
        'Iacute',
        'Icircumflex',
        'Idieresis',
        'Igrave',
        'Ntilde',
        'Oacute',
        'Ocircumflex',
        'Odieresis',
        'Ograve',
        'Otilde',
        'Scaron',
        'Uacute',
        'Ucircumflex',
        'Udieresis',
        'Ugrave',
        'Yacute',
        'Ydieresis',
        'Zcaron',
        'aacute',
        'acircumflex',
        'adieresis',
        'agrave',
        'aring',
        'atilde',
        'ccedilla',
        'eacute',
        'ecircumflex',
        'edieresis',
        'egrave',
        'iacute',
        'icircumflex',
        'idieresis',
        'igrave',
        'ntilde',
        'oacute',
        'ocircumflex',
        'odieresis',
        'ograve',
        'otilde',
        'scaron',
        'uacute',
        'ucircumflex',
        'udieresis',
        'ugrave',
        'yacute',
        'ydieresis',
        'zcaron'
    ];
var ExpertCharset = [
        '.notdef',
        'space',
        'exclamsmall',
        'Hungarumlautsmall',
        'dollaroldstyle',
        'dollarsuperior',
        'ampersandsmall',
        'Acutesmall',
        'parenleftsuperior',
        'parenrightsuperior',
        'twodotenleader',
        'onedotenleader',
        'comma',
        'hyphen',
        'period',
        'fraction',
        'zerooldstyle',
        'oneoldstyle',
        'twooldstyle',
        'threeoldstyle',
        'fouroldstyle',
        'fiveoldstyle',
        'sixoldstyle',
        'sevenoldstyle',
        'eightoldstyle',
        'nineoldstyle',
        'colon',
        'semicolon',
        'commasuperior',
        'threequartersemdash',
        'periodsuperior',
        'questionsmall',
        'asuperior',
        'bsuperior',
        'centsuperior',
        'dsuperior',
        'esuperior',
        'isuperior',
        'lsuperior',
        'msuperior',
        'nsuperior',
        'osuperior',
        'rsuperior',
        'ssuperior',
        'tsuperior',
        'ff',
        'fi',
        'fl',
        'ffi',
        'ffl',
        'parenleftinferior',
        'parenrightinferior',
        'Circumflexsmall',
        'hyphensuperior',
        'Gravesmall',
        'Asmall',
        'Bsmall',
        'Csmall',
        'Dsmall',
        'Esmall',
        'Fsmall',
        'Gsmall',
        'Hsmall',
        'Ismall',
        'Jsmall',
        'Ksmall',
        'Lsmall',
        'Msmall',
        'Nsmall',
        'Osmall',
        'Psmall',
        'Qsmall',
        'Rsmall',
        'Ssmall',
        'Tsmall',
        'Usmall',
        'Vsmall',
        'Wsmall',
        'Xsmall',
        'Ysmall',
        'Zsmall',
        'colonmonetary',
        'onefitted',
        'rupiah',
        'Tildesmall',
        'exclamdownsmall',
        'centoldstyle',
        'Lslashsmall',
        'Scaronsmall',
        'Zcaronsmall',
        'Dieresissmall',
        'Brevesmall',
        'Caronsmall',
        'Dotaccentsmall',
        'Macronsmall',
        'figuredash',
        'hypheninferior',
        'Ogoneksmall',
        'Ringsmall',
        'Cedillasmall',
        'onequarter',
        'onehalf',
        'threequarters',
        'questiondownsmall',
        'oneeighth',
        'threeeighths',
        'fiveeighths',
        'seveneighths',
        'onethird',
        'twothirds',
        'zerosuperior',
        'onesuperior',
        'twosuperior',
        'threesuperior',
        'foursuperior',
        'fivesuperior',
        'sixsuperior',
        'sevensuperior',
        'eightsuperior',
        'ninesuperior',
        'zeroinferior',
        'oneinferior',
        'twoinferior',
        'threeinferior',
        'fourinferior',
        'fiveinferior',
        'sixinferior',
        'seveninferior',
        'eightinferior',
        'nineinferior',
        'centinferior',
        'dollarinferior',
        'periodinferior',
        'commainferior',
        'Agravesmall',
        'Aacutesmall',
        'Acircumflexsmall',
        'Atildesmall',
        'Adieresissmall',
        'Aringsmall',
        'AEsmall',
        'Ccedillasmall',
        'Egravesmall',
        'Eacutesmall',
        'Ecircumflexsmall',
        'Edieresissmall',
        'Igravesmall',
        'Iacutesmall',
        'Icircumflexsmall',
        'Idieresissmall',
        'Ethsmall',
        'Ntildesmall',
        'Ogravesmall',
        'Oacutesmall',
        'Ocircumflexsmall',
        'Otildesmall',
        'Odieresissmall',
        'OEsmall',
        'Oslashsmall',
        'Ugravesmall',
        'Uacutesmall',
        'Ucircumflexsmall',
        'Udieresissmall',
        'Yacutesmall',
        'Thornsmall',
        'Ydieresissmall'
    ];
var ExpertSubsetCharset = [
        '.notdef',
        'space',
        'dollaroldstyle',
        'dollarsuperior',
        'parenleftsuperior',
        'parenrightsuperior',
        'twodotenleader',
        'onedotenleader',
        'comma',
        'hyphen',
        'period',
        'fraction',
        'zerooldstyle',
        'oneoldstyle',
        'twooldstyle',
        'threeoldstyle',
        'fouroldstyle',
        'fiveoldstyle',
        'sixoldstyle',
        'sevenoldstyle',
        'eightoldstyle',
        'nineoldstyle',
        'colon',
        'semicolon',
        'commasuperior',
        'threequartersemdash',
        'periodsuperior',
        'asuperior',
        'bsuperior',
        'centsuperior',
        'dsuperior',
        'esuperior',
        'isuperior',
        'lsuperior',
        'msuperior',
        'nsuperior',
        'osuperior',
        'rsuperior',
        'ssuperior',
        'tsuperior',
        'ff',
        'fi',
        'fl',
        'ffi',
        'ffl',
        'parenleftinferior',
        'parenrightinferior',
        'hyphensuperior',
        'colonmonetary',
        'onefitted',
        'rupiah',
        'centoldstyle',
        'figuredash',
        'hypheninferior',
        'onequarter',
        'onehalf',
        'threequarters',
        'oneeighth',
        'threeeighths',
        'fiveeighths',
        'seveneighths',
        'onethird',
        'twothirds',
        'zerosuperior',
        'onesuperior',
        'twosuperior',
        'threesuperior',
        'foursuperior',
        'fivesuperior',
        'sixsuperior',
        'sevensuperior',
        'eightsuperior',
        'ninesuperior',
        'zeroinferior',
        'oneinferior',
        'twoinferior',
        'threeinferior',
        'fourinferior',
        'fiveinferior',
        'sixinferior',
        'seveninferior',
        'eightinferior',
        'nineinferior',
        'centinferior',
        'dollarinferior',
        'periodinferior',
        'commainferior'
    ];
var LangSysTable = new r.Struct({
        reserved: new r.Reserved(r.uint16),
        reqFeatureIndex: r.uint16,
        featureCount: r.uint16,
        featureIndexes: new r.Array(r.uint16, 'featureCount')
    });
var LangSysRecord = new r.Struct({
        tag: new r.String(4),
        langSys: new r.Pointer(r.uint16, LangSysTable, { type: 'parent' })
    });
var Script = new r.Struct({
        defaultLangSys: new r.Pointer(r.uint16, LangSysTable),
        count: r.uint16,
        langSysRecords: new r.Array(LangSysRecord, 'count')
    });
var ScriptRecord = new r.Struct({
        tag: new r.String(4),
        script: new r.Pointer(r.uint16, Script, { type: 'parent' })
    });
var ScriptList = new r.Array(ScriptRecord, r.uint16);
var Feature = new r.Struct({
        featureParams: r.uint16,
        lookupCount: r.uint16,
        lookupListIndexes: new r.Array(r.uint16, 'lookupCount')
    });
var FeatureRecord = new r.Struct({
        tag: new r.String(4),
        feature: new r.Pointer(r.uint16, Feature, { type: 'parent' })
    });
var FeatureList = new r.Array(FeatureRecord, r.uint16);
var LookupFlags = new r.Struct({
        markAttachmentType: r.uint8,
        flags: new r.Bitfield(r.uint8, [
            'rightToLeft',
            'ignoreBaseGlyphs',
            'ignoreLigatures',
            'ignoreMarks',
            'useMarkFilteringSet'
        ])
    });
function LookupList(SubTable) {
    var Lookup = new r.Struct({
            lookupType: r.uint16,
            flags: LookupFlags,
            subTableCount: r.uint16,
            subTables: new r.Array(new r.Pointer(r.uint16, SubTable), 'subTableCount'),
            markFilteringSet: new r.Optional(r.uint16, function (t) {
                return t.flags.flags.useMarkFilteringSet;
            })
        });
    return new r.LazyArray(new r.Pointer(r.uint16, Lookup), r.uint16);
}
var RangeRecord = new r.Struct({
        start: r.uint16,
        end: r.uint16,
        startCoverageIndex: r.uint16
    });
var Coverage = new r.VersionedStruct(r.uint16, {
        1: {
            glyphCount: r.uint16,
            glyphs: new r.Array(r.uint16, 'glyphCount')
        },
        2: {
            rangeCount: r.uint16,
            rangeRecords: new r.Array(RangeRecord, 'rangeCount')
        }
    });
var ClassRangeRecord = new r.Struct({
        start: r.uint16,
        end: r.uint16,
        class: r.uint16
    });
var ClassDef = new r.VersionedStruct(r.uint16, {
        1: {
            startGlyph: r.uint16,
            glyphCount: r.uint16,
            classValueArray: new r.Array(r.uint16, 'glyphCount')
        },
        2: {
            classRangeCount: r.uint16,
            classRangeRecord: new r.Array(ClassRangeRecord, 'classRangeCount')
        }
    });
var Device = new r.Struct({
        a: r.uint16,
        b: r.uint16,
        deltaFormat: r.uint16
    });
var LookupRecord = new r.Struct({
        sequenceIndex: r.uint16,
        lookupListIndex: r.uint16
    });
var Rule = new r.Struct({
        glyphCount: r.uint16,
        lookupCount: r.uint16,
        input: new r.Array(r.uint16, function (t) {
            return t.glyphCount - 1;
        }),
        lookupRecords: new r.Array(LookupRecord, 'lookupCount')
    });
var RuleSet = new r.Array(new r.Pointer(r.uint16, Rule), r.uint16);
var ClassRule = new r.Struct({
        glyphCount: r.uint16,
        lookupCount: r.uint16,
        classes: new r.Array(r.uint16, function (t) {
            return t.glyphCount - 1;
        }),
        lookupRecords: new r.Array(LookupRecord, 'lookupCount')
    });
var ClassSet = new r.Array(new r.Pointer(r.uint16, ClassRule), r.uint16);
var Context = new r.VersionedStruct(r.uint16, {
        1: {
            coverage: new r.Pointer(r.uint16, Coverage),
            ruleSetCount: r.uint16,
            ruleSets: new r.Array(new r.Pointer(r.uint16, RuleSet), 'ruleSetCount')
        },
        2: {
            coverage: new r.Pointer(r.uint16, Coverage),
            classDef: new r.Pointer(r.uint16, ClassDef),
            classSetCnt: r.uint16,
            classSet: new r.Array(new r.Pointer(r.uint16, ClassSet), 'classSetCnt')
        },
        3: {
            glyphCount: r.uint16,
            lookupCount: r.uint16,
            coverages: new r.Array(new r.Pointer(r.uint16, Coverage), 'glyphCount'),
            lookupRecords: new r.Array(LookupRecord, 'lookupCount')
        }
    });
var ChainRule = new r.Struct({
        backtrackGlyphCount: r.uint16,
        backtrack: new r.Array(r.uint16, 'backtrackGlyphCount'),
        inputGlyphCount: r.uint16,
        input: new r.Array(r.uint16, function (t) {
            return t.inputGlyphCount - 1;
        }),
        lookaheadGlyphCount: r.uint16,
        lookahead: new r.Array(r.uint16, 'lookaheadGlyphCount'),
        lookupCount: r.uint16,
        lookupRecords: new r.Array(LookupRecord, 'lookupCount')
    });
var ChainRuleSet = new r.Array(new r.Pointer(r.uint16, ChainRule), r.uint16);
var ChainingContext = new r.VersionedStruct(r.uint16, {
        1: {
            coverage: new r.Pointer(r.uint16, Coverage),
            chainCount: r.uint16,
            chainRuleSets: new r.Array(new r.Pointer(r.uint16, ChainRuleSet), 'chainCount')
        },
        2: {
            coverage: new r.Pointer(r.uint16, Coverage),
            backtrackClassDef: new r.Pointer(r.uint16, ClassDef),
            inputClassDef: new r.Pointer(r.uint16, ClassDef),
            lookaheadClassDef: new r.Pointer(r.uint16, ClassDef),
            chainCount: r.uint16,
            chainClassSet: new r.Array(new r.Pointer(r.uint16, ChainRuleSet), 'chainCount')
        },
        3: {
            backtrackGlyphCount: r.uint16,
            backtrackCoverage: new r.Array(new r.Pointer(r.uint16, Coverage), 'backtrackGlyphCount'),
            inputGlyphCount: r.uint16,
            inputCoverage: new r.Array(new r.Pointer(r.uint16, Coverage), 'inputGlyphCount'),
            lookaheadGlyphCount: r.uint16,
            lookaheadCoverage: new r.Array(new r.Pointer(r.uint16, Coverage), 'lookaheadGlyphCount'),
            lookupCount: r.uint16,
            lookupRecords: new r.Array(LookupRecord, 'lookupCount')
        }
    });
var _;
var F2DOT14 = new r.Fixed(16, 'BE', 14);
var RegionAxisCoordinates = new r.Struct({
        startCoord: F2DOT14,
        peakCoord: F2DOT14,
        endCoord: F2DOT14
    });
var VariationRegionList = new r.Struct({
        axisCount: r.uint16,
        regionCount: r.uint16,
        variationRegions: new r.Array(new r.Array(RegionAxisCoordinates, 'axisCount'), 'regionCount')
    });
var DeltaSet = new r.Struct({
        shortDeltas: new r.Array(r.int16, function (t) {
            return t.parent.shortDeltaCount;
        }),
        regionDeltas: new r.Array(r.int8, function (t) {
            return t.parent.regionIndexCount - t.parent.shortDeltaCount;
        }),
        deltas: function deltas(t) {
            return t.shortDeltas.concat(t.regionDeltas);
        }
    });
var ItemVariationData = new r.Struct({
        itemCount: r.uint16,
        shortDeltaCount: r.uint16,
        regionIndexCount: r.uint16,
        regionIndexes: new r.Array(r.uint16, 'regionIndexCount'),
        deltaSets: new r.Array(DeltaSet, 'itemCount')
    });
var ItemVariationStore = new r.Struct({
        format: r.uint16,
        variationRegionList: new r.Pointer(r.uint32, VariationRegionList),
        variationDataCount: r.uint16,
        itemVariationData: new r.Array(new r.Pointer(r.uint32, ItemVariationData), 'variationDataCount')
    });
var ConditionTable = new r.VersionedStruct(r.uint16, { 1: (_ = { axisIndex: r.uint16 }, _['axisIndex'] = r.uint16, _.filterRangeMinValue = F2DOT14, _.filterRangeMaxValue = F2DOT14, _) });
var ConditionSet = new r.Struct({
        conditionCount: r.uint16,
        conditionTable: new r.Array(new r.Pointer(r.uint32, ConditionTable), 'conditionCount')
    });
var FeatureTableSubstitutionRecord = new r.Struct({
        featureIndex: r.uint16,
        alternateFeatureTable: new r.Pointer(r.uint32, Feature, { type: 'parent' })
    });
var FeatureTableSubstitution = new r.Struct({
        version: r.fixed32,
        substitutionCount: r.uint16,
        substitutions: new r.Array(FeatureTableSubstitutionRecord, 'substitutionCount')
    });
var FeatureVariationRecord = new r.Struct({
        conditionSet: new r.Pointer(r.uint32, ConditionSet, { type: 'parent' }),
        featureTableSubstitution: new r.Pointer(r.uint32, FeatureTableSubstitution, { type: 'parent' })
    });
var FeatureVariations = new r.Struct({
        majorVersion: r.uint16,
        minorVersion: r.uint16,
        featureVariationRecordCount: r.uint32,
        featureVariationRecords: new r.Array(FeatureVariationRecord, 'featureVariationRecordCount')
    });
var PredefinedOp = function () {
        function PredefinedOp(predefinedOps, type) {
            _classCallCheck(this, PredefinedOp);
            this.predefinedOps = predefinedOps;
            this.type = type;
        }
        PredefinedOp.prototype.decode = function decode(stream, parent, operands) {
            if (this.predefinedOps[operands[0]]) {
                return this.predefinedOps[operands[0]];
            }
            return this.type.decode(stream, parent, operands);
        };
        PredefinedOp.prototype.size = function size(value, ctx) {
            return this.type.size(value, ctx);
        };
        PredefinedOp.prototype.encode = function encode(stream, value, ctx) {
            var index = this.predefinedOps.indexOf(value);
            if (index !== -1) {
                return index;
            }
            return this.type.encode(stream, value, ctx);
        };
        return PredefinedOp;
    }();
var CFFEncodingVersion = function (_r$Number) {
        _inherits(CFFEncodingVersion, _r$Number);
        function CFFEncodingVersion() {
            _classCallCheck(this, CFFEncodingVersion);
            return _possibleConstructorReturn(this, _r$Number.call(this, 'UInt8'));
        }
        CFFEncodingVersion.prototype.decode = function decode(stream) {
            return r.uint8.decode(stream) & 127;
        };
        return CFFEncodingVersion;
    }(r.Number);
var Range1 = new r.Struct({
        first: r.uint16,
        nLeft: r.uint8
    });
var Range2 = new r.Struct({
        first: r.uint16,
        nLeft: r.uint16
    });
var CFFCustomEncoding = new r.VersionedStruct(new CFFEncodingVersion(), {
        0: {
            nCodes: r.uint8,
            codes: new r.Array(r.uint8, 'nCodes')
        },
        1: {
            nRanges: r.uint8,
            ranges: new r.Array(Range1, 'nRanges')
        }
    });
var CFFEncoding = new PredefinedOp([
        StandardEncoding,
        ExpertEncoding
    ], new CFFPointer(CFFCustomEncoding, { lazy: true }));
var RangeArray = function (_r$Array) {
        _inherits(RangeArray, _r$Array);
        function RangeArray() {
            _classCallCheck(this, RangeArray);
            return _possibleConstructorReturn(this, _r$Array.apply(this, arguments));
        }
        RangeArray.prototype.decode = function decode(stream, parent) {
            var length = restructure_src_utils.resolveLength(this.length, stream, parent);
            var count = 0;
            var res = [];
            while (count < length) {
                var range = this.type.decode(stream, parent);
                range.offset = count;
                count += range.nLeft + 1;
                res.push(range);
            }
            return res;
        };
        return RangeArray;
    }(r.Array);
var CFFCustomCharset = new r.VersionedStruct(r.uint8, {
        0: {
            glyphs: new r.Array(r.uint16, function (t) {
                return t.parent.CharStrings.length - 1;
            })
        },
        1: {
            ranges: new RangeArray(Range1, function (t) {
                return t.parent.CharStrings.length - 1;
            })
        },
        2: {
            ranges: new RangeArray(Range2, function (t) {
                return t.parent.CharStrings.length - 1;
            })
        }
    });
var CFFCharset = new PredefinedOp([
        ISOAdobeCharset,
        ExpertCharset,
        ExpertSubsetCharset
    ], new CFFPointer(CFFCustomCharset, { lazy: true }));
var FDRange3 = new r.Struct({
        first: r.uint16,
        fd: r.uint8
    });
var FDRange4 = new r.Struct({
        first: r.uint32,
        fd: r.uint16
    });
var FDSelect = new r.VersionedStruct(r.uint8, {
        0: {
            fds: new r.Array(r.uint8, function (t) {
                return t.parent.CharStrings.length;
            })
        },
        3: {
            nRanges: r.uint16,
            ranges: new r.Array(FDRange3, 'nRanges'),
            sentinel: r.uint16
        },
        4: {
            nRanges: r.uint32,
            ranges: new r.Array(FDRange4, 'nRanges'),
            sentinel: r.uint32
        }
    });
var ptr = new CFFPointer(CFFPrivateDict);
var CFFPrivateOp = function () {
        function CFFPrivateOp() {
            _classCallCheck(this, CFFPrivateOp);
        }
        CFFPrivateOp.prototype.decode = function decode(stream, parent, operands) {
            parent.length = operands[0];
            return ptr.decode(stream, parent, [operands[1]]);
        };
        CFFPrivateOp.prototype.size = function size(dict, ctx) {
            return [
                CFFPrivateDict.size(dict, ctx, false),
                ptr.size(dict, ctx)[0]
            ];
        };
        CFFPrivateOp.prototype.encode = function encode(stream, dict, ctx) {
            return [
                CFFPrivateDict.size(dict, ctx, false),
                ptr.encode(stream, dict, ctx)[0]
            ];
        };
        return CFFPrivateOp;
    }();
var FontDict = new CFFDict([
        [
            18,
            'Private',
            new CFFPrivateOp(),
            null
        ],
        [
            [
                12,
                38
            ],
            'FontName',
            'sid',
            null
        ]
    ]);
var CFFTopDict = new CFFDict([
        [
            [
                12,
                30
            ],
            'ROS',
            [
                'sid',
                'sid',
                'number'
            ],
            null
        ],
        [
            0,
            'version',
            'sid',
            null
        ],
        [
            1,
            'Notice',
            'sid',
            null
        ],
        [
            [
                12,
                0
            ],
            'Copyright',
            'sid',
            null
        ],
        [
            2,
            'FullName',
            'sid',
            null
        ],
        [
            3,
            'FamilyName',
            'sid',
            null
        ],
        [
            4,
            'Weight',
            'sid',
            null
        ],
        [
            [
                12,
                1
            ],
            'isFixedPitch',
            'boolean',
            false
        ],
        [
            [
                12,
                2
            ],
            'ItalicAngle',
            'number',
            0
        ],
        [
            [
                12,
                3
            ],
            'UnderlinePosition',
            'number',
            -100
        ],
        [
            [
                12,
                4
            ],
            'UnderlineThickness',
            'number',
            50
        ],
        [
            [
                12,
                5
            ],
            'PaintType',
            'number',
            0
        ],
        [
            [
                12,
                6
            ],
            'CharstringType',
            'number',
            2
        ],
        [
            [
                12,
                7
            ],
            'FontMatrix',
            'array',
            [
                0.001,
                0,
                0,
                0.001,
                0,
                0
            ]
        ],
        [
            13,
            'UniqueID',
            'number',
            null
        ],
        [
            5,
            'FontBBox',
            'array',
            [
                0,
                0,
                0,
                0
            ]
        ],
        [
            [
                12,
                8
            ],
            'StrokeWidth',
            'number',
            0
        ],
        [
            14,
            'XUID',
            'array',
            null
        ],
        [
            15,
            'charset',
            CFFCharset,
            ISOAdobeCharset
        ],
        [
            16,
            'Encoding',
            CFFEncoding,
            StandardEncoding
        ],
        [
            17,
            'CharStrings',
            new CFFPointer(new CFFIndex()),
            null
        ],
        [
            18,
            'Private',
            new CFFPrivateOp(),
            null
        ],
        [
            [
                12,
                20
            ],
            'SyntheticBase',
            'number',
            null
        ],
        [
            [
                12,
                21
            ],
            'PostScript',
            'sid',
            null
        ],
        [
            [
                12,
                22
            ],
            'BaseFontName',
            'sid',
            null
        ],
        [
            [
                12,
                23
            ],
            'BaseFontBlend',
            'delta',
            null
        ],
        [
            [
                12,
                31
            ],
            'CIDFontVersion',
            'number',
            0
        ],
        [
            [
                12,
                32
            ],
            'CIDFontRevision',
            'number',
            0
        ],
        [
            [
                12,
                33
            ],
            'CIDFontType',
            'number',
            0
        ],
        [
            [
                12,
                34
            ],
            'CIDCount',
            'number',
            8720
        ],
        [
            [
                12,
                35
            ],
            'UIDBase',
            'number',
            null
        ],
        [
            [
                12,
                37
            ],
            'FDSelect',
            new CFFPointer(FDSelect),
            null
        ],
        [
            [
                12,
                36
            ],
            'FDArray',
            new CFFPointer(new CFFIndex(FontDict)),
            null
        ],
        [
            [
                12,
                38
            ],
            'FontName',
            'sid',
            null
        ]
    ]);
var VariationStore = new r.Struct({
        length: r.uint16,
        itemVariationStore: ItemVariationStore
    });
var CFF2TopDict = new CFFDict([
        [
            [
                12,
                7
            ],
            'FontMatrix',
            'array',
            [
                0.001,
                0,
                0,
                0.001,
                0,
                0
            ]
        ],
        [
            17,
            'CharStrings',
            new CFFPointer(new CFFIndex()),
            null
        ],
        [
            [
                12,
                37
            ],
            'FDSelect',
            new CFFPointer(FDSelect),
            null
        ],
        [
            [
                12,
                36
            ],
            'FDArray',
            new CFFPointer(new CFFIndex(FontDict)),
            null
        ],
        [
            24,
            'vstore',
            new CFFPointer(VariationStore),
            null
        ],
        [
            25,
            'maxstack',
            'number',
            193
        ]
    ]);
var CFFTop = new r.VersionedStruct(r.fixed16, {
        1: {
            hdrSize: r.uint8,
            offSize: r.uint8,
            nameIndex: new CFFIndex(new r.String('length')),
            topDictIndex: new CFFIndex(CFFTopDict),
            stringIndex: new CFFIndex(new r.String('length')),
            globalSubrIndex: new CFFIndex()
        },
        2: {
            hdrSize: r.uint8,
            length: r.uint16,
            topDict: CFF2TopDict,
            globalSubrIndex: new CFFIndex()
        }
    });
var CFFFont = function () {
        function CFFFont(stream) {
            _classCallCheck(this, CFFFont);
            this.stream = stream;
            this.decode();
        }
        CFFFont.decode = function decode(stream) {
            return new CFFFont(stream);
        };
        CFFFont.prototype.decode = function decode() {
            var start = this.stream.pos;
            var top = CFFTop.decode(this.stream);
            for (var key in top) {
                var val = top[key];
                this[key] = val;
            }
            if (this.version < 2) {
                if (this.topDictIndex.length !== 1) {
                    throw new Error('Only a single font is allowed in CFF');
                }
                this.topDict = this.topDictIndex[0];
            }
            this.isCIDFont = this.topDict.ROS != null;
            return this;
        };
        CFFFont.prototype.string = function string(sid) {
            if (this.version >= 2) {
                return null;
            }
            if (sid < standardStrings.length) {
                return standardStrings[sid];
            }
            return this.stringIndex[sid - standardStrings.length];
        };
        CFFFont.prototype.getCharString = function getCharString(glyph) {
            this.stream.pos = this.topDict.CharStrings[glyph].offset;
            return this.stream.readBuffer(this.topDict.CharStrings[glyph].length);
        };
        CFFFont.prototype.getGlyphName = function getGlyphName(gid) {
            if (this.version >= 2) {
                return null;
            }
            if (this.isCIDFont) {
                return null;
            }
            var charset = this.topDict.charset;
            if (Array.isArray(charset)) {
                return charset[gid];
            }
            if (gid === 0) {
                return '.notdef';
            }
            gid -= 1;
            switch (charset.version) {
            case 0:
                return this.string(charset.glyphs[gid]);
            case 1:
            case 2:
                for (var i = 0; i < charset.ranges.length; i++) {
                    var range = charset.ranges[i];
                    if (range.offset <= gid && gid <= range.offset + range.nLeft) {
                        return this.string(range.first + (gid - range.offset));
                    }
                }
                break;
            }
            return null;
        };
        CFFFont.prototype.fdForGlyph = function fdForGlyph(gid) {
            if (!this.topDict.FDSelect) {
                return null;
            }
            switch (this.topDict.FDSelect.version) {
            case 0:
                return this.topDict.FDSelect.fds[gid];
            case 3:
            case 4:
                var ranges = this.topDict.FDSelect.ranges;
                var low = 0;
                var high = ranges.length - 1;
                while (low <= high) {
                    var mid = low + high >> 1;
                    if (gid < ranges[mid].first) {
                        high = mid - 1;
                    } else if (mid < high && gid > ranges[mid + 1].first) {
                        low = mid + 1;
                    } else {
                        return ranges[mid].fd;
                    }
                }
            default:
                throw new Error('Unknown FDSelect version: ' + this.topDict.FDSelect.version);
            }
        };
        CFFFont.prototype.privateDictForGlyph = function privateDictForGlyph(gid) {
            if (this.topDict.FDSelect) {
                var fd = this.fdForGlyph(gid);
                if (this.topDict.FDArray[fd]) {
                    return this.topDict.FDArray[fd].Private;
                }
                return null;
            }
            if (this.version < 2) {
                return this.topDict.Private;
            }
            return this.topDict.FDArray[0].Private;
        };
        _createClass(CFFFont, [
            {
                key: 'postscriptName',
                get: function get() {
                    if (this.version < 2) {
                        return this.nameIndex[0];
                    }
                    return null;
                }
            },
            {
                key: 'fullName',
                get: function get() {
                    return this.string(this.topDict.FullName);
                }
            },
            {
                key: 'familyName',
                get: function get() {
                    return this.string(this.topDict.FamilyName);
                }
            }
        ]);
        return CFFFont;
    }();
var VerticalOrigin = new r.Struct({
        glyphIndex: r.uint16,
        vertOriginY: r.int16
    });
var VORG = new r.Struct({
        majorVersion: r.uint16,
        minorVersion: r.uint16,
        defaultVertOriginY: r.int16,
        numVertOriginYMetrics: r.uint16,
        metrics: new r.Array(VerticalOrigin, 'numVertOriginYMetrics')
    });
var BigMetrics = new r.Struct({
        height: r.uint8,
        width: r.uint8,
        horiBearingX: r.int8,
        horiBearingY: r.int8,
        horiAdvance: r.uint8,
        vertBearingX: r.int8,
        vertBearingY: r.int8,
        vertAdvance: r.uint8
    });
var SmallMetrics = new r.Struct({
        height: r.uint8,
        width: r.uint8,
        bearingX: r.int8,
        bearingY: r.int8,
        advance: r.uint8
    });
var EBDTComponent = new r.Struct({
        glyph: r.uint16,
        xOffset: r.int8,
        yOffset: r.int8
    });
var ByteAligned = function ByteAligned() {
    _classCallCheck(this, ByteAligned);
};
var BitAligned = function BitAligned() {
    _classCallCheck(this, BitAligned);
};
var glyph = new r.VersionedStruct('version', {
        1: {
            metrics: SmallMetrics,
            data: ByteAligned
        },
        2: {
            metrics: SmallMetrics,
            data: BitAligned
        },
        5: { data: BitAligned },
        6: {
            metrics: BigMetrics,
            data: ByteAligned
        },
        7: {
            metrics: BigMetrics,
            data: BitAligned
        },
        8: {
            metrics: SmallMetrics,
            pad: new r.Reserved(r.uint8),
            numComponents: r.uint16,
            components: new r.Array(EBDTComponent, 'numComponents')
        },
        9: {
            metrics: BigMetrics,
            pad: new r.Reserved(r.uint8),
            numComponents: r.uint16,
            components: new r.Array(EBDTComponent, 'numComponents')
        },
        17: {
            metrics: SmallMetrics,
            dataLen: r.uint32,
            data: new r.Buffer('dataLen')
        },
        18: {
            metrics: BigMetrics,
            dataLen: r.uint32,
            data: new r.Buffer('dataLen')
        },
        19: {
            dataLen: r.uint32,
            data: new r.Buffer('dataLen')
        }
    });
var SBitLineMetrics = new r.Struct({
        ascender: r.int8,
        descender: r.int8,
        widthMax: r.uint8,
        caretSlopeNumerator: r.int8,
        caretSlopeDenominator: r.int8,
        caretOffset: r.int8,
        minOriginSB: r.int8,
        minAdvanceSB: r.int8,
        maxBeforeBL: r.int8,
        minAfterBL: r.int8,
        pad: new r.Reserved(r.int8, 2)
    });
var CodeOffsetPair = new r.Struct({
        glyphCode: r.uint16,
        offset: r.uint16
    });
var IndexSubtable = new r.VersionedStruct(r.uint16, {
        header: {
            imageFormat: r.uint16,
            imageDataOffset: r.uint32
        },
        1: {
            offsetArray: new r.Array(r.uint32, function (t) {
                return t.parent.lastGlyphIndex - t.parent.firstGlyphIndex + 1;
            })
        },
        2: {
            imageSize: r.uint32,
            bigMetrics: BigMetrics
        },
        3: {
            offsetArray: new r.Array(r.uint16, function (t) {
                return t.parent.lastGlyphIndex - t.parent.firstGlyphIndex + 1;
            })
        },
        4: {
            numGlyphs: r.uint32,
            glyphArray: new r.Array(CodeOffsetPair, function (t) {
                return t.numGlyphs + 1;
            })
        },
        5: {
            imageSize: r.uint32,
            bigMetrics: BigMetrics,
            numGlyphs: r.uint32,
            glyphCodeArray: new r.Array(r.uint16, 'numGlyphs')
        }
    });
var IndexSubtableArray = new r.Struct({
        firstGlyphIndex: r.uint16,
        lastGlyphIndex: r.uint16,
        subtable: new r.Pointer(r.uint32, IndexSubtable)
    });
var BitmapSizeTable = new r.Struct({
        indexSubTableArray: new r.Pointer(r.uint32, new r.Array(IndexSubtableArray, 1), { type: 'parent' }),
        indexTablesSize: r.uint32,
        numberOfIndexSubTables: r.uint32,
        colorRef: r.uint32,
        hori: SBitLineMetrics,
        vert: SBitLineMetrics,
        startGlyphIndex: r.uint16,
        endGlyphIndex: r.uint16,
        ppemX: r.uint8,
        ppemY: r.uint8,
        bitDepth: r.uint8,
        flags: new r.Bitfield(r.uint8, [
            'horizontal',
            'vertical'
        ])
    });
var EBLC = new r.Struct({
        version: r.uint32,
        numSizes: r.uint32,
        sizes: new r.Array(BitmapSizeTable, 'numSizes')
    });
var ImageTable = new r.Struct({
        ppem: r.uint16,
        resolution: r.uint16,
        imageOffsets: new r.Array(new r.Pointer(r.uint32, 'void'), function (t) {
            return t.parent.parent.maxp.numGlyphs + 1;
        })
    });
var sbix = new r.Struct({
        version: r.uint16,
        flags: new r.Bitfield(r.uint16, ['renderOutlines']),
        numImgTables: r.uint32,
        imageTables: new r.Array(new r.Pointer(r.uint32, ImageTable), 'numImgTables')
    });
var LayerRecord = new r.Struct({
        gid: r.uint16,
        paletteIndex: r.uint16
    });
var BaseGlyphRecord = new r.Struct({
        gid: r.uint16,
        firstLayerIndex: r.uint16,
        numLayers: r.uint16
    });
var COLR = new r.Struct({
        version: r.uint16,
        numBaseGlyphRecords: r.uint16,
        baseGlyphRecord: new r.Pointer(r.uint32, new r.Array(BaseGlyphRecord, 'numBaseGlyphRecords')),
        layerRecords: new r.Pointer(r.uint32, new r.Array(LayerRecord, 'numLayerRecords'), { lazy: true }),
        numLayerRecords: r.uint16
    });
var ColorRecord = new r.Struct({
        blue: r.uint8,
        green: r.uint8,
        red: r.uint8,
        alpha: r.uint8
    });
var CPAL = new r.VersionedStruct(r.uint16, {
        header: {
            numPaletteEntries: r.uint16,
            numPalettes: r.uint16,
            numColorRecords: r.uint16,
            colorRecords: new r.Pointer(r.uint32, new r.Array(ColorRecord, 'numColorRecords')),
            colorRecordIndices: new r.Array(r.uint16, 'numPalettes')
        },
        0: {},
        1: {
            offsetPaletteTypeArray: new r.Pointer(r.uint32, new r.Array(r.uint32, 'numPalettes')),
            offsetPaletteLabelArray: new r.Pointer(r.uint32, new r.Array(r.uint16, 'numPalettes')),
            offsetPaletteEntryLabelArray: new r.Pointer(r.uint32, new r.Array(r.uint16, 'numPaletteEntries'))
        }
    });
var BaseCoord = new r.VersionedStruct(r.uint16, {
        1: { coordinate: r.int16 },
        2: {
            coordinate: r.int16,
            referenceGlyph: r.uint16,
            baseCoordPoint: r.uint16
        },
        3: {
            coordinate: r.int16,
            deviceTable: new r.Pointer(r.uint16, Device)
        }
    });
var BaseValues = new r.Struct({
        defaultIndex: r.uint16,
        baseCoordCount: r.uint16,
        baseCoords: new r.Array(new r.Pointer(r.uint16, BaseCoord), 'baseCoordCount')
    });
var FeatMinMaxRecord = new r.Struct({
        tag: new r.String(4),
        minCoord: new r.Pointer(r.uint16, BaseCoord, { type: 'parent' }),
        maxCoord: new r.Pointer(r.uint16, BaseCoord, { type: 'parent' })
    });
var MinMax = new r.Struct({
        minCoord: new r.Pointer(r.uint16, BaseCoord),
        maxCoord: new r.Pointer(r.uint16, BaseCoord),
        featMinMaxCount: r.uint16,
        featMinMaxRecords: new r.Array(FeatMinMaxRecord, 'featMinMaxCount')
    });
var BaseLangSysRecord = new r.Struct({
        tag: new r.String(4),
        minMax: new r.Pointer(r.uint16, MinMax, { type: 'parent' })
    });
var BaseScript = new r.Struct({
        baseValues: new r.Pointer(r.uint16, BaseValues),
        defaultMinMax: new r.Pointer(r.uint16, MinMax),
        baseLangSysCount: r.uint16,
        baseLangSysRecords: new r.Array(BaseLangSysRecord, 'baseLangSysCount')
    });
var BaseScriptRecord = new r.Struct({
        tag: new r.String(4),
        script: new r.Pointer(r.uint16, BaseScript, { type: 'parent' })
    });
var BaseScriptList = new r.Array(BaseScriptRecord, r.uint16);
var BaseTagList = new r.Array(new r.String(4), r.uint16);
var Axis = new r.Struct({
        baseTagList: new r.Pointer(r.uint16, BaseTagList),
        baseScriptList: new r.Pointer(r.uint16, BaseScriptList)
    });
var BASE = new r.VersionedStruct(r.uint32, {
        header: {
            horizAxis: new r.Pointer(r.uint16, Axis),
            vertAxis: new r.Pointer(r.uint16, Axis)
        },
        65536: {},
        65537: { itemVariationStore: new r.Pointer(r.uint32, ItemVariationStore) }
    });
var AttachPoint = new r.Array(r.uint16, r.uint16);
var AttachList = new r.Struct({
        coverage: new r.Pointer(r.uint16, Coverage),
        glyphCount: r.uint16,
        attachPoints: new r.Array(new r.Pointer(r.uint16, AttachPoint), 'glyphCount')
    });
var CaretValue = new r.VersionedStruct(r.uint16, {
        1: { coordinate: r.int16 },
        2: { caretValuePoint: r.uint16 },
        3: {
            coordinate: r.int16,
            deviceTable: new r.Pointer(r.uint16, Device)
        }
    });
var LigGlyph = new r.Array(new r.Pointer(r.uint16, CaretValue), r.uint16);
var LigCaretList = new r.Struct({
        coverage: new r.Pointer(r.uint16, Coverage),
        ligGlyphCount: r.uint16,
        ligGlyphs: new r.Array(new r.Pointer(r.uint16, LigGlyph), 'ligGlyphCount')
    });
var MarkGlyphSetsDef = new r.Struct({
        markSetTableFormat: r.uint16,
        markSetCount: r.uint16,
        coverage: new r.Array(new r.Pointer(r.uint32, Coverage), 'markSetCount')
    });
var GDEF = new r.VersionedStruct(r.uint32, {
        header: {
            glyphClassDef: new r.Pointer(r.uint16, ClassDef),
            attachList: new r.Pointer(r.uint16, AttachList),
            ligCaretList: new r.Pointer(r.uint16, LigCaretList),
            markAttachClassDef: new r.Pointer(r.uint16, ClassDef)
        },
        65536: {},
        65538: { markGlyphSetsDef: new r.Pointer(r.uint16, MarkGlyphSetsDef) },
        65539: {
            markGlyphSetsDef: new r.Pointer(r.uint16, MarkGlyphSetsDef),
            itemVariationStore: new r.Pointer(r.uint32, ItemVariationStore)
        }
    });
var ValueFormat = new r.Bitfield(r.uint16, [
        'xPlacement',
        'yPlacement',
        'xAdvance',
        'yAdvance',
        'xPlaDevice',
        'yPlaDevice',
        'xAdvDevice',
        'yAdvDevice'
    ]);
var types = {
        xPlacement: r.int16,
        yPlacement: r.int16,
        xAdvance: r.int16,
        yAdvance: r.int16,
        xPlaDevice: new r.Pointer(r.uint16, Device, {
            type: 'global',
            relativeTo: 'rel'
        }),
        yPlaDevice: new r.Pointer(r.uint16, Device, {
            type: 'global',
            relativeTo: 'rel'
        }),
        xAdvDevice: new r.Pointer(r.uint16, Device, {
            type: 'global',
            relativeTo: 'rel'
        }),
        yAdvDevice: new r.Pointer(r.uint16, Device, {
            type: 'global',
            relativeTo: 'rel'
        })
    };
var ValueRecord = function () {
        function ValueRecord() {
            var key = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'valueFormat';
            _classCallCheck(this, ValueRecord);
            this.key = key;
        }
        ValueRecord.prototype.buildStruct = function buildStruct(parent) {
            var struct = parent;
            while (!struct[this.key] && struct.parent) {
                struct = struct.parent;
            }
            if (!struct[this.key])
                return;
            var fields = {};
            fields.rel = function () {
                return struct._startOffset;
            };
            var format = struct[this.key];
            for (var key in format) {
                if (format[key]) {
                    fields[key] = types[key];
                }
            }
            return new r.Struct(fields);
        };
        ValueRecord.prototype.size = function size(val, ctx) {
            return this.buildStruct(ctx).size(val, ctx);
        };
        ValueRecord.prototype.decode = function decode(stream, parent) {
            var res = this.buildStruct(parent).decode(stream, parent);
            delete res.rel;
            return res;
        };
        return ValueRecord;
    }();
var PairValueRecord = new r.Struct({
        secondGlyph: r.uint16,
        value1: new ValueRecord('valueFormat1'),
        value2: new ValueRecord('valueFormat2')
    });
var PairSet = new r.Array(PairValueRecord, r.uint16);
var Class2Record = new r.Struct({
        value1: new ValueRecord('valueFormat1'),
        value2: new ValueRecord('valueFormat2')
    });
var Anchor = new r.VersionedStruct(r.uint16, {
        1: {
            xCoordinate: r.int16,
            yCoordinate: r.int16
        },
        2: {
            xCoordinate: r.int16,
            yCoordinate: r.int16,
            anchorPoint: r.uint16
        },
        3: {
            xCoordinate: r.int16,
            yCoordinate: r.int16,
            xDeviceTable: new r.Pointer(r.uint16, Device),
            yDeviceTable: new r.Pointer(r.uint16, Device)
        }
    });
var EntryExitRecord = new r.Struct({
        entryAnchor: new r.Pointer(r.uint16, Anchor, { type: 'parent' }),
        exitAnchor: new r.Pointer(r.uint16, Anchor, { type: 'parent' })
    });
var MarkRecord = new r.Struct({
        class: r.uint16,
        markAnchor: new r.Pointer(r.uint16, Anchor, { type: 'parent' })
    });
var MarkArray = new r.Array(MarkRecord, r.uint16);
var BaseRecord = new r.Array(new r.Pointer(r.uint16, Anchor), function (t) {
        return t.parent.classCount;
    });
var BaseArray = new r.Array(BaseRecord, r.uint16);
var ComponentRecord = new r.Array(new r.Pointer(r.uint16, Anchor), function (t) {
        return t.parent.parent.classCount;
    });
var LigatureAttach = new r.Array(ComponentRecord, r.uint16);
var LigatureArray = new r.Array(new r.Pointer(r.uint16, LigatureAttach), r.uint16);
var GPOSLookup = new r.VersionedStruct('lookupType', {
        1: new r.VersionedStruct(r.uint16, {
            1: {
                coverage: new r.Pointer(r.uint16, Coverage),
                valueFormat: ValueFormat,
                value: new ValueRecord()
            },
            2: {
                coverage: new r.Pointer(r.uint16, Coverage),
                valueFormat: ValueFormat,
                valueCount: r.uint16,
                values: new r.LazyArray(new ValueRecord(), 'valueCount')
            }
        }),
        2: new r.VersionedStruct(r.uint16, {
            1: {
                coverage: new r.Pointer(r.uint16, Coverage),
                valueFormat1: ValueFormat,
                valueFormat2: ValueFormat,
                pairSetCount: r.uint16,
                pairSets: new r.LazyArray(new r.Pointer(r.uint16, PairSet), 'pairSetCount')
            },
            2: {
                coverage: new r.Pointer(r.uint16, Coverage),
                valueFormat1: ValueFormat,
                valueFormat2: ValueFormat,
                classDef1: new r.Pointer(r.uint16, ClassDef),
                classDef2: new r.Pointer(r.uint16, ClassDef),
                class1Count: r.uint16,
                class2Count: r.uint16,
                classRecords: new r.LazyArray(new r.LazyArray(Class2Record, 'class2Count'), 'class1Count')
            }
        }),
        3: {
            format: r.uint16,
            coverage: new r.Pointer(r.uint16, Coverage),
            entryExitCount: r.uint16,
            entryExitRecords: new r.Array(EntryExitRecord, 'entryExitCount')
        },
        4: {
            format: r.uint16,
            markCoverage: new r.Pointer(r.uint16, Coverage),
            baseCoverage: new r.Pointer(r.uint16, Coverage),
            classCount: r.uint16,
            markArray: new r.Pointer(r.uint16, MarkArray),
            baseArray: new r.Pointer(r.uint16, BaseArray)
        },
        5: {
            format: r.uint16,
            markCoverage: new r.Pointer(r.uint16, Coverage),
            ligatureCoverage: new r.Pointer(r.uint16, Coverage),
            classCount: r.uint16,
            markArray: new r.Pointer(r.uint16, MarkArray),
            ligatureArray: new r.Pointer(r.uint16, LigatureArray)
        },
        6: {
            format: r.uint16,
            mark1Coverage: new r.Pointer(r.uint16, Coverage),
            mark2Coverage: new r.Pointer(r.uint16, Coverage),
            classCount: r.uint16,
            mark1Array: new r.Pointer(r.uint16, MarkArray),
            mark2Array: new r.Pointer(r.uint16, BaseArray)
        },
        7: Context,
        8: ChainingContext,
        9: {
            posFormat: r.uint16,
            lookupType: r.uint16,
            extension: new r.Pointer(r.uint32, GPOSLookup)
        }
    });
GPOSLookup.versions[9].extension.type = GPOSLookup;
var GPOS = new r.VersionedStruct(r.uint32, {
        header: {
            scriptList: new r.Pointer(r.uint16, ScriptList),
            featureList: new r.Pointer(r.uint16, FeatureList),
            lookupList: new r.Pointer(r.uint16, new LookupList(GPOSLookup))
        },
        65536: {},
        65537: { featureVariations: new r.Pointer(r.uint32, FeatureVariations) }
    });
var Sequence = new r.Array(r.uint16, r.uint16);
var AlternateSet = Sequence;
var Ligature = new r.Struct({
        glyph: r.uint16,
        compCount: r.uint16,
        components: new r.Array(r.uint16, function (t) {
            return t.compCount - 1;
        })
    });
var LigatureSet = new r.Array(new r.Pointer(r.uint16, Ligature), r.uint16);
var GSUBLookup = new r.VersionedStruct('lookupType', {
        1: new r.VersionedStruct(r.uint16, {
            1: {
                coverage: new r.Pointer(r.uint16, Coverage),
                deltaGlyphID: r.int16
            },
            2: {
                coverage: new r.Pointer(r.uint16, Coverage),
                glyphCount: r.uint16,
                substitute: new r.LazyArray(r.uint16, 'glyphCount')
            }
        }),
        2: {
            substFormat: r.uint16,
            coverage: new r.Pointer(r.uint16, Coverage),
            count: r.uint16,
            sequences: new r.LazyArray(new r.Pointer(r.uint16, Sequence), 'count')
        },
        3: {
            substFormat: r.uint16,
            coverage: new r.Pointer(r.uint16, Coverage),
            count: r.uint16,
            alternateSet: new r.LazyArray(new r.Pointer(r.uint16, AlternateSet), 'count')
        },
        4: {
            substFormat: r.uint16,
            coverage: new r.Pointer(r.uint16, Coverage),
            count: r.uint16,
            ligatureSets: new r.LazyArray(new r.Pointer(r.uint16, LigatureSet), 'count')
        },
        5: Context,
        6: ChainingContext,
        7: {
            substFormat: r.uint16,
            lookupType: r.uint16,
            extension: new r.Pointer(r.uint32, GSUBLookup)
        },
        8: {
            substFormat: r.uint16,
            coverage: new r.Pointer(r.uint16, Coverage),
            backtrackCoverage: new r.Array(new r.Pointer(r.uint16, Coverage), 'backtrackGlyphCount'),
            lookaheadGlyphCount: r.uint16,
            lookaheadCoverage: new r.Array(new r.Pointer(r.uint16, Coverage), 'lookaheadGlyphCount'),
            glyphCount: r.uint16,
            substitutes: new r.Array(r.uint16, 'glyphCount')
        }
    });
GSUBLookup.versions[7].extension.type = GSUBLookup;
var GSUB = new r.VersionedStruct(r.uint32, {
        header: {
            scriptList: new r.Pointer(r.uint16, ScriptList),
            featureList: new r.Pointer(r.uint16, FeatureList),
            lookupList: new r.Pointer(r.uint16, new LookupList(GSUBLookup))
        },
        65536: {},
        65537: { featureVariations: new r.Pointer(r.uint32, FeatureVariations) }
    });
var JstfGSUBModList = new r.Array(r.uint16, r.uint16);
var JstfPriority = new r.Struct({
        shrinkageEnableGSUB: new r.Pointer(r.uint16, JstfGSUBModList),
        shrinkageDisableGSUB: new r.Pointer(r.uint16, JstfGSUBModList),
        shrinkageEnableGPOS: new r.Pointer(r.uint16, JstfGSUBModList),
        shrinkageDisableGPOS: new r.Pointer(r.uint16, JstfGSUBModList),
        shrinkageJstfMax: new r.Pointer(r.uint16, new LookupList(GPOSLookup)),
        extensionEnableGSUB: new r.Pointer(r.uint16, JstfGSUBModList),
        extensionDisableGSUB: new r.Pointer(r.uint16, JstfGSUBModList),
        extensionEnableGPOS: new r.Pointer(r.uint16, JstfGSUBModList),
        extensionDisableGPOS: new r.Pointer(r.uint16, JstfGSUBModList),
        extensionJstfMax: new r.Pointer(r.uint16, new LookupList(GPOSLookup))
    });
var JstfLangSys = new r.Array(new r.Pointer(r.uint16, JstfPriority), r.uint16);
var JstfLangSysRecord = new r.Struct({
        tag: new r.String(4),
        jstfLangSys: new r.Pointer(r.uint16, JstfLangSys)
    });
var JstfScript = new r.Struct({
        extenderGlyphs: new r.Pointer(r.uint16, new r.Array(r.uint16, r.uint16)),
        defaultLangSys: new r.Pointer(r.uint16, JstfLangSys),
        langSysCount: r.uint16,
        langSysRecords: new r.Array(JstfLangSysRecord, 'langSysCount')
    });
var JstfScriptRecord = new r.Struct({
        tag: new r.String(4),
        script: new r.Pointer(r.uint16, JstfScript, { type: 'parent' })
    });
var JSTF = new r.Struct({
        version: r.uint32,
        scriptCount: r.uint16,
        scriptList: new r.Array(JstfScriptRecord, 'scriptCount')
    });
var VariableSizeNumber = function () {
        function VariableSizeNumber(size) {
            _classCallCheck(this, VariableSizeNumber);
            this._size = size;
        }
        VariableSizeNumber.prototype.decode = function decode(stream, parent) {
            switch (this.size(0, parent)) {
            case 1:
                return stream.readUInt8();
            case 2:
                return stream.readUInt16BE();
            case 3:
                return stream.readUInt24BE();
            case 4:
                return stream.readUInt32BE();
            }
        };
        VariableSizeNumber.prototype.size = function size(val, parent) {
            return restructure_src_utils.resolveLength(this._size, null, parent);
        };
        return VariableSizeNumber;
    }();
var MapDataEntry = new r.Struct({
        entry: new VariableSizeNumber(function (t) {
            return ((t.parent.entryFormat & 48) >> 4) + 1;
        }),
        outerIndex: function outerIndex(t) {
            return t.entry >> (t.parent.entryFormat & 15) + 1;
        },
        innerIndex: function innerIndex(t) {
            return t.entry & (1 << (t.parent.entryFormat & 15) + 1) - 1;
        }
    });
var DeltaSetIndexMap = new r.Struct({
        entryFormat: r.uint16,
        mapCount: r.uint16,
        mapData: new r.Array(MapDataEntry, 'mapCount')
    });
var HVAR = new r.Struct({
        majorVersion: r.uint16,
        minorVersion: r.uint16,
        itemVariationStore: new r.Pointer(r.uint32, ItemVariationStore),
        advanceWidthMapping: new r.Pointer(r.uint32, DeltaSetIndexMap),
        LSBMapping: new r.Pointer(r.uint32, DeltaSetIndexMap),
        RSBMapping: new r.Pointer(r.uint32, DeltaSetIndexMap)
    });
var Signature = new r.Struct({
        format: r.uint32,
        length: r.uint32,
        offset: r.uint32
    });
var SignatureBlock = new r.Struct({
        reserved: new r.Reserved(r.uint16, 2),
        cbSignature: r.uint32,
        signature: new r.Buffer('cbSignature')
    });
var DSIG = new r.Struct({
        ulVersion: r.uint32,
        usNumSigs: r.uint16,
        usFlag: r.uint16,
        signatures: new r.Array(Signature, 'usNumSigs'),
        signatureBlocks: new r.Array(SignatureBlock, 'usNumSigs')
    });
var GaspRange = new r.Struct({
        rangeMaxPPEM: r.uint16,
        rangeGaspBehavior: new r.Bitfield(r.uint16, [
            'grayscale',
            'gridfit',
            'symmetricSmoothing',
            'symmetricGridfit'
        ])
    });
var gasp = new r.Struct({
        version: r.uint16,
        numRanges: r.uint16,
        gaspRanges: new r.Array(GaspRange, 'numRanges')
    });
var DeviceRecord = new r.Struct({
        pixelSize: r.uint8,
        maximumWidth: r.uint8,
        widths: new r.Array(r.uint8, function (t) {
            return t.parent.parent.maxp.numGlyphs;
        })
    });
var hdmx = new r.Struct({
        version: r.uint16,
        numRecords: r.int16,
        sizeDeviceRecord: r.int32,
        records: new r.Array(DeviceRecord, 'numRecords')
    });
var KernPair = new r.Struct({
        left: r.uint16,
        right: r.uint16,
        value: r.int16
    });
var ClassTable = new r.Struct({
        firstGlyph: r.uint16,
        nGlyphs: r.uint16,
        offsets: new r.Array(r.uint16, 'nGlyphs'),
        max: function max(t) {
            return t.offsets.length && Math.max.apply(Math, t.offsets);
        }
    });
var Kern2Array = new r.Struct({
        off: function off(t) {
            return t._startOffset - t.parent.parent._startOffset;
        },
        len: function len(t) {
            return ((t.parent.leftTable.max - t.off) / t.parent.rowWidth + 1) * (t.parent.rowWidth / 2);
        },
        values: new r.LazyArray(r.int16, 'len')
    });
var KernSubtable = new r.VersionedStruct('format', {
        0: {
            nPairs: r.uint16,
            searchRange: r.uint16,
            entrySelector: r.uint16,
            rangeShift: r.uint16,
            pairs: new r.Array(KernPair, 'nPairs')
        },
        2: {
            rowWidth: r.uint16,
            leftTable: new r.Pointer(r.uint16, ClassTable, { type: 'parent' }),
            rightTable: new r.Pointer(r.uint16, ClassTable, { type: 'parent' }),
            array: new r.Pointer(r.uint16, Kern2Array, { type: 'parent' })
        },
        3: {
            glyphCount: r.uint16,
            kernValueCount: r.uint8,
            leftClassCount: r.uint8,
            rightClassCount: r.uint8,
            flags: r.uint8,
            kernValue: new r.Array(r.int16, 'kernValueCount'),
            leftClass: new r.Array(r.uint8, 'glyphCount'),
            rightClass: new r.Array(r.uint8, 'glyphCount'),
            kernIndex: new r.Array(r.uint8, function (t) {
                return t.leftClassCount * t.rightClassCount;
            })
        }
    });
var KernTable = new r.VersionedStruct('version', {
        0: {
            subVersion: r.uint16,
            length: r.uint16,
            format: r.uint8,
            coverage: new r.Bitfield(r.uint8, [
                'horizontal',
                'minimum',
                'crossStream',
                'override'
            ]),
            subtable: KernSubtable,
            padding: new r.Reserved(r.uint8, function (t) {
                return t.length - t._currentOffset;
            })
        },
        1: {
            length: r.uint32,
            coverage: new r.Bitfield(r.uint8, [
                null,
                null,
                null,
                null,
                null,
                'variation',
                'crossStream',
                'vertical'
            ]),
            format: r.uint8,
            tupleIndex: r.uint16,
            subtable: KernSubtable,
            padding: new r.Reserved(r.uint8, function (t) {
                return t.length - t._currentOffset;
            })
        }
    });
var kern = new r.VersionedStruct(r.uint16, {
        0: {
            nTables: r.uint16,
            tables: new r.Array(KernTable, 'nTables')
        },
        1: {
            reserved: new r.Reserved(r.uint16),
            nTables: r.uint32,
            tables: new r.Array(KernTable, 'nTables')
        }
    });
var LTSH = new r.Struct({
        version: r.uint16,
        numGlyphs: r.uint16,
        yPels: new r.Array(r.uint8, 'numGlyphs')
    });
var PCLT = new r.Struct({
        version: r.uint16,
        fontNumber: r.uint32,
        pitch: r.uint16,
        xHeight: r.uint16,
        style: r.uint16,
        typeFamily: r.uint16,
        capHeight: r.uint16,
        symbolSet: r.uint16,
        typeface: new r.String(16),
        characterComplement: new r.String(8),
        fileName: new r.String(6),
        strokeWeight: new r.String(1),
        widthType: new r.String(1),
        serifStyle: r.uint8,
        reserved: new r.Reserved(r.uint8)
    });
var Ratio = new r.Struct({
        bCharSet: r.uint8,
        xRatio: r.uint8,
        yStartRatio: r.uint8,
        yEndRatio: r.uint8
    });
var vTable = new r.Struct({
        yPelHeight: r.uint16,
        yMax: r.int16,
        yMin: r.int16
    });
var VdmxGroup = new r.Struct({
        recs: r.uint16,
        startsz: r.uint8,
        endsz: r.uint8,
        entries: new r.Array(vTable, 'recs')
    });
var VDMX = new r.Struct({
        version: r.uint16,
        numRecs: r.uint16,
        numRatios: r.uint16,
        ratioRanges: new r.Array(Ratio, 'numRatios'),
        offsets: new r.Array(r.uint16, 'numRatios'),
        groups: new r.Array(VdmxGroup, 'numRecs')
    });
var vhea = new r.Struct({
        version: r.uint16,
        ascent: r.int16,
        descent: r.int16,
        lineGap: r.int16,
        advanceHeightMax: r.int16,
        minTopSideBearing: r.int16,
        minBottomSideBearing: r.int16,
        yMaxExtent: r.int16,
        caretSlopeRise: r.int16,
        caretSlopeRun: r.int16,
        caretOffset: r.int16,
        reserved: new r.Reserved(r.int16, 4),
        metricDataFormat: r.int16,
        numberOfMetrics: r.uint16
    });
var VmtxEntry = new r.Struct({
        advance: r.uint16,
        bearing: r.int16
    });
var vmtx = new r.Struct({
        metrics: new r.LazyArray(VmtxEntry, function (t) {
            return t.parent.vhea.numberOfMetrics;
        }),
        bearings: new r.LazyArray(r.int16, function (t) {
            return t.parent.maxp.numGlyphs - t.parent.vhea.numberOfMetrics;
        })
    });
var shortFrac = new r.Fixed(16, 'BE', 14);
var Correspondence = new r.Struct({
        fromCoord: shortFrac,
        toCoord: shortFrac
    });
var Segment = new r.Struct({
        pairCount: r.uint16,
        correspondence: new r.Array(Correspondence, 'pairCount')
    });
var avar = new r.Struct({
        version: r.fixed32,
        axisCount: r.uint32,
        segment: new r.Array(Segment, 'axisCount')
    });
var UnboundedArrayAccessor = function () {
        function UnboundedArrayAccessor(type, stream, parent) {
            _classCallCheck(this, UnboundedArrayAccessor);
            this.type = type;
            this.stream = stream;
            this.parent = parent;
            this.base = this.stream.pos;
            this._items = [];
        }
        UnboundedArrayAccessor.prototype.getItem = function getItem(index) {
            if (this._items[index] == null) {
                var pos = this.stream.pos;
                this.stream.pos = this.base + this.type.size(null, this.parent) * index;
                this._items[index] = this.type.decode(this.stream, this.parent);
                this.stream.pos = pos;
            }
            return this._items[index];
        };
        UnboundedArrayAccessor.prototype.inspect = function inspect() {
            return '[UnboundedArray ' + this.type.constructor.name + ']';
        };
        return UnboundedArrayAccessor;
    }();
var UnboundedArray = function (_r$Array) {
        _inherits(UnboundedArray, _r$Array);
        function UnboundedArray(type) {
            _classCallCheck(this, UnboundedArray);
            return _possibleConstructorReturn(this, _r$Array.call(this, type, 0));
        }
        UnboundedArray.prototype.decode = function decode(stream, parent) {
            return new UnboundedArrayAccessor(this.type, stream, parent);
        };
        return UnboundedArray;
    }(r.Array);
var LookupTable = function LookupTable() {
    var ValueType = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : r.uint16;
    var Shadow = function () {
            function Shadow(type) {
                _classCallCheck(this, Shadow);
                this.type = type;
            }
            Shadow.prototype.decode = function decode(stream, ctx) {
                ctx = ctx.parent.parent;
                return this.type.decode(stream, ctx);
            };
            Shadow.prototype.size = function size(val, ctx) {
                ctx = ctx.parent.parent;
                return this.type.size(val, ctx);
            };
            Shadow.prototype.encode = function encode(stream, val, ctx) {
                ctx = ctx.parent.parent;
                return this.type.encode(stream, val, ctx);
            };
            return Shadow;
        }();
    ValueType = new Shadow(ValueType);
    var BinarySearchHeader = new r.Struct({
            unitSize: r.uint16,
            nUnits: r.uint16,
            searchRange: r.uint16,
            entrySelector: r.uint16,
            rangeShift: r.uint16
        });
    var LookupSegmentSingle = new r.Struct({
            lastGlyph: r.uint16,
            firstGlyph: r.uint16,
            value: ValueType
        });
    var LookupSegmentArray = new r.Struct({
            lastGlyph: r.uint16,
            firstGlyph: r.uint16,
            values: new r.Pointer(r.uint16, new r.Array(ValueType, function (t) {
                return t.lastGlyph - t.firstGlyph + 1;
            }), { type: 'parent' })
        });
    var LookupSingle = new r.Struct({
            glyph: r.uint16,
            value: ValueType
        });
    return new r.VersionedStruct(r.uint16, {
        0: { values: new UnboundedArray(ValueType) },
        2: {
            binarySearchHeader: BinarySearchHeader,
            segments: new r.Array(LookupSegmentSingle, function (t) {
                return t.binarySearchHeader.nUnits;
            })
        },
        4: {
            binarySearchHeader: BinarySearchHeader,
            segments: new r.Array(LookupSegmentArray, function (t) {
                return t.binarySearchHeader.nUnits;
            })
        },
        6: {
            binarySearchHeader: BinarySearchHeader,
            segments: new r.Array(LookupSingle, function (t) {
                return t.binarySearchHeader.nUnits;
            })
        },
        8: {
            firstGlyph: r.uint16,
            count: r.uint16,
            values: new r.Array(ValueType, 'count')
        }
    });
};
function StateTable() {
    var entryData = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var lookupType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : r.uint16;
    var entry = _Object$assign({
            newState: r.uint16,
            flags: r.uint16
        }, entryData);
    var Entry = new r.Struct(entry);
    var StateArray = new UnboundedArray(new r.Array(r.uint16, function (t) {
            return t.nClasses;
        }));
    var StateHeader = new r.Struct({
            nClasses: r.uint32,
            classTable: new r.Pointer(r.uint32, new LookupTable(lookupType)),
            stateArray: new r.Pointer(r.uint32, StateArray),
            entryTable: new r.Pointer(r.uint32, new UnboundedArray(Entry))
        });
    return StateHeader;
}
function StateTable1() {
    var entryData = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var lookupType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : r.uint16;
    var ClassLookupTable = new r.Struct({
            version: function version() {
                return 8;
            },
            firstGlyph: r.uint16,
            values: new r.Array(r.uint8, r.uint16)
        });
    var entry = _Object$assign({
            newStateOffset: r.uint16,
            newState: function newState(t) {
                return (t.newStateOffset - (t.parent.stateArray.base - t.parent._startOffset)) / t.parent.nClasses;
            },
            flags: r.uint16
        }, entryData);
    var Entry = new r.Struct(entry);
    var StateArray = new UnboundedArray(new r.Array(r.uint8, function (t) {
            return t.nClasses;
        }));
    var StateHeader1 = new r.Struct({
            nClasses: r.uint16,
            classTable: new r.Pointer(r.uint16, ClassLookupTable),
            stateArray: new r.Pointer(r.uint16, StateArray),
            entryTable: new r.Pointer(r.uint16, new UnboundedArray(Entry))
        });
    return StateHeader1;
}
var BslnSubtable = new r.VersionedStruct('format', {
        0: { deltas: new r.Array(r.int16, 32) },
        1: {
            deltas: new r.Array(r.int16, 32),
            mappingData: new LookupTable(r.uint16)
        },
        2: {
            standardGlyph: r.uint16,
            controlPoints: new r.Array(r.uint16, 32)
        },
        3: {
            standardGlyph: r.uint16,
            controlPoints: new r.Array(r.uint16, 32),
            mappingData: new LookupTable(r.uint16)
        }
    });
var bsln = new r.Struct({
        version: r.fixed32,
        format: r.uint16,
        defaultBaseline: r.uint16,
        subtable: BslnSubtable
    });
var Setting = new r.Struct({
        setting: r.uint16,
        nameIndex: r.int16,
        name: function name(t) {
            return t.parent.parent.parent.name.records.fontFeatures[t.nameIndex];
        }
    });
var FeatureName = new r.Struct({
        feature: r.uint16,
        nSettings: r.uint16,
        settingTable: new r.Pointer(r.uint32, new r.Array(Setting, 'nSettings'), { type: 'parent' }),
        featureFlags: new r.Bitfield(r.uint8, [
            null,
            null,
            null,
            null,
            null,
            null,
            'hasDefault',
            'exclusive'
        ]),
        defaultSetting: r.uint8,
        nameIndex: r.int16,
        name: function name(t) {
            return t.parent.parent.name.records.fontFeatures[t.nameIndex];
        }
    });
var feat = new r.Struct({
        version: r.fixed32,
        featureNameCount: r.uint16,
        reserved1: new r.Reserved(r.uint16),
        reserved2: new r.Reserved(r.uint32),
        featureNames: new r.Array(FeatureName, 'featureNameCount')
    });
var Axis$1 = new r.Struct({
        axisTag: new r.String(4),
        minValue: r.fixed32,
        defaultValue: r.fixed32,
        maxValue: r.fixed32,
        flags: r.uint16,
        nameID: r.uint16,
        name: function name(t) {
            return t.parent.parent.name.records.fontFeatures[t.nameID];
        }
    });
var Instance = new r.Struct({
        nameID: r.uint16,
        name: function name(t) {
            return t.parent.parent.name.records.fontFeatures[t.nameID];
        },
        flags: r.uint16,
        coord: new r.Array(r.fixed32, function (t) {
            return t.parent.axisCount;
        }),
        postscriptNameID: new r.Optional(r.uint16, function (t) {
            return t.parent.instanceSize - t._currentOffset > 0;
        })
    });
var fvar = new r.Struct({
        version: r.fixed32,
        offsetToData: r.uint16,
        countSizePairs: r.uint16,
        axisCount: r.uint16,
        axisSize: r.uint16,
        instanceCount: r.uint16,
        instanceSize: r.uint16,
        axis: new r.Array(Axis$1, 'axisCount'),
        instance: new r.Array(Instance, 'instanceCount')
    });
var shortFrac$1 = new r.Fixed(16, 'BE', 14);
var Offset = function () {
        function Offset() {
            _classCallCheck(this, Offset);
        }
        Offset.decode = function decode(stream, parent) {
            return parent.flags ? stream.readUInt32BE() : stream.readUInt16BE() * 2;
        };
        return Offset;
    }();
var gvar = new r.Struct({
        version: r.uint16,
        reserved: new r.Reserved(r.uint16),
        axisCount: r.uint16,
        globalCoordCount: r.uint16,
        globalCoords: new r.Pointer(r.uint32, new r.Array(new r.Array(shortFrac$1, 'axisCount'), 'globalCoordCount')),
        glyphCount: r.uint16,
        flags: r.uint16,
        offsetToData: r.uint32,
        offsets: new r.Array(new r.Pointer(Offset, 'void', {
            relativeTo: 'offsetToData',
            allowNull: false
        }), function (t) {
            return t.glyphCount + 1;
        })
    });
var ClassTable$1 = new r.Struct({
        length: r.uint16,
        coverage: r.uint16,
        subFeatureFlags: r.uint32,
        stateTable: new StateTable1()
    });
var WidthDeltaRecord = new r.Struct({
        justClass: r.uint32,
        beforeGrowLimit: r.fixed32,
        beforeShrinkLimit: r.fixed32,
        afterGrowLimit: r.fixed32,
        afterShrinkLimit: r.fixed32,
        growFlags: r.uint16,
        shrinkFlags: r.uint16
    });
var WidthDeltaCluster = new r.Array(WidthDeltaRecord, r.uint32);
var ActionData = new r.VersionedStruct('actionType', {
        0: {
            lowerLimit: r.fixed32,
            upperLimit: r.fixed32,
            order: r.uint16,
            glyphs: new r.Array(r.uint16, r.uint16)
        },
        1: { addGlyph: r.uint16 },
        2: {
            substThreshold: r.fixed32,
            addGlyph: r.uint16,
            substGlyph: r.uint16
        },
        3: {},
        4: {
            variationAxis: r.uint32,
            minimumLimit: r.fixed32,
            noStretchValue: r.fixed32,
            maximumLimit: r.fixed32
        },
        5: {
            flags: r.uint16,
            glyph: r.uint16
        }
    });
var Action = new r.Struct({
        actionClass: r.uint16,
        actionType: r.uint16,
        actionLength: r.uint32,
        actionData: ActionData,
        padding: new r.Reserved(r.uint8, function (t) {
            return t.actionLength - t._currentOffset;
        })
    });
var PostcompensationAction = new r.Array(Action, r.uint32);
var PostCompensationTable = new r.Struct({ lookupTable: new LookupTable(new r.Pointer(r.uint16, PostcompensationAction)) });
var JustificationTable = new r.Struct({
        classTable: new r.Pointer(r.uint16, ClassTable$1, { type: 'parent' }),
        wdcOffset: r.uint16,
        postCompensationTable: new r.Pointer(r.uint16, PostCompensationTable, { type: 'parent' }),
        widthDeltaClusters: new LookupTable(new r.Pointer(r.uint16, WidthDeltaCluster, {
            type: 'parent',
            relativeTo: 'wdcOffset'
        }))
    });
var just = new r.Struct({
        version: r.uint32,
        format: r.uint16,
        horizontal: new r.Pointer(r.uint16, JustificationTable),
        vertical: new r.Pointer(r.uint16, JustificationTable)
    });
var LigatureData = { action: r.uint16 };
var ContextualData = {
        markIndex: r.uint16,
        currentIndex: r.uint16
    };
var InsertionData = {
        currentInsertIndex: r.uint16,
        markedInsertIndex: r.uint16
    };
var SubstitutionTable = new r.Struct({ items: new UnboundedArray(new r.Pointer(r.uint32, new LookupTable())) });
var SubtableData = new r.VersionedStruct('type', {
        0: { stateTable: new StateTable() },
        1: {
            stateTable: new StateTable(ContextualData),
            substitutionTable: new r.Pointer(r.uint32, SubstitutionTable)
        },
        2: {
            stateTable: new StateTable(LigatureData),
            ligatureActions: new r.Pointer(r.uint32, new UnboundedArray(r.uint32)),
            components: new r.Pointer(r.uint32, new UnboundedArray(r.uint16)),
            ligatureList: new r.Pointer(r.uint32, new UnboundedArray(r.uint16))
        },
        4: { lookupTable: new LookupTable() },
        5: {
            stateTable: new StateTable(InsertionData),
            insertionActions: new r.Pointer(r.uint32, new UnboundedArray(r.uint16))
        }
    });
var Subtable = new r.Struct({
        length: r.uint32,
        coverage: r.uint24,
        type: r.uint8,
        subFeatureFlags: r.uint32,
        table: SubtableData,
        padding: new r.Reserved(r.uint8, function (t) {
            return t.length - t._currentOffset;
        })
    });
var FeatureEntry = new r.Struct({
        featureType: r.uint16,
        featureSetting: r.uint16,
        enableFlags: r.uint32,
        disableFlags: r.uint32
    });
var MorxChain = new r.Struct({
        defaultFlags: r.uint32,
        chainLength: r.uint32,
        nFeatureEntries: r.uint32,
        nSubtables: r.uint32,
        features: new r.Array(FeatureEntry, 'nFeatureEntries'),
        subtables: new r.Array(Subtable, 'nSubtables')
    });
var morx = new r.Struct({
        version: r.uint16,
        unused: new r.Reserved(r.uint16),
        nChains: r.uint32,
        chains: new r.Array(MorxChain, 'nChains')
    });
var OpticalBounds = new r.Struct({
        left: r.int16,
        top: r.int16,
        right: r.int16,
        bottom: r.int16
    });
var opbd = new r.Struct({
        version: r.fixed32,
        format: r.uint16,
        lookupTable: new LookupTable(OpticalBounds)
    });
var tables = {};
tables.cmap = cmap;
tables.head = head;
tables.hhea = hhea;
tables.hmtx = hmtx;
tables.maxp = maxp;
tables.name = NameTable;
tables['OS/2'] = OS2;
tables.post = post;
tables.fpgm = fpgm;
tables.loca = loca;
tables.prep = prep;
tables['cvt '] = cvt;
tables.glyf = glyf;
tables['CFF '] = CFFFont;
tables['CFF2'] = CFFFont;
tables.VORG = VORG;
tables.EBLC = EBLC;
tables.CBLC = tables.EBLC;
tables.sbix = sbix;
tables.COLR = COLR;
tables.CPAL = CPAL;
tables.BASE = BASE;
tables.GDEF = GDEF;
tables.GPOS = GPOS;
tables.GSUB = GSUB;
tables.JSTF = JSTF;
tables.HVAR = HVAR;
tables.DSIG = DSIG;
tables.gasp = gasp;
tables.hdmx = hdmx;
tables.kern = kern;
tables.LTSH = LTSH;
tables.PCLT = PCLT;
tables.VDMX = VDMX;
tables.vhea = vhea;
tables.vmtx = vmtx;
tables.avar = avar;
tables.bsln = bsln;
tables.feat = feat;
tables.fvar = fvar;
tables.gvar = gvar;
tables.just = just;
tables.morx = morx;
tables.opbd = opbd;
var TableEntry = new r.Struct({
        tag: new r.String(4),
        checkSum: r.uint32,
        offset: new r.Pointer(r.uint32, 'void', { type: 'global' }),
        length: r.uint32
    });
var Directory = new r.Struct({
        tag: new r.String(4),
        numTables: r.uint16,
        searchRange: r.uint16,
        entrySelector: r.uint16,
        rangeShift: r.uint16,
        tables: new r.Array(TableEntry, 'numTables')
    });
Directory.process = function () {
    var tables = {};
    for (var _iterator = this.tables, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _getIterator(_iterator);;) {
        var _ref;
        if (_isArray) {
            if (_i >= _iterator.length)
                break;
            _ref = _iterator[_i++];
        } else {
            _i = _iterator.next();
            if (_i.done)
                break;
            _ref = _i.value;
        }
        var table = _ref;
        tables[table.tag] = table;
    }
    this.tables = tables;
};
Directory.preEncode = function (stream) {
    var tables$$ = [];
    for (var tag in this.tables) {
        var table = this.tables[tag];
        if (table) {
            tables$$.push({
                tag: tag,
                checkSum: 0,
                offset: new r.VoidPointer(tables[tag], table),
                length: tables[tag].size(table)
            });
        }
    }
    this.tag = 'true';
    this.numTables = tables$$.length;
    this.tables = tables$$;
    var maxExponentFor2 = Math.floor(Math.log(this.numTables) / Math.LN2);
    var maxPowerOf2 = Math.pow(2, maxExponentFor2);
    this.searchRange = maxPowerOf2 * 16;
    this.entrySelector = Math.log(maxPowerOf2) / Math.LN2;
    this.rangeShift = this.numTables * 16 - this.searchRange;
};
function binarySearch(arr, cmp) {
    var min = 0;
    var max = arr.length - 1;
    while (min <= max) {
        var mid = min + max >> 1;
        var res = cmp(arr[mid]);
        if (res < 0) {
            max = mid - 1;
        } else if (res > 0) {
            min = mid + 1;
        } else {
            return mid;
        }
    }
    return -1;
}
function range(index, end) {
    var range = [];
    while (index < end) {
        range.push(index++);
    }
    return range;
}
var _class$1;
function _applyDecoratedDescriptor$1(target, property, decorators, descriptor, context) {
    var desc = {};
    Object['ke' + 'ys'](descriptor).forEach(function (key) {
        desc[key] = descriptor[key];
    });
    desc.enumerable = !!desc.enumerable;
    desc.configurable = !!desc.configurable;
    if ('value' in desc || desc.initializer) {
        desc.writable = true;
    }
    desc = decorators.slice().reverse().reduce(function (desc, decorator) {
        return decorator(target, property, desc) || desc;
    }, desc);
    if (context && desc.initializer !== void 0) {
        desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
        desc.initializer = undefined;
    }
    if (desc.initializer === void 0) {
        Object['define' + 'Property'](target, property, desc);
        desc = null;
    }
    return desc;
}
try {
    var iconv = function () {
            throw new Error('Cannot find module \'iconv-lite\' from \'/Users/roel/work/recursive/extension/node_modules/fontkit\'');
        }();
} catch (err) {
}
var CmapProcessor = (_class$1 = function () {
        function CmapProcessor(cmapTable) {
            _classCallCheck(this, CmapProcessor);
            this.encoding = null;
            this.cmap = this.findSubtable(cmapTable, [
                [
                    3,
                    10
                ],
                [
                    0,
                    6
                ],
                [
                    0,
                    4
                ],
                [
                    3,
                    1
                ],
                [
                    0,
                    3
                ],
                [
                    0,
                    2
                ],
                [
                    0,
                    1
                ],
                [
                    0,
                    0
                ]
            ]);
            if (!this.cmap && iconv) {
                for (var _iterator = cmapTable.tables, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _getIterator(_iterator);;) {
                    var _ref;
                    if (_isArray) {
                        if (_i >= _iterator.length)
                            break;
                        _ref = _iterator[_i++];
                    } else {
                        _i = _iterator.next();
                        if (_i.done)
                            break;
                        _ref = _i.value;
                    }
                    var cmap = _ref;
                    var encoding = getEncoding(cmap.platformID, cmap.encodingID, cmap.table.language - 1);
                    if (iconv.encodingExists(encoding)) {
                        this.cmap = cmap.table;
                        this.encoding = encoding;
                    }
                }
            }
            if (!this.cmap) {
                throw new Error('Could not find a supported cmap table');
            }
            this.uvs = this.findSubtable(cmapTable, [[
                    0,
                    5
                ]]);
            if (this.uvs && this.uvs.version !== 14) {
                this.uvs = null;
            }
        }
        CmapProcessor.prototype.findSubtable = function findSubtable(cmapTable, pairs) {
            for (var _iterator2 = pairs, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _getIterator(_iterator2);;) {
                var _ref2;
                if (_isArray2) {
                    if (_i2 >= _iterator2.length)
                        break;
                    _ref2 = _iterator2[_i2++];
                } else {
                    _i2 = _iterator2.next();
                    if (_i2.done)
                        break;
                    _ref2 = _i2.value;
                }
                var _ref3 = _ref2, platformID = _ref3[0], encodingID = _ref3[1];
                for (var _iterator3 = cmapTable.tables, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _getIterator(_iterator3);;) {
                    var _ref4;
                    if (_isArray3) {
                        if (_i3 >= _iterator3.length)
                            break;
                        _ref4 = _iterator3[_i3++];
                    } else {
                        _i3 = _iterator3.next();
                        if (_i3.done)
                            break;
                        _ref4 = _i3.value;
                    }
                    var cmap = _ref4;
                    if (cmap.platformID === platformID && cmap.encodingID === encodingID) {
                        return cmap.table;
                    }
                }
            }
            return null;
        };
        CmapProcessor.prototype.lookup = function lookup(codepoint, variationSelector) {
            if (this.encoding) {
                var buf = iconv.encode(_String$fromCodePoint(codepoint), this.encoding);
                codepoint = 0;
                for (var i = 0; i < buf.length; i++) {
                    codepoint = codepoint << 8 | buf[i];
                }
            } else if (variationSelector) {
                var gid = this.getVariationSelector(codepoint, variationSelector);
                if (gid) {
                    return gid;
                }
            }
            var cmap = this.cmap;
            switch (cmap.version) {
            case 0:
                return cmap.codeMap.get(codepoint) || 0;
            case 4: {
                    var min = 0;
                    var max = cmap.segCount - 1;
                    while (min <= max) {
                        var mid = min + max >> 1;
                        if (codepoint < cmap.startCode.get(mid)) {
                            max = mid - 1;
                        } else if (codepoint > cmap.endCode.get(mid)) {
                            min = mid + 1;
                        } else {
                            var rangeOffset = cmap.idRangeOffset.get(mid);
                            var _gid = void 0;
                            if (rangeOffset === 0) {
                                _gid = codepoint + cmap.idDelta.get(mid);
                            } else {
                                var index = rangeOffset / 2 + (codepoint - cmap.startCode.get(mid)) - (cmap.segCount - mid);
                                _gid = cmap.glyphIndexArray.get(index) || 0;
                                if (_gid !== 0) {
                                    _gid += cmap.idDelta.get(mid);
                                }
                            }
                            return _gid & 65535;
                        }
                    }
                    return 0;
                }
            case 8:
                throw new Error('TODO: cmap format 8');
            case 6:
            case 10:
                return cmap.glyphIndices.get(codepoint - cmap.firstCode) || 0;
            case 12:
            case 13: {
                    var _min = 0;
                    var _max = cmap.nGroups - 1;
                    while (_min <= _max) {
                        var _mid = _min + _max >> 1;
                        var group = cmap.groups.get(_mid);
                        if (codepoint < group.startCharCode) {
                            _max = _mid - 1;
                        } else if (codepoint > group.endCharCode) {
                            _min = _mid + 1;
                        } else {
                            if (cmap.version === 12) {
                                return group.glyphID + (codepoint - group.startCharCode);
                            } else {
                                return group.glyphID;
                            }
                        }
                    }
                    return 0;
                }
            case 14:
                throw new Error('TODO: cmap format 14');
            default:
                throw new Error('Unknown cmap format ' + cmap.version);
            }
        };
        CmapProcessor.prototype.getVariationSelector = function getVariationSelector(codepoint, variationSelector) {
            if (!this.uvs) {
                return 0;
            }
            var selectors = this.uvs.varSelectors.toArray();
            var i = binarySearch(selectors, function (x) {
                    return variationSelector - x.varSelector;
                });
            var sel = selectors[i];
            if (i !== -1 && sel.defaultUVS) {
                i = binarySearch(sel.defaultUVS, function (x) {
                    return codepoint < x.startUnicodeValue ? -1 : codepoint > x.startUnicodeValue + x.additionalCount ? +1 : 0;
                });
            }
            if (i !== -1 && sel.nonDefaultUVS) {
                i = binarySearch(sel.nonDefaultUVS, function (x) {
                    return codepoint - x.unicodeValue;
                });
                if (i !== -1) {
                    return sel.nonDefaultUVS[i].glyphID;
                }
            }
            return 0;
        };
        CmapProcessor.prototype.getCharacterSet = function getCharacterSet() {
            var cmap = this.cmap;
            switch (cmap.version) {
            case 0:
                return range(0, cmap.codeMap.length);
            case 4: {
                    var res = [];
                    var endCodes = cmap.endCode.toArray();
                    for (var i = 0; i < endCodes.length; i++) {
                        var tail = endCodes[i] + 1;
                        var start = cmap.startCode.get(i);
                        res.push.apply(res, range(start, tail));
                    }
                    return res;
                }
            case 8:
                throw new Error('TODO: cmap format 8');
            case 6:
            case 10:
                return range(cmap.firstCode, cmap.firstCode + cmap.glyphIndices.length);
            case 12:
            case 13: {
                    var _res = [];
                    for (var _iterator4 = cmap.groups.toArray(), _isArray4 = Array.isArray(_iterator4), _i4 = 0, _iterator4 = _isArray4 ? _iterator4 : _getIterator(_iterator4);;) {
                        var _ref5;
                        if (_isArray4) {
                            if (_i4 >= _iterator4.length)
                                break;
                            _ref5 = _iterator4[_i4++];
                        } else {
                            _i4 = _iterator4.next();
                            if (_i4.done)
                                break;
                            _ref5 = _i4.value;
                        }
                        var group = _ref5;
                        _res.push.apply(_res, range(group.startCharCode, group.endCharCode + 1));
                    }
                    return _res;
                }
            case 14:
                throw new Error('TODO: cmap format 14');
            default:
                throw new Error('Unknown cmap format ' + cmap.version);
            }
        };
        CmapProcessor.prototype.codePointsForGlyph = function codePointsForGlyph(gid) {
            var cmap = this.cmap;
            switch (cmap.version) {
            case 0: {
                    var res = [];
                    for (var i = 0; i < 256; i++) {
                        if (cmap.codeMap.get(i) === gid) {
                            res.push(i);
                        }
                    }
                    return res;
                }
            case 4: {
                    var _res2 = [];
                    for (var _i5 = 0; _i5 < cmap.segCount; _i5++) {
                        var end = cmap.endCode.get(_i5);
                        var start = cmap.startCode.get(_i5);
                        var rangeOffset = cmap.idRangeOffset.get(_i5);
                        var delta = cmap.idDelta.get(_i5);
                        for (var c = start; c <= end; c++) {
                            var g = 0;
                            if (rangeOffset === 0) {
                                g = c + delta;
                            } else {
                                var index = rangeOffset / 2 + (c - start) - (cmap.segCount - _i5);
                                g = cmap.glyphIndexArray.get(index) || 0;
                                if (g !== 0) {
                                    g += delta;
                                }
                            }
                            if (g === gid) {
                                _res2.push(c);
                            }
                        }
                    }
                    return _res2;
                }
            case 12: {
                    var _res3 = [];
                    for (var _iterator5 = cmap.groups.toArray(), _isArray5 = Array.isArray(_iterator5), _i6 = 0, _iterator5 = _isArray5 ? _iterator5 : _getIterator(_iterator5);;) {
                        var _ref6;
                        if (_isArray5) {
                            if (_i6 >= _iterator5.length)
                                break;
                            _ref6 = _iterator5[_i6++];
                        } else {
                            _i6 = _iterator5.next();
                            if (_i6.done)
                                break;
                            _ref6 = _i6.value;
                        }
                        var group = _ref6;
                        if (gid >= group.glyphID && gid <= group.glyphID + (group.endCharCode - group.startCharCode)) {
                            _res3.push(group.startCharCode + (gid - group.glyphID));
                        }
                    }
                    return _res3;
                }
            case 13: {
                    var _res4 = [];
                    for (var _iterator6 = cmap.groups.toArray(), _isArray6 = Array.isArray(_iterator6), _i7 = 0, _iterator6 = _isArray6 ? _iterator6 : _getIterator(_iterator6);;) {
                        var _ref7;
                        if (_isArray6) {
                            if (_i7 >= _iterator6.length)
                                break;
                            _ref7 = _iterator6[_i7++];
                        } else {
                            _i7 = _iterator6.next();
                            if (_i7.done)
                                break;
                            _ref7 = _i7.value;
                        }
                        var _group = _ref7;
                        if (gid === _group.glyphID) {
                            _res4.push.apply(_res4, range(_group.startCharCode, _group.endCharCode + 1));
                        }
                    }
                    return _res4;
                }
            default:
                throw new Error('Unknown cmap format ' + cmap.version);
            }
        };
        return CmapProcessor;
    }(), (_applyDecoratedDescriptor$1(_class$1.prototype, 'getCharacterSet', [cache], _Object$getOwnPropertyDescriptor(_class$1.prototype, 'getCharacterSet'), _class$1.prototype), _applyDecoratedDescriptor$1(_class$1.prototype, 'codePointsForGlyph', [cache], _Object$getOwnPropertyDescriptor(_class$1.prototype, 'codePointsForGlyph'), _class$1.prototype)), _class$1);
var KernProcessor = function () {
        function KernProcessor(font) {
            _classCallCheck(this, KernProcessor);
            this.kern = font.kern;
        }
        KernProcessor.prototype.process = function process(glyphs, positions) {
            for (var glyphIndex = 0; glyphIndex < glyphs.length - 1; glyphIndex++) {
                var left = glyphs[glyphIndex].id;
                var right = glyphs[glyphIndex + 1].id;
                positions[glyphIndex].xAdvance += this.getKerning(left, right);
            }
        };
        KernProcessor.prototype.getKerning = function getKerning(left, right) {
            var res = 0;
            for (var _iterator = this.kern.tables, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _getIterator(_iterator);;) {
                var _ref;
                if (_isArray) {
                    if (_i >= _iterator.length)
                        break;
                    _ref = _iterator[_i++];
                } else {
                    _i = _iterator.next();
                    if (_i.done)
                        break;
                    _ref = _i.value;
                }
                var table = _ref;
                if (table.coverage.crossStream) {
                    continue;
                }
                switch (table.version) {
                case 0:
                    if (!table.coverage.horizontal) {
                        continue;
                    }
                    break;
                case 1:
                    if (table.coverage.vertical || table.coverage.variation) {
                        continue;
                    }
                    break;
                default:
                    throw new Error('Unsupported kerning table version ' + table.version);
                }
                var val = 0;
                var s = table.subtable;
                switch (table.format) {
                case 0:
                    var pairIdx = binarySearch(s.pairs, function (pair) {
                            return left - pair.left || right - pair.right;
                        });
                    if (pairIdx >= 0) {
                        val = s.pairs[pairIdx].value;
                    }
                    break;
                case 2:
                    var leftOffset = 0, rightOffset = 0;
                    if (left >= s.leftTable.firstGlyph && left < s.leftTable.firstGlyph + s.leftTable.nGlyphs) {
                        leftOffset = s.leftTable.offsets[left - s.leftTable.firstGlyph];
                    } else {
                        leftOffset = s.array.off;
                    }
                    if (right >= s.rightTable.firstGlyph && right < s.rightTable.firstGlyph + s.rightTable.nGlyphs) {
                        rightOffset = s.rightTable.offsets[right - s.rightTable.firstGlyph];
                    }
                    var index = (leftOffset + rightOffset - s.array.off) / 2;
                    val = s.array.values.get(index);
                    break;
                case 3:
                    if (left >= s.glyphCount || right >= s.glyphCount) {
                        return 0;
                    }
                    val = s.kernValue[s.kernIndex[s.leftClass[left] * s.rightClassCount + s.rightClass[right]]];
                    break;
                default:
                    throw new Error('Unsupported kerning sub-table format ' + table.format);
                }
                if (table.coverage.override) {
                    res = val;
                } else {
                    res += val;
                }
            }
            return res;
        };
        return KernProcessor;
    }();
var UnicodeLayoutEngine = function () {
        function UnicodeLayoutEngine(font) {
            _classCallCheck(this, UnicodeLayoutEngine);
            this.font = font;
        }
        UnicodeLayoutEngine.prototype.positionGlyphs = function positionGlyphs(glyphs, positions) {
            var clusterStart = 0;
            var clusterEnd = 0;
            for (var index = 0; index < glyphs.length; index++) {
                var glyph = glyphs[index];
                if (glyph.isMark) {
                    clusterEnd = index;
                } else {
                    if (clusterStart !== clusterEnd) {
                        this.positionCluster(glyphs, positions, clusterStart, clusterEnd);
                    }
                    clusterStart = clusterEnd = index;
                }
            }
            if (clusterStart !== clusterEnd) {
                this.positionCluster(glyphs, positions, clusterStart, clusterEnd);
            }
            return positions;
        };
        UnicodeLayoutEngine.prototype.positionCluster = function positionCluster(glyphs, positions, clusterStart, clusterEnd) {
            var base = glyphs[clusterStart];
            var baseBox = base.cbox.copy();
            if (base.codePoints.length > 1) {
                baseBox.minX += (base.codePoints.length - 1) * baseBox.width / base.codePoints.length;
            }
            var xOffset = -positions[clusterStart].xAdvance;
            var yOffset = 0;
            var yGap = this.font.unitsPerEm / 16;
            for (var index = clusterStart + 1; index <= clusterEnd; index++) {
                var mark = glyphs[index];
                var markBox = mark.cbox;
                var position = positions[index];
                var combiningClass = this.getCombiningClass(mark.codePoints[0]);
                if (combiningClass !== 'Not_Reordered') {
                    position.xOffset = position.yOffset = 0;
                    switch (combiningClass) {
                    case 'Double_Above':
                    case 'Double_Below':
                        position.xOffset += baseBox.minX - markBox.width / 2 - markBox.minX;
                        break;
                    case 'Attached_Below_Left':
                    case 'Below_Left':
                    case 'Above_Left':
                        position.xOffset += baseBox.minX - markBox.minX;
                        break;
                    case 'Attached_Above_Right':
                    case 'Below_Right':
                    case 'Above_Right':
                        position.xOffset += baseBox.maxX - markBox.width - markBox.minX;
                        break;
                    default:
                        position.xOffset += baseBox.minX + (baseBox.width - markBox.width) / 2 - markBox.minX;
                    }
                    switch (combiningClass) {
                    case 'Double_Below':
                    case 'Below_Left':
                    case 'Below':
                    case 'Below_Right':
                    case 'Attached_Below_Left':
                    case 'Attached_Below':
                        if (combiningClass === 'Attached_Below_Left' || combiningClass === 'Attached_Below') {
                            baseBox.minY += yGap;
                        }
                        position.yOffset = -baseBox.minY - markBox.maxY;
                        baseBox.minY += markBox.height;
                        break;
                    case 'Double_Above':
                    case 'Above_Left':
                    case 'Above':
                    case 'Above_Right':
                    case 'Attached_Above':
                    case 'Attached_Above_Right':
                        if (combiningClass === 'Attached_Above' || combiningClass === 'Attached_Above_Right') {
                            baseBox.maxY += yGap;
                        }
                        position.yOffset = baseBox.maxY - markBox.minY;
                        baseBox.maxY += markBox.height;
                        break;
                    }
                    position.xAdvance = position.yAdvance = 0;
                    position.xOffset += xOffset;
                    position.yOffset += yOffset;
                } else {
                    xOffset -= position.xAdvance;
                    yOffset -= position.yAdvance;
                }
            }
            return;
        };
        UnicodeLayoutEngine.prototype.getCombiningClass = function getCombiningClass(codePoint) {
            var combiningClass = unicode.getCombiningClass(codePoint);
            if ((codePoint & ~255) === 3584) {
                if (combiningClass === 'Not_Reordered') {
                    switch (codePoint) {
                    case 3633:
                    case 3636:
                    case 3637:
                    case 3638:
                    case 3639:
                    case 3655:
                    case 3660:
                    case 3645:
                    case 3662:
                        return 'Above_Right';
                    case 3761:
                    case 3764:
                    case 3765:
                    case 3766:
                    case 3767:
                    case 3771:
                    case 3788:
                    case 3789:
                        return 'Above';
                    case 3772:
                        return 'Below';
                    }
                } else if (codePoint === 3642) {
                    return 'Below_Right';
                }
            }
            switch (combiningClass) {
            case 'CCC10':
            case 'CCC11':
            case 'CCC12':
            case 'CCC13':
            case 'CCC14':
            case 'CCC15':
            case 'CCC16':
            case 'CCC17':
            case 'CCC18':
            case 'CCC20':
            case 'CCC22':
                return 'Below';
            case 'CCC23':
                return 'Attached_Above';
            case 'CCC24':
                return 'Above_Right';
            case 'CCC25':
            case 'CCC19':
                return 'Above_Left';
            case 'CCC26':
                return 'Above';
            case 'CCC21':
                break;
            case 'CCC27':
            case 'CCC28':
            case 'CCC30':
            case 'CCC31':
            case 'CCC33':
            case 'CCC34':
            case 'CCC35':
            case 'CCC36':
                return 'Above';
            case 'CCC29':
            case 'CCC32':
                return 'Below';
            case 'CCC103':
                return 'Below_Right';
            case 'CCC107':
                return 'Above_Right';
            case 'CCC118':
                return 'Below';
            case 'CCC122':
                return 'Above';
            case 'CCC129':
            case 'CCC132':
                return 'Below';
            case 'CCC130':
                return 'Above';
            }
            return combiningClass;
        };
        return UnicodeLayoutEngine;
    }();
var BBox = function () {
        function BBox() {
            var minX = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Infinity;
            var minY = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Infinity;
            var maxX = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -Infinity;
            var maxY = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : -Infinity;
            _classCallCheck(this, BBox);
            this.minX = minX;
            this.minY = minY;
            this.maxX = maxX;
            this.maxY = maxY;
        }
        BBox.prototype.addPoint = function addPoint(x, y) {
            if (Math.abs(x) !== Infinity) {
                if (x < this.minX) {
                    this.minX = x;
                }
                if (x > this.maxX) {
                    this.maxX = x;
                }
            }
            if (Math.abs(y) !== Infinity) {
                if (y < this.minY) {
                    this.minY = y;
                }
                if (y > this.maxY) {
                    this.maxY = y;
                }
            }
        };
        BBox.prototype.copy = function copy() {
            return new BBox(this.minX, this.minY, this.maxX, this.maxY);
        };
        _createClass(BBox, [
            {
                key: 'width',
                get: function get() {
                    return this.maxX - this.minX;
                }
            },
            {
                key: 'height',
                get: function get() {
                    return this.maxY - this.minY;
                }
            }
        ]);
        return BBox;
    }();
var UNICODE_SCRIPTS = {
        Caucasian_Albanian: 'aghb',
        Arabic: 'arab',
        Imperial_Aramaic: 'armi',
        Armenian: 'armn',
        Avestan: 'avst',
        Balinese: 'bali',
        Bamum: 'bamu',
        Bassa_Vah: 'bass',
        Batak: 'batk',
        Bengali: [
            'bng2',
            'beng'
        ],
        Bopomofo: 'bopo',
        Brahmi: 'brah',
        Braille: 'brai',
        Buginese: 'bugi',
        Buhid: 'buhd',
        Chakma: 'cakm',
        Canadian_Aboriginal: 'cans',
        Carian: 'cari',
        Cham: 'cham',
        Cherokee: 'cher',
        Coptic: 'copt',
        Cypriot: 'cprt',
        Cyrillic: 'cyrl',
        Devanagari: [
            'dev2',
            'deva'
        ],
        Deseret: 'dsrt',
        Duployan: 'dupl',
        Egyptian_Hieroglyphs: 'egyp',
        Elbasan: 'elba',
        Ethiopic: 'ethi',
        Georgian: 'geor',
        Glagolitic: 'glag',
        Gothic: 'goth',
        Grantha: 'gran',
        Greek: 'grek',
        Gujarati: [
            'gjr2',
            'gujr'
        ],
        Gurmukhi: [
            'gur2',
            'guru'
        ],
        Hangul: 'hang',
        Han: 'hani',
        Hanunoo: 'hano',
        Hebrew: 'hebr',
        Hiragana: 'hira',
        Pahawh_Hmong: 'hmng',
        Katakana_Or_Hiragana: 'hrkt',
        Old_Italic: 'ital',
        Javanese: 'java',
        Kayah_Li: 'kali',
        Katakana: 'kana',
        Kharoshthi: 'khar',
        Khmer: 'khmr',
        Khojki: 'khoj',
        Kannada: [
            'knd2',
            'knda'
        ],
        Kaithi: 'kthi',
        Tai_Tham: 'lana',
        Lao: 'lao ',
        Latin: 'latn',
        Lepcha: 'lepc',
        Limbu: 'limb',
        Linear_A: 'lina',
        Linear_B: 'linb',
        Lisu: 'lisu',
        Lycian: 'lyci',
        Lydian: 'lydi',
        Mahajani: 'mahj',
        Mandaic: 'mand',
        Manichaean: 'mani',
        Mende_Kikakui: 'mend',
        Meroitic_Cursive: 'merc',
        Meroitic_Hieroglyphs: 'mero',
        Malayalam: [
            'mlm2',
            'mlym'
        ],
        Modi: 'modi',
        Mongolian: 'mong',
        Mro: 'mroo',
        Meetei_Mayek: 'mtei',
        Myanmar: [
            'mym2',
            'mymr'
        ],
        Old_North_Arabian: 'narb',
        Nabataean: 'nbat',
        Nko: 'nko ',
        Ogham: 'ogam',
        Ol_Chiki: 'olck',
        Old_Turkic: 'orkh',
        Oriya: [
            'ory2',
            'orya'
        ],
        Osmanya: 'osma',
        Palmyrene: 'palm',
        Pau_Cin_Hau: 'pauc',
        Old_Permic: 'perm',
        Phags_Pa: 'phag',
        Inscriptional_Pahlavi: 'phli',
        Psalter_Pahlavi: 'phlp',
        Phoenician: 'phnx',
        Miao: 'plrd',
        Inscriptional_Parthian: 'prti',
        Rejang: 'rjng',
        Runic: 'runr',
        Samaritan: 'samr',
        Old_South_Arabian: 'sarb',
        Saurashtra: 'saur',
        Shavian: 'shaw',
        Sharada: 'shrd',
        Siddham: 'sidd',
        Khudawadi: 'sind',
        Sinhala: 'sinh',
        Sora_Sompeng: 'sora',
        Sundanese: 'sund',
        Syloti_Nagri: 'sylo',
        Syriac: 'syrc',
        Tagbanwa: 'tagb',
        Takri: 'takr',
        Tai_Le: 'tale',
        New_Tai_Lue: 'talu',
        Tamil: [
            'tml2',
            'taml'
        ],
        Tai_Viet: 'tavt',
        Telugu: [
            'tel2',
            'telu'
        ],
        Tifinagh: 'tfng',
        Tagalog: 'tglg',
        Thaana: 'thaa',
        Thai: 'thai',
        Tibetan: 'tibt',
        Tirhuta: 'tirh',
        Ugaritic: 'ugar',
        Vai: 'vai ',
        Warang_Citi: 'wara',
        Old_Persian: 'xpeo',
        Cuneiform: 'xsux',
        Yi: 'yi  ',
        Inherited: 'zinh',
        Common: 'zyyy',
        Unknown: 'zzzz'
    };
var OPENTYPE_SCRIPTS = {};
for (var script in UNICODE_SCRIPTS) {
    var tag = UNICODE_SCRIPTS[script];
    if (Array.isArray(tag)) {
        for (var _iterator = tag, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _getIterator(_iterator);;) {
            var _ref;
            if (_isArray) {
                if (_i >= _iterator.length)
                    break;
                _ref = _iterator[_i++];
            } else {
                _i = _iterator.next();
                if (_i.done)
                    break;
                _ref = _i.value;
            }
            var t = _ref;
            OPENTYPE_SCRIPTS[t] = script;
        }
    } else {
        OPENTYPE_SCRIPTS[tag] = script;
    }
}
function fromOpenType(tag) {
    return OPENTYPE_SCRIPTS[tag];
}
function forString(string) {
    var len = string.length;
    var idx = 0;
    while (idx < len) {
        var code = string.charCodeAt(idx++);
        if (55296 <= code && code <= 56319 && idx < len) {
            var next = string.charCodeAt(idx);
            if (56320 <= next && next <= 57343) {
                idx++;
                code = ((code & 1023) << 10) + (next & 1023) + 65536;
            }
        }
        var _script = unicode.getScript(code);
        if (_script !== 'Common' && _script !== 'Inherited' && _script !== 'Unknown') {
            return UNICODE_SCRIPTS[_script];
        }
    }
    return UNICODE_SCRIPTS.Unknown;
}
function forCodePoints(codePoints) {
    for (var i = 0; i < codePoints.length; i++) {
        var codePoint = codePoints[i];
        var _script2 = unicode.getScript(codePoint);
        if (_script2 !== 'Common' && _script2 !== 'Inherited' && _script2 !== 'Unknown') {
            return UNICODE_SCRIPTS[_script2];
        }
    }
    return UNICODE_SCRIPTS.Unknown;
}
var RTL = {
        arab: true,
        hebr: true,
        syrc: true,
        thaa: true,
        cprt: true,
        khar: true,
        phnx: true,
        'nko ': true,
        lydi: true,
        avst: true,
        armi: true,
        phli: true,
        prti: true,
        sarb: true,
        orkh: true,
        samr: true,
        mand: true,
        merc: true,
        mero: true,
        mani: true,
        mend: true,
        nbat: true,
        narb: true,
        palm: true,
        phlp: true
    };
function direction(script) {
    if (RTL[script]) {
        return 'rtl';
    }
    return 'ltr';
}
var GlyphRun = function () {
        function GlyphRun(glyphs, features, script, language, direction$$) {
            _classCallCheck(this, GlyphRun);
            this.glyphs = glyphs;
            this.positions = null;
            this.script = script;
            this.language = language || null;
            this.direction = direction$$ || direction(script);
            this.features = {};
            if (Array.isArray(features)) {
                for (var _iterator = features, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _getIterator(_iterator);;) {
                    var _ref;
                    if (_isArray) {
                        if (_i >= _iterator.length)
                            break;
                        _ref = _iterator[_i++];
                    } else {
                        _i = _iterator.next();
                        if (_i.done)
                            break;
                        _ref = _i.value;
                    }
                    var tag = _ref;
                    this.features[tag] = true;
                }
            } else if ((typeof features === 'undefined' ? 'undefined' : _typeof(features)) === 'object') {
                this.features = features;
            }
        }
        _createClass(GlyphRun, [
            {
                key: 'advanceWidth',
                get: function get() {
                    var width = 0;
                    for (var _iterator2 = this.positions, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _getIterator(_iterator2);;) {
                        var _ref2;
                        if (_isArray2) {
                            if (_i2 >= _iterator2.length)
                                break;
                            _ref2 = _iterator2[_i2++];
                        } else {
                            _i2 = _iterator2.next();
                            if (_i2.done)
                                break;
                            _ref2 = _i2.value;
                        }
                        var position = _ref2;
                        width += position.xAdvance;
                    }
                    return width;
                }
            },
            {
                key: 'advanceHeight',
                get: function get() {
                    var height = 0;
                    for (var _iterator3 = this.positions, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _getIterator(_iterator3);;) {
                        var _ref3;
                        if (_isArray3) {
                            if (_i3 >= _iterator3.length)
                                break;
                            _ref3 = _iterator3[_i3++];
                        } else {
                            _i3 = _iterator3.next();
                            if (_i3.done)
                                break;
                            _ref3 = _i3.value;
                        }
                        var position = _ref3;
                        height += position.yAdvance;
                    }
                    return height;
                }
            },
            {
                key: 'bbox',
                get: function get() {
                    var bbox = new BBox();
                    var x = 0;
                    var y = 0;
                    for (var index = 0; index < this.glyphs.length; index++) {
                        var glyph = this.glyphs[index];
                        var p = this.positions[index];
                        var b = glyph.bbox;
                        bbox.addPoint(b.minX + x + p.xOffset, b.minY + y + p.yOffset);
                        bbox.addPoint(b.maxX + x + p.xOffset, b.maxY + y + p.yOffset);
                        x += p.xAdvance;
                        y += p.yAdvance;
                    }
                    return bbox;
                }
            }
        ]);
        return GlyphRun;
    }();
var GlyphPosition = function GlyphPosition() {
    var xAdvance = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    var yAdvance = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var xOffset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    var yOffset = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
    _classCallCheck(this, GlyphPosition);
    this.xAdvance = xAdvance;
    this.yAdvance = yAdvance;
    this.xOffset = xOffset;
    this.yOffset = yOffset;
};
var features = {
        allTypographicFeatures: {
            code: 0,
            exclusive: false,
            allTypeFeatures: 0
        },
        ligatures: {
            code: 1,
            exclusive: false,
            requiredLigatures: 0,
            commonLigatures: 2,
            rareLigatures: 4,
            rebusPictures: 8,
            diphthongLigatures: 10,
            squaredLigatures: 12,
            abbrevSquaredLigatures: 14,
            symbolLigatures: 16,
            contextualLigatures: 18,
            historicalLigatures: 20
        },
        cursiveConnection: {
            code: 2,
            exclusive: true,
            unconnected: 0,
            partiallyConnected: 1,
            cursive: 2
        },
        letterCase: {
            code: 3,
            exclusive: true
        },
        verticalSubstitution: {
            code: 4,
            exclusive: false,
            substituteVerticalForms: 0
        },
        linguisticRearrangement: {
            code: 5,
            exclusive: false,
            linguisticRearrangement: 0
        },
        numberSpacing: {
            code: 6,
            exclusive: true,
            monospacedNumbers: 0,
            proportionalNumbers: 1,
            thirdWidthNumbers: 2,
            quarterWidthNumbers: 3
        },
        smartSwash: {
            code: 8,
            exclusive: false,
            wordInitialSwashes: 0,
            wordFinalSwashes: 2,
            nonFinalSwashes: 8
        },
        diacritics: {
            code: 9,
            exclusive: true,
            showDiacritics: 0,
            hideDiacritics: 1,
            decomposeDiacritics: 2
        },
        verticalPosition: {
            code: 10,
            exclusive: true,
            normalPosition: 0,
            superiors: 1,
            inferiors: 2,
            ordinals: 3,
            scientificInferiors: 4
        },
        fractions: {
            code: 11,
            exclusive: true,
            noFractions: 0,
            verticalFractions: 1,
            diagonalFractions: 2
        },
        overlappingCharacters: {
            code: 13,
            exclusive: false,
            preventOverlap: 0
        },
        typographicExtras: {
            code: 14,
            exclusive: false,
            slashedZero: 4
        },
        mathematicalExtras: {
            code: 15,
            exclusive: false,
            mathematicalGreek: 10
        },
        ornamentSets: {
            code: 16,
            exclusive: true,
            noOrnaments: 0,
            dingbats: 1,
            piCharacters: 2,
            fleurons: 3,
            decorativeBorders: 4,
            internationalSymbols: 5,
            mathSymbols: 6
        },
        characterAlternatives: {
            code: 17,
            exclusive: true,
            noAlternates: 0
        },
        designComplexity: {
            code: 18,
            exclusive: true,
            designLevel1: 0,
            designLevel2: 1,
            designLevel3: 2,
            designLevel4: 3,
            designLevel5: 4
        },
        styleOptions: {
            code: 19,
            exclusive: true,
            noStyleOptions: 0,
            displayText: 1,
            engravedText: 2,
            illuminatedCaps: 3,
            titlingCaps: 4,
            tallCaps: 5
        },
        characterShape: {
            code: 20,
            exclusive: true,
            traditionalCharacters: 0,
            simplifiedCharacters: 1,
            JIS1978Characters: 2,
            JIS1983Characters: 3,
            JIS1990Characters: 4,
            traditionalAltOne: 5,
            traditionalAltTwo: 6,
            traditionalAltThree: 7,
            traditionalAltFour: 8,
            traditionalAltFive: 9,
            expertCharacters: 10,
            JIS2004Characters: 11,
            hojoCharacters: 12,
            NLCCharacters: 13,
            traditionalNamesCharacters: 14
        },
        numberCase: {
            code: 21,
            exclusive: true,
            lowerCaseNumbers: 0,
            upperCaseNumbers: 1
        },
        textSpacing: {
            code: 22,
            exclusive: true,
            proportionalText: 0,
            monospacedText: 1,
            halfWidthText: 2,
            thirdWidthText: 3,
            quarterWidthText: 4,
            altProportionalText: 5,
            altHalfWidthText: 6
        },
        transliteration: {
            code: 23,
            exclusive: true,
            noTransliteration: 0
        },
        annotation: {
            code: 24,
            exclusive: true,
            noAnnotation: 0,
            boxAnnotation: 1,
            roundedBoxAnnotation: 2,
            circleAnnotation: 3,
            invertedCircleAnnotation: 4,
            parenthesisAnnotation: 5,
            periodAnnotation: 6,
            romanNumeralAnnotation: 7,
            diamondAnnotation: 8,
            invertedBoxAnnotation: 9,
            invertedRoundedBoxAnnotation: 10
        },
        kanaSpacing: {
            code: 25,
            exclusive: true,
            fullWidthKana: 0,
            proportionalKana: 1
        },
        ideographicSpacing: {
            code: 26,
            exclusive: true,
            fullWidthIdeographs: 0,
            proportionalIdeographs: 1,
            halfWidthIdeographs: 2
        },
        unicodeDecomposition: {
            code: 27,
            exclusive: false,
            canonicalComposition: 0,
            compatibilityComposition: 2,
            transcodingComposition: 4
        },
        rubyKana: {
            code: 28,
            exclusive: false,
            rubyKana: 2
        },
        CJKSymbolAlternatives: {
            code: 29,
            exclusive: true,
            noCJKSymbolAlternatives: 0,
            CJKSymbolAltOne: 1,
            CJKSymbolAltTwo: 2,
            CJKSymbolAltThree: 3,
            CJKSymbolAltFour: 4,
            CJKSymbolAltFive: 5
        },
        ideographicAlternatives: {
            code: 30,
            exclusive: true,
            noIdeographicAlternatives: 0,
            ideographicAltOne: 1,
            ideographicAltTwo: 2,
            ideographicAltThree: 3,
            ideographicAltFour: 4,
            ideographicAltFive: 5
        },
        CJKVerticalRomanPlacement: {
            code: 31,
            exclusive: true,
            CJKVerticalRomanCentered: 0,
            CJKVerticalRomanHBaseline: 1
        },
        italicCJKRoman: {
            code: 32,
            exclusive: false,
            CJKItalicRoman: 2
        },
        caseSensitiveLayout: {
            code: 33,
            exclusive: false,
            caseSensitiveLayout: 0,
            caseSensitiveSpacing: 2
        },
        alternateKana: {
            code: 34,
            exclusive: false,
            alternateHorizKana: 0,
            alternateVertKana: 2
        },
        stylisticAlternatives: {
            code: 35,
            exclusive: false,
            noStylisticAlternates: 0,
            stylisticAltOne: 2,
            stylisticAltTwo: 4,
            stylisticAltThree: 6,
            stylisticAltFour: 8,
            stylisticAltFive: 10,
            stylisticAltSix: 12,
            stylisticAltSeven: 14,
            stylisticAltEight: 16,
            stylisticAltNine: 18,
            stylisticAltTen: 20,
            stylisticAltEleven: 22,
            stylisticAltTwelve: 24,
            stylisticAltThirteen: 26,
            stylisticAltFourteen: 28,
            stylisticAltFifteen: 30,
            stylisticAltSixteen: 32,
            stylisticAltSeventeen: 34,
            stylisticAltEighteen: 36,
            stylisticAltNineteen: 38,
            stylisticAltTwenty: 40
        },
        contextualAlternates: {
            code: 36,
            exclusive: false,
            contextualAlternates: 0,
            swashAlternates: 2,
            contextualSwashAlternates: 4
        },
        lowerCase: {
            code: 37,
            exclusive: true,
            defaultLowerCase: 0,
            lowerCaseSmallCaps: 1,
            lowerCasePetiteCaps: 2
        },
        upperCase: {
            code: 38,
            exclusive: true,
            defaultUpperCase: 0,
            upperCaseSmallCaps: 1,
            upperCasePetiteCaps: 2
        },
        languageTag: {
            code: 39,
            exclusive: true
        },
        CJKRomanSpacing: {
            code: 103,
            exclusive: true,
            halfWidthCJKRoman: 0,
            proportionalCJKRoman: 1,
            defaultCJKRoman: 2,
            fullWidthCJKRoman: 3
        }
    };
var feature = function feature(name, selector) {
    return [
        features[name].code,
        features[name][selector]
    ];
};
var OTMapping = {
        rlig: feature('ligatures', 'requiredLigatures'),
        clig: feature('ligatures', 'contextualLigatures'),
        dlig: feature('ligatures', 'rareLigatures'),
        hlig: feature('ligatures', 'historicalLigatures'),
        liga: feature('ligatures', 'commonLigatures'),
        hist: feature('ligatures', 'historicalLigatures'),
        smcp: feature('lowerCase', 'lowerCaseSmallCaps'),
        pcap: feature('lowerCase', 'lowerCasePetiteCaps'),
        frac: feature('fractions', 'diagonalFractions'),
        dnom: feature('fractions', 'diagonalFractions'),
        numr: feature('fractions', 'diagonalFractions'),
        afrc: feature('fractions', 'verticalFractions'),
        case: feature('caseSensitiveLayout', 'caseSensitiveLayout'),
        ccmp: feature('unicodeDecomposition', 'canonicalComposition'),
        cpct: feature('CJKVerticalRomanPlacement', 'CJKVerticalRomanCentered'),
        valt: feature('CJKVerticalRomanPlacement', 'CJKVerticalRomanCentered'),
        swsh: feature('contextualAlternates', 'swashAlternates'),
        cswh: feature('contextualAlternates', 'contextualSwashAlternates'),
        curs: feature('cursiveConnection', 'cursive'),
        c2pc: feature('upperCase', 'upperCasePetiteCaps'),
        c2sc: feature('upperCase', 'upperCaseSmallCaps'),
        init: feature('smartSwash', 'wordInitialSwashes'),
        fin2: feature('smartSwash', 'wordFinalSwashes'),
        medi: feature('smartSwash', 'nonFinalSwashes'),
        med2: feature('smartSwash', 'nonFinalSwashes'),
        fin3: feature('smartSwash', 'wordFinalSwashes'),
        fina: feature('smartSwash', 'wordFinalSwashes'),
        pkna: feature('kanaSpacing', 'proportionalKana'),
        half: feature('textSpacing', 'halfWidthText'),
        halt: feature('textSpacing', 'altHalfWidthText'),
        hkna: feature('alternateKana', 'alternateHorizKana'),
        vkna: feature('alternateKana', 'alternateVertKana'),
        ital: feature('italicCJKRoman', 'CJKItalicRoman'),
        lnum: feature('numberCase', 'upperCaseNumbers'),
        onum: feature('numberCase', 'lowerCaseNumbers'),
        mgrk: feature('mathematicalExtras', 'mathematicalGreek'),
        calt: feature('contextualAlternates', 'contextualAlternates'),
        vrt2: feature('verticalSubstitution', 'substituteVerticalForms'),
        vert: feature('verticalSubstitution', 'substituteVerticalForms'),
        tnum: feature('numberSpacing', 'monospacedNumbers'),
        pnum: feature('numberSpacing', 'proportionalNumbers'),
        sups: feature('verticalPosition', 'superiors'),
        subs: feature('verticalPosition', 'inferiors'),
        ordn: feature('verticalPosition', 'ordinals'),
        pwid: feature('textSpacing', 'proportionalText'),
        hwid: feature('textSpacing', 'halfWidthText'),
        qwid: feature('textSpacing', 'quarterWidthText'),
        twid: feature('textSpacing', 'thirdWidthText'),
        fwid: feature('textSpacing', 'proportionalText'),
        palt: feature('textSpacing', 'altProportionalText'),
        trad: feature('characterShape', 'traditionalCharacters'),
        smpl: feature('characterShape', 'simplifiedCharacters'),
        jp78: feature('characterShape', 'JIS1978Characters'),
        jp83: feature('characterShape', 'JIS1983Characters'),
        jp90: feature('characterShape', 'JIS1990Characters'),
        jp04: feature('characterShape', 'JIS2004Characters'),
        expt: feature('characterShape', 'expertCharacters'),
        hojo: feature('characterShape', 'hojoCharacters'),
        nlck: feature('characterShape', 'NLCCharacters'),
        tnam: feature('characterShape', 'traditionalNamesCharacters'),
        ruby: feature('rubyKana', 'rubyKana'),
        titl: feature('styleOptions', 'titlingCaps'),
        zero: feature('typographicExtras', 'slashedZero'),
        ss01: feature('stylisticAlternatives', 'stylisticAltOne'),
        ss02: feature('stylisticAlternatives', 'stylisticAltTwo'),
        ss03: feature('stylisticAlternatives', 'stylisticAltThree'),
        ss04: feature('stylisticAlternatives', 'stylisticAltFour'),
        ss05: feature('stylisticAlternatives', 'stylisticAltFive'),
        ss06: feature('stylisticAlternatives', 'stylisticAltSix'),
        ss07: feature('stylisticAlternatives', 'stylisticAltSeven'),
        ss08: feature('stylisticAlternatives', 'stylisticAltEight'),
        ss09: feature('stylisticAlternatives', 'stylisticAltNine'),
        ss10: feature('stylisticAlternatives', 'stylisticAltTen'),
        ss11: feature('stylisticAlternatives', 'stylisticAltEleven'),
        ss12: feature('stylisticAlternatives', 'stylisticAltTwelve'),
        ss13: feature('stylisticAlternatives', 'stylisticAltThirteen'),
        ss14: feature('stylisticAlternatives', 'stylisticAltFourteen'),
        ss15: feature('stylisticAlternatives', 'stylisticAltFifteen'),
        ss16: feature('stylisticAlternatives', 'stylisticAltSixteen'),
        ss17: feature('stylisticAlternatives', 'stylisticAltSeventeen'),
        ss18: feature('stylisticAlternatives', 'stylisticAltEighteen'),
        ss19: feature('stylisticAlternatives', 'stylisticAltNineteen'),
        ss20: feature('stylisticAlternatives', 'stylisticAltTwenty')
    };
for (var i = 1; i <= 99; i++) {
    OTMapping['cv' + ('00' + i).slice(-2)] = [
        features.characterAlternatives.code,
        i
    ];
}
var AATMapping = {};
for (var ot in OTMapping) {
    var aat = OTMapping[ot];
    if (AATMapping[aat[0]] == null) {
        AATMapping[aat[0]] = {};
    }
    AATMapping[aat[0]][aat[1]] = ot;
}
function mapOTToAAT(features) {
    var res = {};
    for (var k in features) {
        var r = void 0;
        if (r = OTMapping[k]) {
            if (res[r[0]] == null) {
                res[r[0]] = {};
            }
            res[r[0]][r[1]] = features[k];
        }
    }
    return res;
}
function mapFeatureStrings(f) {
    var type = f[0], setting = f[1];
    if (isNaN(type)) {
        var typeCode = features[type] && features[type].code;
    } else {
        var typeCode = type;
    }
    if (isNaN(setting)) {
        var settingCode = features[type] && features[type][setting];
    } else {
        var settingCode = setting;
    }
    return [
        typeCode,
        settingCode
    ];
}
function mapAATToOT(features) {
    var res = {};
    if (Array.isArray(features)) {
        for (var k = 0; k < features.length; k++) {
            var r = void 0;
            var f = mapFeatureStrings(features[k]);
            if (r = AATMapping[f[0]] && AATMapping[f[0]][f[1]]) {
                res[r] = true;
            }
        }
    } else if ((typeof features === 'undefined' ? 'undefined' : _typeof(features)) === 'object') {
        for (var type in features) {
            var _feature = features[type];
            for (var setting in _feature) {
                var _r = void 0;
                var _f = mapFeatureStrings([
                        type,
                        setting
                    ]);
                if (_feature[setting] && (_r = AATMapping[_f[0]] && AATMapping[_f[0]][_f[1]])) {
                    res[_r] = true;
                }
            }
        }
    }
    return _Object$keys(res);
}
var _class$3;
function _applyDecoratedDescriptor$3(target, property, decorators, descriptor, context) {
    var desc = {};
    Object['ke' + 'ys'](descriptor).forEach(function (key) {
        desc[key] = descriptor[key];
    });
    desc.enumerable = !!desc.enumerable;
    desc.configurable = !!desc.configurable;
    if ('value' in desc || desc.initializer) {
        desc.writable = true;
    }
    desc = decorators.slice().reverse().reduce(function (desc, decorator) {
        return decorator(target, property, desc) || desc;
    }, desc);
    if (context && desc.initializer !== void 0) {
        desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
        desc.initializer = undefined;
    }
    if (desc.initializer === void 0) {
        Object['define' + 'Property'](target, property, desc);
        desc = null;
    }
    return desc;
}
var AATLookupTable = (_class$3 = function () {
        function AATLookupTable(table) {
            _classCallCheck(this, AATLookupTable);
            this.table = table;
        }
        AATLookupTable.prototype.lookup = function lookup(glyph) {
            switch (this.table.version) {
            case 0:
                return this.table.values.getItem(glyph);
            case 2:
            case 4: {
                    var min = 0;
                    var max = this.table.binarySearchHeader.nUnits - 1;
                    while (min <= max) {
                        var mid = min + max >> 1;
                        var seg = this.table.segments[mid];
                        if (seg.firstGlyph === 65535) {
                            return null;
                        }
                        if (glyph < seg.firstGlyph) {
                            max = mid - 1;
                        } else if (glyph > seg.lastGlyph) {
                            min = mid + 1;
                        } else {
                            if (this.table.version === 2) {
                                return seg.value;
                            } else {
                                return seg.values[glyph - seg.firstGlyph];
                            }
                        }
                    }
                    return null;
                }
            case 6: {
                    var _min = 0;
                    var _max = this.table.binarySearchHeader.nUnits - 1;
                    while (_min <= _max) {
                        var mid = _min + _max >> 1;
                        var seg = this.table.segments[mid];
                        if (seg.glyph === 65535) {
                            return null;
                        }
                        if (glyph < seg.glyph) {
                            _max = mid - 1;
                        } else if (glyph > seg.glyph) {
                            _min = mid + 1;
                        } else {
                            return seg.value;
                        }
                    }
                    return null;
                }
            case 8:
                return this.table.values[glyph - this.table.firstGlyph];
            default:
                throw new Error('Unknown lookup table format: ' + this.table.version);
            }
        };
        AATLookupTable.prototype.glyphsForValue = function glyphsForValue(classValue) {
            var res = [];
            switch (this.table.version) {
            case 2:
            case 4: {
                    for (var _iterator = this.table.segments, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _getIterator(_iterator);;) {
                        var _ref;
                        if (_isArray) {
                            if (_i >= _iterator.length)
                                break;
                            _ref = _iterator[_i++];
                        } else {
                            _i = _iterator.next();
                            if (_i.done)
                                break;
                            _ref = _i.value;
                        }
                        var segment = _ref;
                        if (this.table.version === 2 && segment.value === classValue) {
                            res.push.apply(res, range(segment.firstGlyph, segment.lastGlyph + 1));
                        } else {
                            for (var index = 0; index < segment.values.length; index++) {
                                if (segment.values[index] === classValue) {
                                    res.push(segment.firstGlyph + index);
                                }
                            }
                        }
                    }
                    break;
                }
            case 6: {
                    for (var _iterator2 = this.table.segments, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _getIterator(_iterator2);;) {
                        var _ref2;
                        if (_isArray2) {
                            if (_i2 >= _iterator2.length)
                                break;
                            _ref2 = _iterator2[_i2++];
                        } else {
                            _i2 = _iterator2.next();
                            if (_i2.done)
                                break;
                            _ref2 = _i2.value;
                        }
                        var _segment = _ref2;
                        if (_segment.value === classValue) {
                            res.push(_segment.glyph);
                        }
                    }
                    break;
                }
            case 8: {
                    for (var i = 0; i < this.table.values.length; i++) {
                        if (this.table.values[i] === classValue) {
                            res.push(this.table.firstGlyph + i);
                        }
                    }
                    break;
                }
            default:
                throw new Error('Unknown lookup table format: ' + this.table.version);
            }
            return res;
        };
        return AATLookupTable;
    }(), _applyDecoratedDescriptor$3(_class$3.prototype, 'glyphsForValue', [cache], _Object$getOwnPropertyDescriptor(_class$3.prototype, 'glyphsForValue'), _class$3.prototype), _class$3);
var START_OF_TEXT_STATE = 0;
var END_OF_TEXT_CLASS = 0;
var OUT_OF_BOUNDS_CLASS = 1;
var DELETED_GLYPH_CLASS = 2;
var DONT_ADVANCE = 16384;
var AATStateMachine = function () {
        function AATStateMachine(stateTable) {
            _classCallCheck(this, AATStateMachine);
            this.stateTable = stateTable;
            this.lookupTable = new AATLookupTable(stateTable.classTable);
        }
        AATStateMachine.prototype.process = function process(glyphs, reverse, processEntry) {
            var currentState = START_OF_TEXT_STATE;
            var index = reverse ? glyphs.length - 1 : 0;
            var dir = reverse ? -1 : 1;
            while (dir === 1 && index <= glyphs.length || dir === -1 && index >= -1) {
                var glyph = null;
                var classCode = OUT_OF_BOUNDS_CLASS;
                var shouldAdvance = true;
                if (index === glyphs.length || index === -1) {
                    classCode = END_OF_TEXT_CLASS;
                } else {
                    glyph = glyphs[index];
                    if (glyph.id === 65535) {
                        classCode = DELETED_GLYPH_CLASS;
                    } else {
                        classCode = this.lookupTable.lookup(glyph.id);
                        if (classCode == null) {
                            classCode = OUT_OF_BOUNDS_CLASS;
                        }
                    }
                }
                var row = this.stateTable.stateArray.getItem(currentState);
                var entryIndex = row[classCode];
                var entry = this.stateTable.entryTable.getItem(entryIndex);
                if (classCode !== END_OF_TEXT_CLASS && classCode !== DELETED_GLYPH_CLASS) {
                    processEntry(glyph, entry, index);
                    shouldAdvance = !(entry.flags & DONT_ADVANCE);
                }
                currentState = entry.newState;
                if (shouldAdvance) {
                    index += dir;
                }
            }
            return glyphs;
        };
        AATStateMachine.prototype.traverse = function traverse(opts) {
            var state = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
            var visited = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new _Set();
            if (visited.has(state)) {
                return;
            }
            visited.add(state);
            var _stateTable = this.stateTable, nClasses = _stateTable.nClasses, stateArray = _stateTable.stateArray, entryTable = _stateTable.entryTable;
            var row = stateArray.getItem(state);
            for (var classCode = 4; classCode < nClasses; classCode++) {
                var entryIndex = row[classCode];
                var entry = entryTable.getItem(entryIndex);
                for (var _iterator = this.lookupTable.glyphsForValue(classCode), _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _getIterator(_iterator);;) {
                    var _ref;
                    if (_isArray) {
                        if (_i >= _iterator.length)
                            break;
                        _ref = _iterator[_i++];
                    } else {
                        _i = _iterator.next();
                        if (_i.done)
                            break;
                        _ref = _i.value;
                    }
                    var glyph = _ref;
                    if (opts.enter) {
                        opts.enter(glyph, entry);
                    }
                    if (entry.newState !== 0) {
                        this.traverse(opts, entry.newState, visited);
                    }
                    if (opts.exit) {
                        opts.exit(glyph, entry);
                    }
                }
            }
        };
        return AATStateMachine;
    }();
var _class$2;
function _applyDecoratedDescriptor$2(target, property, decorators, descriptor, context) {
    var desc = {};
    Object['ke' + 'ys'](descriptor).forEach(function (key) {
        desc[key] = descriptor[key];
    });
    desc.enumerable = !!desc.enumerable;
    desc.configurable = !!desc.configurable;
    if ('value' in desc || desc.initializer) {
        desc.writable = true;
    }
    desc = decorators.slice().reverse().reduce(function (desc, decorator) {
        return decorator(target, property, desc) || desc;
    }, desc);
    if (context && desc.initializer !== void 0) {
        desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
        desc.initializer = undefined;
    }
    if (desc.initializer === void 0) {
        Object['define' + 'Property'](target, property, desc);
        desc = null;
    }
    return desc;
}
var MARK_FIRST = 32768;
var MARK_LAST = 8192;
var VERB = 15;
var SET_MARK = 32768;
var SET_COMPONENT = 32768;
var PERFORM_ACTION = 8192;
var LAST_MASK = 2147483648;
var STORE_MASK = 1073741824;
var OFFSET_MASK = 1073741823;
var REVERSE_DIRECTION = 4194304;
var CURRENT_INSERT_BEFORE = 2048;
var MARKED_INSERT_BEFORE = 1024;
var CURRENT_INSERT_COUNT = 992;
var MARKED_INSERT_COUNT = 31;
var AATMorxProcessor = (_class$2 = function () {
        function AATMorxProcessor(font) {
            _classCallCheck(this, AATMorxProcessor);
            this.processIndicRearragement = this.processIndicRearragement.bind(this);
            this.processContextualSubstitution = this.processContextualSubstitution.bind(this);
            this.processLigature = this.processLigature.bind(this);
            this.processNoncontextualSubstitutions = this.processNoncontextualSubstitutions.bind(this);
            this.processGlyphInsertion = this.processGlyphInsertion.bind(this);
            this.font = font;
            this.morx = font.morx;
            this.inputCache = null;
        }
        AATMorxProcessor.prototype.process = function process(glyphs) {
            var features = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
            for (var _iterator = this.morx.chains, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _getIterator(_iterator);;) {
                var _ref;
                if (_isArray) {
                    if (_i >= _iterator.length)
                        break;
                    _ref = _iterator[_i++];
                } else {
                    _i = _iterator.next();
                    if (_i.done)
                        break;
                    _ref = _i.value;
                }
                var chain = _ref;
                var flags = chain.defaultFlags;
                for (var _iterator2 = chain.features, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _getIterator(_iterator2);;) {
                    var _ref2;
                    if (_isArray2) {
                        if (_i2 >= _iterator2.length)
                            break;
                        _ref2 = _iterator2[_i2++];
                    } else {
                        _i2 = _iterator2.next();
                        if (_i2.done)
                            break;
                        _ref2 = _i2.value;
                    }
                    var feature = _ref2;
                    var f = void 0;
                    if ((f = features[feature.featureType]) && f[feature.featureSetting]) {
                        flags &= feature.disableFlags;
                        flags |= feature.enableFlags;
                    }
                }
                for (var _iterator3 = chain.subtables, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _getIterator(_iterator3);;) {
                    var _ref3;
                    if (_isArray3) {
                        if (_i3 >= _iterator3.length)
                            break;
                        _ref3 = _iterator3[_i3++];
                    } else {
                        _i3 = _iterator3.next();
                        if (_i3.done)
                            break;
                        _ref3 = _i3.value;
                    }
                    var subtable = _ref3;
                    if (subtable.subFeatureFlags & flags) {
                        this.processSubtable(subtable, glyphs);
                    }
                }
            }
            var index = glyphs.length - 1;
            while (index >= 0) {
                if (glyphs[index].id === 65535) {
                    glyphs.splice(index, 1);
                }
                index--;
            }
            return glyphs;
        };
        AATMorxProcessor.prototype.processSubtable = function processSubtable(subtable, glyphs) {
            this.subtable = subtable;
            this.glyphs = glyphs;
            if (this.subtable.type === 4) {
                this.processNoncontextualSubstitutions(this.subtable, this.glyphs);
                return;
            }
            this.ligatureStack = [];
            this.markedGlyph = null;
            this.firstGlyph = null;
            this.lastGlyph = null;
            this.markedIndex = null;
            var stateMachine = this.getStateMachine(subtable);
            var process = this.getProcessor();
            var reverse = !!(this.subtable.coverage & REVERSE_DIRECTION);
            return stateMachine.process(this.glyphs, reverse, process);
        };
        AATMorxProcessor.prototype.getStateMachine = function getStateMachine(subtable) {
            return new AATStateMachine(subtable.table.stateTable);
        };
        AATMorxProcessor.prototype.getProcessor = function getProcessor() {
            switch (this.subtable.type) {
            case 0:
                return this.processIndicRearragement;
            case 1:
                return this.processContextualSubstitution;
            case 2:
                return this.processLigature;
            case 4:
                return this.processNoncontextualSubstitutions;
            case 5:
                return this.processGlyphInsertion;
            default:
                throw new Error('Invalid morx subtable type: ' + this.subtable.type);
            }
        };
        AATMorxProcessor.prototype.processIndicRearragement = function processIndicRearragement(glyph, entry, index) {
            if (entry.flags & MARK_FIRST) {
                this.firstGlyph = index;
            }
            if (entry.flags & MARK_LAST) {
                this.lastGlyph = index;
            }
            reorderGlyphs(this.glyphs, entry.flags & VERB, this.firstGlyph, this.lastGlyph);
        };
        AATMorxProcessor.prototype.processContextualSubstitution = function processContextualSubstitution(glyph, entry, index) {
            var subsitutions = this.subtable.table.substitutionTable.items;
            if (entry.markIndex !== 65535) {
                var lookup = subsitutions.getItem(entry.markIndex);
                var lookupTable = new AATLookupTable(lookup);
                glyph = this.glyphs[this.markedGlyph];
                var gid = lookupTable.lookup(glyph.id);
                if (gid) {
                    this.glyphs[this.markedGlyph] = this.font.getGlyph(gid, glyph.codePoints);
                }
            }
            if (entry.currentIndex !== 65535) {
                var _lookup = subsitutions.getItem(entry.currentIndex);
                var _lookupTable = new AATLookupTable(_lookup);
                glyph = this.glyphs[index];
                var gid = _lookupTable.lookup(glyph.id);
                if (gid) {
                    this.glyphs[index] = this.font.getGlyph(gid, glyph.codePoints);
                }
            }
            if (entry.flags & SET_MARK) {
                this.markedGlyph = index;
            }
        };
        AATMorxProcessor.prototype.processLigature = function processLigature(glyph, entry, index) {
            if (entry.flags & SET_COMPONENT) {
                this.ligatureStack.push(index);
            }
            if (entry.flags & PERFORM_ACTION) {
                var _ligatureStack;
                var actions = this.subtable.table.ligatureActions;
                var components = this.subtable.table.components;
                var ligatureList = this.subtable.table.ligatureList;
                var actionIndex = entry.action;
                var last = false;
                var ligatureIndex = 0;
                var codePoints = [];
                var ligatureGlyphs = [];
                while (!last) {
                    var _codePoints;
                    var componentGlyph = this.ligatureStack.pop();
                    (_codePoints = codePoints).unshift.apply(_codePoints, this.glyphs[componentGlyph].codePoints);
                    var action = actions.getItem(actionIndex++);
                    last = !!(action & LAST_MASK);
                    var store = !!(action & STORE_MASK);
                    var offset = (action & OFFSET_MASK) << 2 >> 2;
                    offset += this.glyphs[componentGlyph].id;
                    var component = components.getItem(offset);
                    ligatureIndex += component;
                    if (last || store) {
                        var ligatureEntry = ligatureList.getItem(ligatureIndex);
                        this.glyphs[componentGlyph] = this.font.getGlyph(ligatureEntry, codePoints);
                        ligatureGlyphs.push(componentGlyph);
                        ligatureIndex = 0;
                        codePoints = [];
                    } else {
                        this.glyphs[componentGlyph] = this.font.getGlyph(65535);
                    }
                }
                (_ligatureStack = this.ligatureStack).push.apply(_ligatureStack, ligatureGlyphs);
            }
        };
        AATMorxProcessor.prototype.processNoncontextualSubstitutions = function processNoncontextualSubstitutions(subtable, glyphs, index) {
            var lookupTable = new AATLookupTable(subtable.table.lookupTable);
            for (index = 0; index < glyphs.length; index++) {
                var glyph = glyphs[index];
                if (glyph.id !== 65535) {
                    var gid = lookupTable.lookup(glyph.id);
                    if (gid) {
                        glyphs[index] = this.font.getGlyph(gid, glyph.codePoints);
                    }
                }
            }
        };
        AATMorxProcessor.prototype._insertGlyphs = function _insertGlyphs(glyphIndex, insertionActionIndex, count, isBefore) {
            var _glyphs;
            var insertions = [];
            while (count--) {
                var gid = this.subtable.table.insertionActions.getItem(insertionActionIndex++);
                insertions.push(this.font.getGlyph(gid));
            }
            if (!isBefore) {
                glyphIndex++;
            }
            (_glyphs = this.glyphs).splice.apply(_glyphs, [
                glyphIndex,
                0
            ].concat(insertions));
        };
        AATMorxProcessor.prototype.processGlyphInsertion = function processGlyphInsertion(glyph, entry, index) {
            if (entry.flags & SET_MARK) {
                this.markedIndex = index;
            }
            if (entry.markedInsertIndex !== 65535) {
                var count = (entry.flags & MARKED_INSERT_COUNT) >>> 5;
                var isBefore = !!(entry.flags & MARKED_INSERT_BEFORE);
                this._insertGlyphs(this.markedIndex, entry.markedInsertIndex, count, isBefore);
            }
            if (entry.currentInsertIndex !== 65535) {
                var _count = (entry.flags & CURRENT_INSERT_COUNT) >>> 5;
                var _isBefore = !!(entry.flags & CURRENT_INSERT_BEFORE);
                this._insertGlyphs(index, entry.currentInsertIndex, _count, _isBefore);
            }
        };
        AATMorxProcessor.prototype.getSupportedFeatures = function getSupportedFeatures() {
            var features = [];
            for (var _iterator4 = this.morx.chains, _isArray4 = Array.isArray(_iterator4), _i4 = 0, _iterator4 = _isArray4 ? _iterator4 : _getIterator(_iterator4);;) {
                var _ref4;
                if (_isArray4) {
                    if (_i4 >= _iterator4.length)
                        break;
                    _ref4 = _iterator4[_i4++];
                } else {
                    _i4 = _iterator4.next();
                    if (_i4.done)
                        break;
                    _ref4 = _i4.value;
                }
                var chain = _ref4;
                for (var _iterator5 = chain.features, _isArray5 = Array.isArray(_iterator5), _i5 = 0, _iterator5 = _isArray5 ? _iterator5 : _getIterator(_iterator5);;) {
                    var _ref5;
                    if (_isArray5) {
                        if (_i5 >= _iterator5.length)
                            break;
                        _ref5 = _iterator5[_i5++];
                    } else {
                        _i5 = _iterator5.next();
                        if (_i5.done)
                            break;
                        _ref5 = _i5.value;
                    }
                    var feature = _ref5;
                    features.push([
                        feature.featureType,
                        feature.featureSetting
                    ]);
                }
            }
            return features;
        };
        AATMorxProcessor.prototype.generateInputs = function generateInputs(gid) {
            if (!this.inputCache) {
                this.generateInputCache();
            }
            return this.inputCache[gid] || [];
        };
        AATMorxProcessor.prototype.generateInputCache = function generateInputCache() {
            this.inputCache = {};
            for (var _iterator6 = this.morx.chains, _isArray6 = Array.isArray(_iterator6), _i6 = 0, _iterator6 = _isArray6 ? _iterator6 : _getIterator(_iterator6);;) {
                var _ref6;
                if (_isArray6) {
                    if (_i6 >= _iterator6.length)
                        break;
                    _ref6 = _iterator6[_i6++];
                } else {
                    _i6 = _iterator6.next();
                    if (_i6.done)
                        break;
                    _ref6 = _i6.value;
                }
                var chain = _ref6;
                var flags = chain.defaultFlags;
                for (var _iterator7 = chain.subtables, _isArray7 = Array.isArray(_iterator7), _i7 = 0, _iterator7 = _isArray7 ? _iterator7 : _getIterator(_iterator7);;) {
                    var _ref7;
                    if (_isArray7) {
                        if (_i7 >= _iterator7.length)
                            break;
                        _ref7 = _iterator7[_i7++];
                    } else {
                        _i7 = _iterator7.next();
                        if (_i7.done)
                            break;
                        _ref7 = _i7.value;
                    }
                    var subtable = _ref7;
                    if (subtable.subFeatureFlags & flags) {
                        this.generateInputsForSubtable(subtable);
                    }
                }
            }
        };
        AATMorxProcessor.prototype.generateInputsForSubtable = function generateInputsForSubtable(subtable) {
            var _this = this;
            if (subtable.type !== 2) {
                return;
            }
            var reverse = !!(subtable.coverage & REVERSE_DIRECTION);
            if (reverse) {
                throw new Error('Reverse subtable, not supported.');
            }
            this.subtable = subtable;
            this.ligatureStack = [];
            var stateMachine = this.getStateMachine(subtable);
            var process = this.getProcessor();
            var input = [];
            var stack = [];
            this.glyphs = [];
            stateMachine.traverse({
                enter: function enter(glyph, entry) {
                    var glyphs = _this.glyphs;
                    stack.push({
                        glyphs: glyphs.slice(),
                        ligatureStack: _this.ligatureStack.slice()
                    });
                    var g = _this.font.getGlyph(glyph);
                    input.push(g);
                    glyphs.push(input[input.length - 1]);
                    process(glyphs[glyphs.length - 1], entry, glyphs.length - 1);
                    var count = 0;
                    var found = 0;
                    for (var i = 0; i < glyphs.length && count <= 1; i++) {
                        if (glyphs[i].id !== 65535) {
                            count++;
                            found = glyphs[i].id;
                        }
                    }
                    if (count === 1) {
                        var result = input.map(function (g) {
                                return g.id;
                            });
                        var _cache = _this.inputCache[found];
                        if (_cache) {
                            _cache.push(result);
                        } else {
                            _this.inputCache[found] = [result];
                        }
                    }
                },
                exit: function exit() {
                    var _stack$pop = stack.pop();
                    _this.glyphs = _stack$pop.glyphs;
                    _this.ligatureStack = _stack$pop.ligatureStack;
                    input.pop();
                }
            });
        };
        return AATMorxProcessor;
    }(), _applyDecoratedDescriptor$2(_class$2.prototype, 'getStateMachine', [cache], _Object$getOwnPropertyDescriptor(_class$2.prototype, 'getStateMachine'), _class$2.prototype), _class$2);
function swap(glyphs, rangeA, rangeB) {
    var reverseA = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
    var reverseB = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
    var end = glyphs.splice(rangeB[0] - (rangeB[1] - 1), rangeB[1]);
    if (reverseB) {
        end.reverse();
    }
    var start = glyphs.splice.apply(glyphs, [
            rangeA[0],
            rangeA[1]
        ].concat(end));
    if (reverseA) {
        start.reverse();
    }
    glyphs.splice.apply(glyphs, [
        rangeB[0] - (rangeA[1] - 1),
        0
    ].concat(start));
    return glyphs;
}
function reorderGlyphs(glyphs, verb, firstGlyph, lastGlyph) {
    var length = lastGlyph - firstGlyph + 1;
    switch (verb) {
    case 0:
        return glyphs;
    case 1:
        return swap(glyphs, [
            firstGlyph,
            1
        ], [
            lastGlyph,
            0
        ]);
    case 2:
        return swap(glyphs, [
            firstGlyph,
            0
        ], [
            lastGlyph,
            1
        ]);
    case 3:
        return swap(glyphs, [
            firstGlyph,
            1
        ], [
            lastGlyph,
            1
        ]);
    case 4:
        return swap(glyphs, [
            firstGlyph,
            2
        ], [
            lastGlyph,
            0
        ]);
    case 5:
        return swap(glyphs, [
            firstGlyph,
            2
        ], [
            lastGlyph,
            0
        ], true, false);
    case 6:
        return swap(glyphs, [
            firstGlyph,
            0
        ], [
            lastGlyph,
            2
        ]);
    case 7:
        return swap(glyphs, [
            firstGlyph,
            0
        ], [
            lastGlyph,
            2
        ], false, true);
    case 8:
        return swap(glyphs, [
            firstGlyph,
            1
        ], [
            lastGlyph,
            2
        ]);
    case 9:
        return swap(glyphs, [
            firstGlyph,
            1
        ], [
            lastGlyph,
            2
        ], false, true);
    case 10:
        return swap(glyphs, [
            firstGlyph,
            2
        ], [
            lastGlyph,
            1
        ]);
    case 11:
        return swap(glyphs, [
            firstGlyph,
            2
        ], [
            lastGlyph,
            1
        ], true, false);
    case 12:
        return swap(glyphs, [
            firstGlyph,
            2
        ], [
            lastGlyph,
            2
        ]);
    case 13:
        return swap(glyphs, [
            firstGlyph,
            2
        ], [
            lastGlyph,
            2
        ], true, false);
    case 14:
        return swap(glyphs, [
            firstGlyph,
            2
        ], [
            lastGlyph,
            2
        ], false, true);
    case 15:
        return swap(glyphs, [
            firstGlyph,
            2
        ], [
            lastGlyph,
            2
        ], true, true);
    default:
        throw new Error('Unknown verb: ' + verb);
    }
}
var AATLayoutEngine = function () {
        function AATLayoutEngine(font) {
            _classCallCheck(this, AATLayoutEngine);
            this.font = font;
            this.morxProcessor = new AATMorxProcessor(font);
            this.fallbackPosition = false;
        }
        AATLayoutEngine.prototype.substitute = function substitute(glyphRun) {
            if (glyphRun.direction === 'rtl') {
                glyphRun.glyphs.reverse();
            }
            this.morxProcessor.process(glyphRun.glyphs, mapOTToAAT(glyphRun.features));
        };
        AATLayoutEngine.prototype.getAvailableFeatures = function getAvailableFeatures(script, language) {
            return mapAATToOT(this.morxProcessor.getSupportedFeatures());
        };
        AATLayoutEngine.prototype.stringsForGlyph = function stringsForGlyph(gid) {
            var glyphStrings = this.morxProcessor.generateInputs(gid);
            var result = new _Set();
            for (var _iterator = glyphStrings, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _getIterator(_iterator);;) {
                var _ref;
                if (_isArray) {
                    if (_i >= _iterator.length)
                        break;
                    _ref = _iterator[_i++];
                } else {
                    _i = _iterator.next();
                    if (_i.done)
                        break;
                    _ref = _i.value;
                }
                var glyphs = _ref;
                this._addStrings(glyphs, 0, result, '');
            }
            return result;
        };
        AATLayoutEngine.prototype._addStrings = function _addStrings(glyphs, index, strings, string) {
            var codePoints = this.font._cmapProcessor.codePointsForGlyph(glyphs[index]);
            for (var _iterator2 = codePoints, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _getIterator(_iterator2);;) {
                var _ref2;
                if (_isArray2) {
                    if (_i2 >= _iterator2.length)
                        break;
                    _ref2 = _iterator2[_i2++];
                } else {
                    _i2 = _iterator2.next();
                    if (_i2.done)
                        break;
                    _ref2 = _i2.value;
                }
                var codePoint = _ref2;
                var s = string + _String$fromCodePoint(codePoint);
                if (index < glyphs.length - 1) {
                    this._addStrings(glyphs, index + 1, strings, s);
                } else {
                    strings.add(s);
                }
            }
        };
        return AATLayoutEngine;
    }();
var ShapingPlan = function () {
        function ShapingPlan(font, script, direction) {
            _classCallCheck(this, ShapingPlan);
            this.font = font;
            this.script = script;
            this.direction = direction;
            this.stages = [];
            this.globalFeatures = {};
            this.allFeatures = {};
        }
        ShapingPlan.prototype._addFeatures = function _addFeatures(features, global) {
            var stageIndex = this.stages.length - 1;
            var stage = this.stages[stageIndex];
            for (var _iterator = features, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _getIterator(_iterator);;) {
                var _ref;
                if (_isArray) {
                    if (_i >= _iterator.length)
                        break;
                    _ref = _iterator[_i++];
                } else {
                    _i = _iterator.next();
                    if (_i.done)
                        break;
                    _ref = _i.value;
                }
                var feature = _ref;
                if (this.allFeatures[feature] == null) {
                    stage.push(feature);
                    this.allFeatures[feature] = stageIndex;
                    if (global) {
                        this.globalFeatures[feature] = true;
                    }
                }
            }
        };
        ShapingPlan.prototype.add = function add(arg) {
            var global = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
            if (this.stages.length === 0) {
                this.stages.push([]);
            }
            if (typeof arg === 'string') {
                arg = [arg];
            }
            if (Array.isArray(arg)) {
                this._addFeatures(arg, global);
            } else if ((typeof arg === 'undefined' ? 'undefined' : _typeof(arg)) === 'object') {
                this._addFeatures(arg.global || [], true);
                this._addFeatures(arg.local || [], false);
            } else {
                throw new Error('Unsupported argument to ShapingPlan#add');
            }
        };
        ShapingPlan.prototype.addStage = function addStage(arg, global) {
            if (typeof arg === 'function') {
                this.stages.push(arg, []);
            } else {
                this.stages.push([]);
                this.add(arg, global);
            }
        };
        ShapingPlan.prototype.setFeatureOverrides = function setFeatureOverrides(features) {
            if (Array.isArray(features)) {
                this.add(features);
            } else if ((typeof features === 'undefined' ? 'undefined' : _typeof(features)) === 'object') {
                for (var tag in features) {
                    if (features[tag]) {
                        this.add(tag);
                    } else if (this.allFeatures[tag] != null) {
                        var stage = this.stages[this.allFeatures[tag]];
                        stage.splice(stage.indexOf(tag), 1);
                        delete this.allFeatures[tag];
                        delete this.globalFeatures[tag];
                    }
                }
            }
        };
        ShapingPlan.prototype.assignGlobalFeatures = function assignGlobalFeatures(glyphs) {
            for (var _iterator2 = glyphs, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _getIterator(_iterator2);;) {
                var _ref2;
                if (_isArray2) {
                    if (_i2 >= _iterator2.length)
                        break;
                    _ref2 = _iterator2[_i2++];
                } else {
                    _i2 = _iterator2.next();
                    if (_i2.done)
                        break;
                    _ref2 = _i2.value;
                }
                var glyph = _ref2;
                for (var feature in this.globalFeatures) {
                    glyph.features[feature] = true;
                }
            }
        };
        ShapingPlan.prototype.process = function process(processor, glyphs, positions) {
            for (var _iterator3 = this.stages, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _getIterator(_iterator3);;) {
                var _ref3;
                if (_isArray3) {
                    if (_i3 >= _iterator3.length)
                        break;
                    _ref3 = _iterator3[_i3++];
                } else {
                    _i3 = _iterator3.next();
                    if (_i3.done)
                        break;
                    _ref3 = _i3.value;
                }
                var stage = _ref3;
                if (typeof stage === 'function') {
                    if (!positions) {
                        stage(this.font, glyphs, this);
                    }
                } else if (stage.length > 0) {
                    processor.applyFeatures(stage, glyphs, positions);
                }
            }
        };
        return ShapingPlan;
    }();
var _class$4;
var _temp;
var VARIATION_FEATURES = ['rvrn'];
var COMMON_FEATURES = [
        'ccmp',
        'locl',
        'rlig',
        'mark',
        'mkmk'
    ];
var FRACTIONAL_FEATURES = [
        'frac',
        'numr',
        'dnom'
    ];
var HORIZONTAL_FEATURES = [
        'calt',
        'clig',
        'liga',
        'rclt',
        'curs',
        'kern'
    ];
var DIRECTIONAL_FEATURES = {
        ltr: [
            'ltra',
            'ltrm'
        ],
        rtl: [
            'rtla',
            'rtlm'
        ]
    };
var DefaultShaper = (_temp = _class$4 = function () {
        function DefaultShaper() {
            _classCallCheck(this, DefaultShaper);
        }
        DefaultShaper.plan = function plan(_plan, glyphs, features) {
            this.planPreprocessing(_plan);
            this.planFeatures(_plan);
            this.planPostprocessing(_plan, features);
            _plan.assignGlobalFeatures(glyphs);
            this.assignFeatures(_plan, glyphs);
        };
        DefaultShaper.planPreprocessing = function planPreprocessing(plan) {
            plan.add({
                global: [].concat(VARIATION_FEATURES, DIRECTIONAL_FEATURES[plan.direction]),
                local: FRACTIONAL_FEATURES
            });
        };
        DefaultShaper.planFeatures = function planFeatures(plan) {
        };
        DefaultShaper.planPostprocessing = function planPostprocessing(plan, userFeatures) {
            plan.add([].concat(COMMON_FEATURES, HORIZONTAL_FEATURES));
            plan.setFeatureOverrides(userFeatures);
        };
        DefaultShaper.assignFeatures = function assignFeatures(plan, glyphs) {
            for (var i = 0; i < glyphs.length; i++) {
                var glyph = glyphs[i];
                if (glyph.codePoints[0] === 8260) {
                    var start = i;
                    var end = i + 1;
                    while (start > 0 && unicode.isDigit(glyphs[start - 1].codePoints[0])) {
                        glyphs[start - 1].features.numr = true;
                        glyphs[start - 1].features.frac = true;
                        start--;
                    }
                    while (end < glyphs.length && unicode.isDigit(glyphs[end].codePoints[0])) {
                        glyphs[end].features.dnom = true;
                        glyphs[end].features.frac = true;
                        end++;
                    }
                    glyph.features.frac = true;
                    i = end - 1;
                }
            }
        };
        return DefaultShaper;
    }(), _class$4.zeroMarkWidths = 'AFTER_GPOS', _temp);
var trie = new UnicodeTrie(Buffer('AAEQAAAAAAAAADGgAZUBav7t2CtPA0EUBeDZB00pin9AJZIEgyUEj0QhweDAgQOJxCBRBElQSBwSicLgkOAwnNKZ5GaY2c7uzj4o5yZfZrrbefbuIx2nSq3CGmzAWH/+K+UO7MIe7MMhHMMpnMMFXMIVXIt2t3CnP088iPqjqNN8e4Ij7Rle4LUH82rLm6i/92A+RERERERERERNmfz/89GDeRARERERzbN8ceps2Iwt9H0C9/AJ6yOlDkbTczcot5VSm8Pm1vcFWfb7+BKOLTuOd2UlTX4wGP85Eg953lWPFbnuN7PkjtLmalOWbNenkHOSa7T3KmR9MVTZ2zZkVj1kHa68MueVKH0R4zqQ44WEXLM8VjcWHP0PtKLfPzQnMtGn3W4QYf6qxFxceVI394r2xnV+1rih0fV1Vzf3fO1n3evL5J78ruvZ5ptX2Rwy92Tfb1wlEqut3U+sZ3HXOeJ7/zDrbyuP6+Zz0fqa6Nv3vhY7Yu1xWnGevmsvsUpTT/RYIe8waUH/rvHMWKFzLfN8L+rTfp645mfX7ftlnfDtYxN59w0=', 'base64'));
var FEATURES = [
        'isol',
        'fina',
        'fin2',
        'fin3',
        'medi',
        'med2',
        'init'
    ];
var ShapingClasses = {
        Non_Joining: 0,
        Left_Joining: 1,
        Right_Joining: 2,
        Dual_Joining: 3,
        Join_Causing: 3,
        ALAPH: 4,
        'DALATH RISH': 5,
        Transparent: 6
    };
var ISOL = 'isol';
var FINA = 'fina';
var FIN2 = 'fin2';
var FIN3 = 'fin3';
var MEDI = 'medi';
var MED2 = 'med2';
var INIT = 'init';
var NONE = null;
var STATE_TABLE = [
        [
            [
                NONE,
                NONE,
                0
            ],
            [
                NONE,
                ISOL,
                2
            ],
            [
                NONE,
                ISOL,
                1
            ],
            [
                NONE,
                ISOL,
                2
            ],
            [
                NONE,
                ISOL,
                1
            ],
            [
                NONE,
                ISOL,
                6
            ]
        ],
        [
            [
                NONE,
                NONE,
                0
            ],
            [
                NONE,
                ISOL,
                2
            ],
            [
                NONE,
                ISOL,
                1
            ],
            [
                NONE,
                ISOL,
                2
            ],
            [
                NONE,
                FIN2,
                5
            ],
            [
                NONE,
                ISOL,
                6
            ]
        ],
        [
            [
                NONE,
                NONE,
                0
            ],
            [
                NONE,
                ISOL,
                2
            ],
            [
                INIT,
                FINA,
                1
            ],
            [
                INIT,
                FINA,
                3
            ],
            [
                INIT,
                FINA,
                4
            ],
            [
                INIT,
                FINA,
                6
            ]
        ],
        [
            [
                NONE,
                NONE,
                0
            ],
            [
                NONE,
                ISOL,
                2
            ],
            [
                MEDI,
                FINA,
                1
            ],
            [
                MEDI,
                FINA,
                3
            ],
            [
                MEDI,
                FINA,
                4
            ],
            [
                MEDI,
                FINA,
                6
            ]
        ],
        [
            [
                NONE,
                NONE,
                0
            ],
            [
                NONE,
                ISOL,
                2
            ],
            [
                MED2,
                ISOL,
                1
            ],
            [
                MED2,
                ISOL,
                2
            ],
            [
                MED2,
                FIN2,
                5
            ],
            [
                MED2,
                ISOL,
                6
            ]
        ],
        [
            [
                NONE,
                NONE,
                0
            ],
            [
                NONE,
                ISOL,
                2
            ],
            [
                ISOL,
                ISOL,
                1
            ],
            [
                ISOL,
                ISOL,
                2
            ],
            [
                ISOL,
                FIN2,
                5
            ],
            [
                ISOL,
                ISOL,
                6
            ]
        ],
        [
            [
                NONE,
                NONE,
                0
            ],
            [
                NONE,
                ISOL,
                2
            ],
            [
                NONE,
                ISOL,
                1
            ],
            [
                NONE,
                ISOL,
                2
            ],
            [
                NONE,
                FIN3,
                5
            ],
            [
                NONE,
                ISOL,
                6
            ]
        ]
    ];
var ArabicShaper = function (_DefaultShaper) {
        _inherits(ArabicShaper, _DefaultShaper);
        function ArabicShaper() {
            _classCallCheck(this, ArabicShaper);
            return _possibleConstructorReturn(this, _DefaultShaper.apply(this, arguments));
        }
        ArabicShaper.planFeatures = function planFeatures(plan) {
            plan.add([
                'ccmp',
                'locl'
            ]);
            for (var i = 0; i < FEATURES.length; i++) {
                var feature = FEATURES[i];
                plan.addStage(feature, false);
            }
            plan.addStage('mset');
        };
        ArabicShaper.assignFeatures = function assignFeatures(plan, glyphs) {
            _DefaultShaper.assignFeatures.call(this, plan, glyphs);
            var prev = -1;
            var state = 0;
            var actions = [];
            for (var i = 0; i < glyphs.length; i++) {
                var curAction = void 0, prevAction = void 0;
                var glyph = glyphs[i];
                var type = getShapingClass(glyph.codePoints[0]);
                if (type === ShapingClasses.Transparent) {
                    actions[i] = NONE;
                    continue;
                }
                var _STATE_TABLE$state$ty = STATE_TABLE[state][type];
                prevAction = _STATE_TABLE$state$ty[0];
                curAction = _STATE_TABLE$state$ty[1];
                state = _STATE_TABLE$state$ty[2];
                if (prevAction !== NONE && prev !== -1) {
                    actions[prev] = prevAction;
                }
                actions[i] = curAction;
                prev = i;
            }
            for (var index = 0; index < glyphs.length; index++) {
                var feature = void 0;
                var glyph = glyphs[index];
                if (feature = actions[index]) {
                    glyph.features[feature] = true;
                }
            }
        };
        return ArabicShaper;
    }(DefaultShaper);
function getShapingClass(codePoint) {
    var res = trie.get(codePoint);
    if (res) {
        return res - 1;
    }
    var category = unicode.getCategory(codePoint);
    if (category === 'Mn' || category === 'Me' || category === 'Cf') {
        return ShapingClasses.Transparent;
    }
    return ShapingClasses.Non_Joining;
}
var GlyphIterator = function () {
        function GlyphIterator(glyphs, options) {
            _classCallCheck(this, GlyphIterator);
            this.glyphs = glyphs;
            this.reset(options);
        }
        GlyphIterator.prototype.reset = function reset() {
            var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
            var index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
            this.options = options;
            this.flags = options.flags || {};
            this.markAttachmentType = options.markAttachmentType || 0;
            this.index = index;
        };
        GlyphIterator.prototype.shouldIgnore = function shouldIgnore(glyph) {
            return this.flags.ignoreMarks && glyph.isMark || this.flags.ignoreBaseGlyphs && glyph.isBase || this.flags.ignoreLigatures && glyph.isLigature || this.markAttachmentType && glyph.isMark && glyph.markAttachmentType !== this.markAttachmentType;
        };
        GlyphIterator.prototype.move = function move(dir) {
            this.index += dir;
            while (0 <= this.index && this.index < this.glyphs.length && this.shouldIgnore(this.glyphs[this.index])) {
                this.index += dir;
            }
            if (0 > this.index || this.index >= this.glyphs.length) {
                return null;
            }
            return this.glyphs[this.index];
        };
        GlyphIterator.prototype.next = function next() {
            return this.move(+1);
        };
        GlyphIterator.prototype.prev = function prev() {
            return this.move(-1);
        };
        GlyphIterator.prototype.peek = function peek() {
            var count = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
            var idx = this.index;
            var res = this.increment(count);
            this.index = idx;
            return res;
        };
        GlyphIterator.prototype.peekIndex = function peekIndex() {
            var count = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
            var idx = this.index;
            this.increment(count);
            var res = this.index;
            this.index = idx;
            return res;
        };
        GlyphIterator.prototype.increment = function increment() {
            var count = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
            var dir = count < 0 ? -1 : 1;
            count = Math.abs(count);
            while (count--) {
                this.move(dir);
            }
            return this.glyphs[this.index];
        };
        _createClass(GlyphIterator, [{
                key: 'cur',
                get: function get() {
                    return this.glyphs[this.index] || null;
                }
            }]);
        return GlyphIterator;
    }();
var DEFAULT_SCRIPTS = [
        'DFLT',
        'dflt',
        'latn'
    ];
var OTProcessor = function () {
        function OTProcessor(font, table) {
            _classCallCheck(this, OTProcessor);
            this.font = font;
            this.table = table;
            this.script = null;
            this.scriptTag = null;
            this.language = null;
            this.languageTag = null;
            this.features = {};
            this.lookups = {};
            this.variationsIndex = font._variationProcessor ? this.findVariationsIndex(font._variationProcessor.normalizedCoords) : -1;
            this.selectScript();
            this.glyphs = [];
            this.positions = [];
            this.ligatureID = 1;
            this.currentFeature = null;
        }
        OTProcessor.prototype.findScript = function findScript(script) {
            if (this.table.scriptList == null) {
                return null;
            }
            if (!Array.isArray(script)) {
                script = [script];
            }
            for (var _iterator = script, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _getIterator(_iterator);;) {
                var _ref;
                if (_isArray) {
                    if (_i >= _iterator.length)
                        break;
                    _ref = _iterator[_i++];
                } else {
                    _i = _iterator.next();
                    if (_i.done)
                        break;
                    _ref = _i.value;
                }
                var s = _ref;
                for (var _iterator2 = this.table.scriptList, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _getIterator(_iterator2);;) {
                    var _ref2;
                    if (_isArray2) {
                        if (_i2 >= _iterator2.length)
                            break;
                        _ref2 = _iterator2[_i2++];
                    } else {
                        _i2 = _iterator2.next();
                        if (_i2.done)
                            break;
                        _ref2 = _i2.value;
                    }
                    var entry = _ref2;
                    if (entry.tag === s) {
                        return entry;
                    }
                }
            }
            return null;
        };
        OTProcessor.prototype.selectScript = function selectScript(script, language, direction$$) {
            var changed = false;
            var entry = void 0;
            if (!this.script || script !== this.scriptTag) {
                entry = this.findScript(script);
                if (!entry) {
                    entry = this.findScript(DEFAULT_SCRIPTS);
                }
                if (!entry) {
                    return this.scriptTag;
                }
                this.scriptTag = entry.tag;
                this.script = entry.script;
                this.language = null;
                this.languageTag = null;
                changed = true;
            }
            if (!direction$$ || direction$$ !== this.direction) {
                this.direction = direction$$ || direction(script);
            }
            if (language && language.length < 4) {
                language += ' '.repeat(4 - language.length);
            }
            if (!language || language !== this.languageTag) {
                this.language = null;
                for (var _iterator3 = this.script.langSysRecords, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _getIterator(_iterator3);;) {
                    var _ref3;
                    if (_isArray3) {
                        if (_i3 >= _iterator3.length)
                            break;
                        _ref3 = _iterator3[_i3++];
                    } else {
                        _i3 = _iterator3.next();
                        if (_i3.done)
                            break;
                        _ref3 = _i3.value;
                    }
                    var lang = _ref3;
                    if (lang.tag === language) {
                        this.language = lang.langSys;
                        this.languageTag = lang.tag;
                        break;
                    }
                }
                if (!this.language) {
                    this.language = this.script.defaultLangSys;
                    this.languageTag = null;
                }
                changed = true;
            }
            if (changed) {
                this.features = {};
                if (this.language) {
                    for (var _iterator4 = this.language.featureIndexes, _isArray4 = Array.isArray(_iterator4), _i4 = 0, _iterator4 = _isArray4 ? _iterator4 : _getIterator(_iterator4);;) {
                        var _ref4;
                        if (_isArray4) {
                            if (_i4 >= _iterator4.length)
                                break;
                            _ref4 = _iterator4[_i4++];
                        } else {
                            _i4 = _iterator4.next();
                            if (_i4.done)
                                break;
                            _ref4 = _i4.value;
                        }
                        var featureIndex = _ref4;
                        var record = this.table.featureList[featureIndex];
                        var substituteFeature = this.substituteFeatureForVariations(featureIndex);
                        this.features[record.tag] = substituteFeature || record.feature;
                    }
                }
            }
            return this.scriptTag;
        };
        OTProcessor.prototype.lookupsForFeatures = function lookupsForFeatures() {
            var userFeatures = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
            var exclude = arguments[1];
            var lookups = [];
            for (var _iterator5 = userFeatures, _isArray5 = Array.isArray(_iterator5), _i5 = 0, _iterator5 = _isArray5 ? _iterator5 : _getIterator(_iterator5);;) {
                var _ref5;
                if (_isArray5) {
                    if (_i5 >= _iterator5.length)
                        break;
                    _ref5 = _iterator5[_i5++];
                } else {
                    _i5 = _iterator5.next();
                    if (_i5.done)
                        break;
                    _ref5 = _i5.value;
                }
                var tag = _ref5;
                var feature = this.features[tag];
                if (!feature) {
                    continue;
                }
                for (var _iterator6 = feature.lookupListIndexes, _isArray6 = Array.isArray(_iterator6), _i6 = 0, _iterator6 = _isArray6 ? _iterator6 : _getIterator(_iterator6);;) {
                    var _ref6;
                    if (_isArray6) {
                        if (_i6 >= _iterator6.length)
                            break;
                        _ref6 = _iterator6[_i6++];
                    } else {
                        _i6 = _iterator6.next();
                        if (_i6.done)
                            break;
                        _ref6 = _i6.value;
                    }
                    var lookupIndex = _ref6;
                    if (exclude && exclude.indexOf(lookupIndex) !== -1) {
                        continue;
                    }
                    lookups.push({
                        feature: tag,
                        index: lookupIndex,
                        lookup: this.table.lookupList.get(lookupIndex)
                    });
                }
            }
            lookups.sort(function (a, b) {
                return a.index - b.index;
            });
            return lookups;
        };
        OTProcessor.prototype.substituteFeatureForVariations = function substituteFeatureForVariations(featureIndex) {
            if (this.variationsIndex === -1) {
                return null;
            }
            var record = this.table.featureVariations.featureVariationRecords[this.variationsIndex];
            var substitutions = record.featureTableSubstitution.substitutions;
            for (var _iterator7 = substitutions, _isArray7 = Array.isArray(_iterator7), _i7 = 0, _iterator7 = _isArray7 ? _iterator7 : _getIterator(_iterator7);;) {
                var _ref7;
                if (_isArray7) {
                    if (_i7 >= _iterator7.length)
                        break;
                    _ref7 = _iterator7[_i7++];
                } else {
                    _i7 = _iterator7.next();
                    if (_i7.done)
                        break;
                    _ref7 = _i7.value;
                }
                var substitution = _ref7;
                if (substitution.featureIndex === featureIndex) {
                    return substitution.alternateFeatureTable;
                }
            }
            return null;
        };
        OTProcessor.prototype.findVariationsIndex = function findVariationsIndex(coords) {
            var variations = this.table.featureVariations;
            if (!variations) {
                return -1;
            }
            var records = variations.featureVariationRecords;
            for (var i = 0; i < records.length; i++) {
                var conditions = records[i].conditionSet.conditionTable;
                if (this.variationConditionsMatch(conditions, coords)) {
                    return i;
                }
            }
            return -1;
        };
        OTProcessor.prototype.variationConditionsMatch = function variationConditionsMatch(conditions, coords) {
            return conditions.every(function (condition) {
                var coord = condition.axisIndex < coords.length ? coords[condition.axisIndex] : 0;
                return condition.filterRangeMinValue <= coord && coord <= condition.filterRangeMaxValue;
            });
        };
        OTProcessor.prototype.applyFeatures = function applyFeatures(userFeatures, glyphs, advances) {
            var lookups = this.lookupsForFeatures(userFeatures);
            this.applyLookups(lookups, glyphs, advances);
        };
        OTProcessor.prototype.applyLookups = function applyLookups(lookups, glyphs, positions) {
            this.glyphs = glyphs;
            this.positions = positions;
            this.glyphIterator = new GlyphIterator(glyphs);
            for (var _iterator8 = lookups, _isArray8 = Array.isArray(_iterator8), _i8 = 0, _iterator8 = _isArray8 ? _iterator8 : _getIterator(_iterator8);;) {
                var _ref8;
                if (_isArray8) {
                    if (_i8 >= _iterator8.length)
                        break;
                    _ref8 = _iterator8[_i8++];
                } else {
                    _i8 = _iterator8.next();
                    if (_i8.done)
                        break;
                    _ref8 = _i8.value;
                }
                var _ref9 = _ref8, feature = _ref9.feature, lookup = _ref9.lookup;
                this.currentFeature = feature;
                this.glyphIterator.reset(lookup.flags);
                while (this.glyphIterator.index < glyphs.length) {
                    if (!(feature in this.glyphIterator.cur.features)) {
                        this.glyphIterator.next();
                        continue;
                    }
                    for (var _iterator9 = lookup.subTables, _isArray9 = Array.isArray(_iterator9), _i9 = 0, _iterator9 = _isArray9 ? _iterator9 : _getIterator(_iterator9);;) {
                        var _ref10;
                        if (_isArray9) {
                            if (_i9 >= _iterator9.length)
                                break;
                            _ref10 = _iterator9[_i9++];
                        } else {
                            _i9 = _iterator9.next();
                            if (_i9.done)
                                break;
                            _ref10 = _i9.value;
                        }
                        var table = _ref10;
                        var res = this.applyLookup(lookup.lookupType, table);
                        if (res) {
                            break;
                        }
                    }
                    this.glyphIterator.next();
                }
            }
        };
        OTProcessor.prototype.applyLookup = function applyLookup(lookup, table) {
            throw new Error('applyLookup must be implemented by subclasses');
        };
        OTProcessor.prototype.applyLookupList = function applyLookupList(lookupRecords) {
            var options = this.glyphIterator.options;
            var glyphIndex = this.glyphIterator.index;
            for (var _iterator10 = lookupRecords, _isArray10 = Array.isArray(_iterator10), _i10 = 0, _iterator10 = _isArray10 ? _iterator10 : _getIterator(_iterator10);;) {
                var _ref11;
                if (_isArray10) {
                    if (_i10 >= _iterator10.length)
                        break;
                    _ref11 = _iterator10[_i10++];
                } else {
                    _i10 = _iterator10.next();
                    if (_i10.done)
                        break;
                    _ref11 = _i10.value;
                }
                var lookupRecord = _ref11;
                this.glyphIterator.reset(options, glyphIndex);
                this.glyphIterator.increment(lookupRecord.sequenceIndex);
                var lookup = this.table.lookupList.get(lookupRecord.lookupListIndex);
                this.glyphIterator.reset(lookup.flags, this.glyphIterator.index);
                for (var _iterator11 = lookup.subTables, _isArray11 = Array.isArray(_iterator11), _i11 = 0, _iterator11 = _isArray11 ? _iterator11 : _getIterator(_iterator11);;) {
                    var _ref12;
                    if (_isArray11) {
                        if (_i11 >= _iterator11.length)
                            break;
                        _ref12 = _iterator11[_i11++];
                    } else {
                        _i11 = _iterator11.next();
                        if (_i11.done)
                            break;
                        _ref12 = _i11.value;
                    }
                    var table = _ref12;
                    if (this.applyLookup(lookup.lookupType, table)) {
                        break;
                    }
                }
            }
            this.glyphIterator.reset(options, glyphIndex);
            return true;
        };
        OTProcessor.prototype.coverageIndex = function coverageIndex(coverage, glyph) {
            if (glyph == null) {
                glyph = this.glyphIterator.cur.id;
            }
            switch (coverage.version) {
            case 1:
                return coverage.glyphs.indexOf(glyph);
            case 2:
                for (var _iterator12 = coverage.rangeRecords, _isArray12 = Array.isArray(_iterator12), _i12 = 0, _iterator12 = _isArray12 ? _iterator12 : _getIterator(_iterator12);;) {
                    var _ref13;
                    if (_isArray12) {
                        if (_i12 >= _iterator12.length)
                            break;
                        _ref13 = _iterator12[_i12++];
                    } else {
                        _i12 = _iterator12.next();
                        if (_i12.done)
                            break;
                        _ref13 = _i12.value;
                    }
                    var range = _ref13;
                    if (range.start <= glyph && glyph <= range.end) {
                        return range.startCoverageIndex + glyph - range.start;
                    }
                }
                break;
            }
            return -1;
        };
        OTProcessor.prototype.match = function match(sequenceIndex, sequence, fn, matched) {
            var pos = this.glyphIterator.index;
            var glyph = this.glyphIterator.increment(sequenceIndex);
            var idx = 0;
            while (idx < sequence.length && glyph && fn(sequence[idx], glyph)) {
                if (matched) {
                    matched.push(this.glyphIterator.index);
                }
                idx++;
                glyph = this.glyphIterator.next();
            }
            this.glyphIterator.index = pos;
            if (idx < sequence.length) {
                return false;
            }
            return matched || true;
        };
        OTProcessor.prototype.sequenceMatches = function sequenceMatches(sequenceIndex, sequence) {
            return this.match(sequenceIndex, sequence, function (component, glyph) {
                return component === glyph.id;
            });
        };
        OTProcessor.prototype.sequenceMatchIndices = function sequenceMatchIndices(sequenceIndex, sequence) {
            var _this = this;
            return this.match(sequenceIndex, sequence, function (component, glyph) {
                if (!(_this.currentFeature in glyph.features)) {
                    return false;
                }
                return component === glyph.id;
            }, []);
        };
        OTProcessor.prototype.coverageSequenceMatches = function coverageSequenceMatches(sequenceIndex, sequence) {
            var _this2 = this;
            return this.match(sequenceIndex, sequence, function (coverage, glyph) {
                return _this2.coverageIndex(coverage, glyph.id) >= 0;
            });
        };
        OTProcessor.prototype.getClassID = function getClassID(glyph, classDef) {
            switch (classDef.version) {
            case 1:
                var i = glyph - classDef.startGlyph;
                if (i >= 0 && i < classDef.classValueArray.length) {
                    return classDef.classValueArray[i];
                }
                break;
            case 2:
                for (var _iterator13 = classDef.classRangeRecord, _isArray13 = Array.isArray(_iterator13), _i13 = 0, _iterator13 = _isArray13 ? _iterator13 : _getIterator(_iterator13);;) {
                    var _ref14;
                    if (_isArray13) {
                        if (_i13 >= _iterator13.length)
                            break;
                        _ref14 = _iterator13[_i13++];
                    } else {
                        _i13 = _iterator13.next();
                        if (_i13.done)
                            break;
                        _ref14 = _i13.value;
                    }
                    var range = _ref14;
                    if (range.start <= glyph && glyph <= range.end) {
                        return range.class;
                    }
                }
                break;
            }
            return 0;
        };
        OTProcessor.prototype.classSequenceMatches = function classSequenceMatches(sequenceIndex, sequence, classDef) {
            var _this3 = this;
            return this.match(sequenceIndex, sequence, function (classID, glyph) {
                return classID === _this3.getClassID(glyph.id, classDef);
            });
        };
        OTProcessor.prototype.applyContext = function applyContext(table) {
            switch (table.version) {
            case 1:
                var index = this.coverageIndex(table.coverage);
                if (index === -1) {
                    return false;
                }
                var set = table.ruleSets[index];
                for (var _iterator14 = set, _isArray14 = Array.isArray(_iterator14), _i14 = 0, _iterator14 = _isArray14 ? _iterator14 : _getIterator(_iterator14);;) {
                    var _ref15;
                    if (_isArray14) {
                        if (_i14 >= _iterator14.length)
                            break;
                        _ref15 = _iterator14[_i14++];
                    } else {
                        _i14 = _iterator14.next();
                        if (_i14.done)
                            break;
                        _ref15 = _i14.value;
                    }
                    var rule = _ref15;
                    if (this.sequenceMatches(1, rule.input)) {
                        return this.applyLookupList(rule.lookupRecords);
                    }
                }
                break;
            case 2:
                if (this.coverageIndex(table.coverage) === -1) {
                    return false;
                }
                index = this.getClassID(this.glyphIterator.cur.id, table.classDef);
                if (index === -1) {
                    return false;
                }
                set = table.classSet[index];
                for (var _iterator15 = set, _isArray15 = Array.isArray(_iterator15), _i15 = 0, _iterator15 = _isArray15 ? _iterator15 : _getIterator(_iterator15);;) {
                    var _ref16;
                    if (_isArray15) {
                        if (_i15 >= _iterator15.length)
                            break;
                        _ref16 = _iterator15[_i15++];
                    } else {
                        _i15 = _iterator15.next();
                        if (_i15.done)
                            break;
                        _ref16 = _i15.value;
                    }
                    var _rule = _ref16;
                    if (this.classSequenceMatches(1, _rule.classes, table.classDef)) {
                        return this.applyLookupList(_rule.lookupRecords);
                    }
                }
                break;
            case 3:
                if (this.coverageSequenceMatches(0, table.coverages)) {
                    return this.applyLookupList(table.lookupRecords);
                }
                break;
            }
            return false;
        };
        OTProcessor.prototype.applyChainingContext = function applyChainingContext(table) {
            switch (table.version) {
            case 1:
                var index = this.coverageIndex(table.coverage);
                if (index === -1) {
                    return false;
                }
                var set = table.chainRuleSets[index];
                for (var _iterator16 = set, _isArray16 = Array.isArray(_iterator16), _i16 = 0, _iterator16 = _isArray16 ? _iterator16 : _getIterator(_iterator16);;) {
                    var _ref17;
                    if (_isArray16) {
                        if (_i16 >= _iterator16.length)
                            break;
                        _ref17 = _iterator16[_i16++];
                    } else {
                        _i16 = _iterator16.next();
                        if (_i16.done)
                            break;
                        _ref17 = _i16.value;
                    }
                    var rule = _ref17;
                    if (this.sequenceMatches(-rule.backtrack.length, rule.backtrack) && this.sequenceMatches(1, rule.input) && this.sequenceMatches(1 + rule.input.length, rule.lookahead)) {
                        return this.applyLookupList(rule.lookupRecords);
                    }
                }
                break;
            case 2:
                if (this.coverageIndex(table.coverage) === -1) {
                    return false;
                }
                index = this.getClassID(this.glyphIterator.cur.id, table.inputClassDef);
                var rules = table.chainClassSet[index];
                if (!rules) {
                    return false;
                }
                for (var _iterator17 = rules, _isArray17 = Array.isArray(_iterator17), _i17 = 0, _iterator17 = _isArray17 ? _iterator17 : _getIterator(_iterator17);;) {
                    var _ref18;
                    if (_isArray17) {
                        if (_i17 >= _iterator17.length)
                            break;
                        _ref18 = _iterator17[_i17++];
                    } else {
                        _i17 = _iterator17.next();
                        if (_i17.done)
                            break;
                        _ref18 = _i17.value;
                    }
                    var _rule2 = _ref18;
                    if (this.classSequenceMatches(-_rule2.backtrack.length, _rule2.backtrack, table.backtrackClassDef) && this.classSequenceMatches(1, _rule2.input, table.inputClassDef) && this.classSequenceMatches(1 + _rule2.input.length, _rule2.lookahead, table.lookaheadClassDef)) {
                        return this.applyLookupList(_rule2.lookupRecords);
                    }
                }
                break;
            case 3:
                if (this.coverageSequenceMatches(-table.backtrackGlyphCount, table.backtrackCoverage) && this.coverageSequenceMatches(0, table.inputCoverage) && this.coverageSequenceMatches(table.inputGlyphCount, table.lookaheadCoverage)) {
                    return this.applyLookupList(table.lookupRecords);
                }
                break;
            }
            return false;
        };
        return OTProcessor;
    }();
var GlyphInfo = function () {
        function GlyphInfo(font, id) {
            var codePoints = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
            var features = arguments[3];
            _classCallCheck(this, GlyphInfo);
            this._font = font;
            this.codePoints = codePoints;
            this.id = id;
            this.features = {};
            if (Array.isArray(features)) {
                for (var i = 0; i < features.length; i++) {
                    var feature = features[i];
                    this.features[feature] = true;
                }
            } else if ((typeof features === 'undefined' ? 'undefined' : _typeof(features)) === 'object') {
                _Object$assign(this.features, features);
            }
            this.ligatureID = null;
            this.ligatureComponent = null;
            this.isLigated = false;
            this.cursiveAttachment = null;
            this.markAttachment = null;
            this.shaperInfo = null;
            this.substituted = false;
            this.isMultiplied = false;
        }
        GlyphInfo.prototype.copy = function copy() {
            return new GlyphInfo(this._font, this.id, this.codePoints, this.features);
        };
        _createClass(GlyphInfo, [{
                key: 'id',
                get: function get() {
                    return this._id;
                },
                set: function set(id) {
                    this._id = id;
                    this.substituted = true;
                    var GDEF = this._font.GDEF;
                    if (GDEF && GDEF.glyphClassDef) {
                        var classID = OTProcessor.prototype.getClassID(id, GDEF.glyphClassDef);
                        this.isBase = classID === 1;
                        this.isLigature = classID === 2;
                        this.isMark = classID === 3;
                        this.markAttachmentType = GDEF.markAttachClassDef ? OTProcessor.prototype.getClassID(id, GDEF.markAttachClassDef) : 0;
                    } else {
                        this.isMark = this.codePoints.length > 0 && this.codePoints.every(unicode.isMark);
                        this.isBase = !this.isMark;
                        this.isLigature = this.codePoints.length > 1;
                        this.markAttachmentType = 0;
                    }
                }
            }]);
        return GlyphInfo;
    }();
var _class$5;
var _temp$1;
var HangulShaper = (_temp$1 = _class$5 = function (_DefaultShaper) {
        _inherits(HangulShaper, _DefaultShaper);
        function HangulShaper() {
            _classCallCheck(this, HangulShaper);
            return _possibleConstructorReturn(this, _DefaultShaper.apply(this, arguments));
        }
        HangulShaper.planFeatures = function planFeatures(plan) {
            plan.add([
                'ljmo',
                'vjmo',
                'tjmo'
            ], false);
        };
        HangulShaper.assignFeatures = function assignFeatures(plan, glyphs) {
            var state = 0;
            var i = 0;
            while (i < glyphs.length) {
                var action = void 0;
                var glyph = glyphs[i];
                var code = glyph.codePoints[0];
                var type = getType(code);
                var _STATE_TABLE$state$ty = STATE_TABLE$1[state][type];
                action = _STATE_TABLE$state$ty[0];
                state = _STATE_TABLE$state$ty[1];
                switch (action) {
                case DECOMPOSE:
                    if (!plan.font.hasGlyphForCodePoint(code)) {
                        i = decompose(glyphs, i, plan.font);
                    }
                    break;
                case COMPOSE:
                    i = compose(glyphs, i, plan.font);
                    break;
                case TONE_MARK:
                    reorderToneMark(glyphs, i, plan.font);
                    break;
                case INVALID:
                    i = insertDottedCircle(glyphs, i, plan.font);
                    break;
                }
                i++;
            }
        };
        return HangulShaper;
    }(DefaultShaper), _class$5.zeroMarkWidths = 'NONE', _temp$1);
var HANGUL_BASE = 44032;
var HANGUL_END = 55204;
var HANGUL_COUNT = HANGUL_END - HANGUL_BASE + 1;
var L_BASE = 4352;
var V_BASE = 4449;
var T_BASE = 4519;
var L_COUNT = 19;
var V_COUNT = 21;
var T_COUNT = 28;
var L_END = L_BASE + L_COUNT - 1;
var V_END = V_BASE + V_COUNT - 1;
var T_END = T_BASE + T_COUNT - 1;
var DOTTED_CIRCLE = 9676;
var isL = function isL(code) {
    return 4352 <= code && code <= 4447 || 43360 <= code && code <= 43388;
};
var isV = function isV(code) {
    return 4448 <= code && code <= 4519 || 55216 <= code && code <= 55238;
};
var isT = function isT(code) {
    return 4520 <= code && code <= 4607 || 55243 <= code && code <= 55291;
};
var isTone = function isTone(code) {
    return 12334 <= code && code <= 12335;
};
var isLVT = function isLVT(code) {
    return HANGUL_BASE <= code && code <= HANGUL_END;
};
var isLV = function isLV(code) {
    return code - HANGUL_BASE < HANGUL_COUNT && (code - HANGUL_BASE) % T_COUNT === 0;
};
var isCombiningL = function isCombiningL(code) {
    return L_BASE <= code && code <= L_END;
};
var isCombiningV = function isCombiningV(code) {
    return V_BASE <= code && code <= V_END;
};
var isCombiningT = function isCombiningT(code) {
    return T_BASE + 1 && 1 <= code && code <= T_END;
};
var X = 0;
var L = 1;
var V = 2;
var T = 3;
var LV = 4;
var LVT = 5;
var M = 6;
function getType(code) {
    if (isL(code)) {
        return L;
    }
    if (isV(code)) {
        return V;
    }
    if (isT(code)) {
        return T;
    }
    if (isLV(code)) {
        return LV;
    }
    if (isLVT(code)) {
        return LVT;
    }
    if (isTone(code)) {
        return M;
    }
    return X;
}
var NO_ACTION = 0;
var DECOMPOSE = 1;
var COMPOSE = 2;
var TONE_MARK = 4;
var INVALID = 5;
var STATE_TABLE$1 = [
        [
            [
                NO_ACTION,
                0
            ],
            [
                NO_ACTION,
                1
            ],
            [
                NO_ACTION,
                0
            ],
            [
                NO_ACTION,
                0
            ],
            [
                DECOMPOSE,
                2
            ],
            [
                DECOMPOSE,
                3
            ],
            [
                INVALID,
                0
            ]
        ],
        [
            [
                NO_ACTION,
                0
            ],
            [
                NO_ACTION,
                1
            ],
            [
                COMPOSE,
                2
            ],
            [
                NO_ACTION,
                0
            ],
            [
                DECOMPOSE,
                2
            ],
            [
                DECOMPOSE,
                3
            ],
            [
                INVALID,
                0
            ]
        ],
        [
            [
                NO_ACTION,
                0
            ],
            [
                NO_ACTION,
                1
            ],
            [
                NO_ACTION,
                0
            ],
            [
                COMPOSE,
                3
            ],
            [
                DECOMPOSE,
                2
            ],
            [
                DECOMPOSE,
                3
            ],
            [
                TONE_MARK,
                0
            ]
        ],
        [
            [
                NO_ACTION,
                0
            ],
            [
                NO_ACTION,
                1
            ],
            [
                NO_ACTION,
                0
            ],
            [
                NO_ACTION,
                0
            ],
            [
                DECOMPOSE,
                2
            ],
            [
                DECOMPOSE,
                3
            ],
            [
                TONE_MARK,
                0
            ]
        ]
    ];
function getGlyph(font, code, features) {
    return new GlyphInfo(font, font.glyphForCodePoint(code).id, [code], features);
}
function decompose(glyphs, i, font) {
    var glyph = glyphs[i];
    var code = glyph.codePoints[0];
    var s = code - HANGUL_BASE;
    var t = T_BASE + s % T_COUNT;
    s = s / T_COUNT | 0;
    var l = L_BASE + s / V_COUNT | 0;
    var v = V_BASE + s % V_COUNT;
    if (!font.hasGlyphForCodePoint(l) || !font.hasGlyphForCodePoint(v) || t !== T_BASE && !font.hasGlyphForCodePoint(t)) {
        return i;
    }
    var ljmo = getGlyph(font, l, glyph.features);
    ljmo.features.ljmo = true;
    var vjmo = getGlyph(font, v, glyph.features);
    vjmo.features.vjmo = true;
    var insert = [
            ljmo,
            vjmo
        ];
    if (t > T_BASE) {
        var tjmo = getGlyph(font, t, glyph.features);
        tjmo.features.tjmo = true;
        insert.push(tjmo);
    }
    glyphs.splice.apply(glyphs, [
        i,
        1
    ].concat(insert));
    return i + insert.length - 1;
}
function compose(glyphs, i, font) {
    var glyph = glyphs[i];
    var code = glyphs[i].codePoints[0];
    var type = getType(code);
    var prev = glyphs[i - 1].codePoints[0];
    var prevType = getType(prev);
    var lv = void 0, ljmo = void 0, vjmo = void 0, tjmo = void 0;
    if (prevType === LV && type === T) {
        lv = prev;
        tjmo = glyph;
    } else {
        if (type === V) {
            ljmo = glyphs[i - 1];
            vjmo = glyph;
        } else {
            ljmo = glyphs[i - 2];
            vjmo = glyphs[i - 1];
            tjmo = glyph;
        }
        var l = ljmo.codePoints[0];
        var v = vjmo.codePoints[0];
        if (isCombiningL(l) && isCombiningV(v)) {
            lv = HANGUL_BASE + ((l - L_BASE) * V_COUNT + (v - V_BASE)) * T_COUNT;
        }
    }
    var t = tjmo && tjmo.codePoints[0] || T_BASE;
    if (lv != null && (t === T_BASE || isCombiningT(t))) {
        var s = lv + (t - T_BASE);
        if (font.hasGlyphForCodePoint(s)) {
            var del = prevType === V ? 3 : 2;
            glyphs.splice(i - del + 1, del, getGlyph(font, s, glyph.features));
            return i - del + 1;
        }
    }
    if (ljmo) {
        ljmo.features.ljmo = true;
    }
    if (vjmo) {
        vjmo.features.vjmo = true;
    }
    if (tjmo) {
        tjmo.features.tjmo = true;
    }
    if (prevType === LV) {
        decompose(glyphs, i - 1, font);
        return i + 1;
    }
    return i;
}
function getLength(code) {
    switch (getType(code)) {
    case LV:
    case LVT:
        return 1;
    case V:
        return 2;
    case T:
        return 3;
    }
}
function reorderToneMark(glyphs, i, font) {
    var glyph = glyphs[i];
    var code = glyphs[i].codePoints[0];
    if (font.glyphForCodePoint(code).advanceWidth === 0) {
        return;
    }
    var prev = glyphs[i - 1].codePoints[0];
    var len = getLength(prev);
    glyphs.splice(i, 1);
    return glyphs.splice(i - len, 0, glyph);
}
function insertDottedCircle(glyphs, i, font) {
    var glyph = glyphs[i];
    var code = glyphs[i].codePoints[0];
    if (font.hasGlyphForCodePoint(DOTTED_CIRCLE)) {
        var dottedCircle = getGlyph(font, DOTTED_CIRCLE, glyph.features);
        var idx = font.glyphForCodePoint(code).advanceWidth === 0 ? i : i + 1;
        glyphs.splice(idx, 0, dottedCircle);
        i++;
    }
    return i;
}
var stateTable = [
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            2,
            3,
            4,
            5,
            6,
            7,
            8,
            9,
            0,
            10,
            11,
            11,
            12,
            13,
            14,
            15,
            16,
            17
        ],
        [
            0,
            0,
            0,
            18,
            19,
            20,
            21,
            22,
            23,
            0,
            24,
            0,
            0,
            25,
            26,
            0,
            0,
            27,
            0
        ],
        [
            0,
            0,
            0,
            28,
            29,
            30,
            31,
            32,
            33,
            0,
            34,
            0,
            0,
            35,
            36,
            0,
            0,
            37,
            0
        ],
        [
            0,
            0,
            0,
            38,
            5,
            7,
            7,
            8,
            9,
            0,
            10,
            0,
            0,
            0,
            13,
            0,
            0,
            16,
            0
        ],
        [
            0,
            39,
            0,
            0,
            0,
            40,
            41,
            0,
            9,
            0,
            10,
            0,
            0,
            0,
            42,
            0,
            39,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            43,
            44,
            44,
            8,
            9,
            0,
            0,
            0,
            0,
            12,
            43,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            43,
            44,
            44,
            8,
            9,
            0,
            0,
            0,
            0,
            0,
            43,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            45,
            46,
            47,
            48,
            49,
            9,
            0,
            10,
            0,
            0,
            0,
            42,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            50,
            0,
            0,
            51,
            0,
            10,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            52,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            53,
            54,
            55,
            56,
            57,
            58,
            0,
            59,
            0,
            0,
            60,
            61,
            0,
            0,
            62,
            0
        ],
        [
            0,
            0,
            0,
            4,
            5,
            7,
            7,
            8,
            9,
            0,
            10,
            0,
            0,
            0,
            13,
            0,
            0,
            16,
            0
        ],
        [
            0,
            63,
            64,
            0,
            0,
            40,
            41,
            0,
            9,
            0,
            10,
            0,
            0,
            0,
            42,
            0,
            63,
            0,
            0
        ],
        [
            0,
            2,
            3,
            4,
            5,
            6,
            7,
            8,
            9,
            0,
            10,
            11,
            11,
            12,
            13,
            0,
            2,
            16,
            0
        ],
        [
            0,
            0,
            0,
            18,
            65,
            20,
            21,
            22,
            23,
            0,
            24,
            0,
            0,
            25,
            26,
            0,
            0,
            27,
            0
        ],
        [
            0,
            0,
            0,
            0,
            66,
            67,
            67,
            8,
            9,
            0,
            10,
            0,
            0,
            0,
            68,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            69,
            0,
            70,
            70,
            0,
            71,
            0,
            72,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            73,
            19,
            74,
            74,
            22,
            23,
            0,
            24,
            0,
            0,
            0,
            26,
            0,
            0,
            27,
            0
        ],
        [
            0,
            75,
            0,
            0,
            0,
            76,
            77,
            0,
            23,
            0,
            24,
            0,
            0,
            0,
            78,
            0,
            75,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            79,
            80,
            80,
            22,
            23,
            0,
            0,
            0,
            0,
            25,
            79,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            18,
            19,
            20,
            74,
            22,
            23,
            0,
            24,
            0,
            0,
            25,
            26,
            0,
            0,
            27,
            0
        ],
        [
            0,
            0,
            0,
            81,
            82,
            83,
            84,
            85,
            23,
            0,
            24,
            0,
            0,
            0,
            78,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            86,
            0,
            0,
            87,
            0,
            24,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            88,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            18,
            19,
            74,
            74,
            22,
            23,
            0,
            24,
            0,
            0,
            0,
            26,
            0,
            0,
            27,
            0
        ],
        [
            0,
            89,
            90,
            0,
            0,
            76,
            77,
            0,
            23,
            0,
            24,
            0,
            0,
            0,
            78,
            0,
            89,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            91,
            92,
            92,
            22,
            23,
            0,
            24,
            0,
            0,
            0,
            93,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            94,
            29,
            95,
            31,
            32,
            33,
            0,
            34,
            0,
            0,
            0,
            36,
            0,
            0,
            37,
            0
        ],
        [
            0,
            96,
            0,
            0,
            0,
            97,
            98,
            0,
            33,
            0,
            34,
            0,
            0,
            0,
            99,
            0,
            96,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            100,
            101,
            101,
            32,
            33,
            0,
            0,
            0,
            0,
            35,
            100,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            100,
            101,
            101,
            32,
            33,
            0,
            0,
            0,
            0,
            0,
            100,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            102,
            103,
            104,
            105,
            106,
            33,
            0,
            34,
            0,
            0,
            0,
            99,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            107,
            0,
            0,
            108,
            0,
            34,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            109,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            28,
            29,
            95,
            31,
            32,
            33,
            0,
            34,
            0,
            0,
            0,
            36,
            0,
            0,
            37,
            0
        ],
        [
            0,
            110,
            111,
            0,
            0,
            97,
            98,
            0,
            33,
            0,
            34,
            0,
            0,
            0,
            99,
            0,
            110,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            112,
            113,
            113,
            32,
            33,
            0,
            34,
            0,
            0,
            0,
            114,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            5,
            7,
            7,
            8,
            9,
            0,
            10,
            0,
            0,
            0,
            13,
            0,
            0,
            16,
            0
        ],
        [
            0,
            0,
            0,
            115,
            116,
            117,
            118,
            8,
            9,
            0,
            10,
            0,
            0,
            119,
            120,
            0,
            0,
            16,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            121,
            121,
            0,
            9,
            0,
            10,
            0,
            0,
            0,
            42,
            0,
            0,
            0,
            0
        ],
        [
            0,
            39,
            0,
            122,
            0,
            123,
            123,
            8,
            9,
            0,
            10,
            0,
            0,
            0,
            42,
            0,
            39,
            0,
            0
        ],
        [
            0,
            124,
            64,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            124,
            0,
            0
        ],
        [
            0,
            39,
            0,
            0,
            0,
            121,
            125,
            0,
            9,
            0,
            10,
            0,
            0,
            0,
            42,
            0,
            39,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            126,
            126,
            8,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            46,
            47,
            48,
            49,
            9,
            0,
            10,
            0,
            0,
            0,
            42,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            47,
            47,
            49,
            9,
            0,
            10,
            0,
            0,
            0,
            42,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            127,
            127,
            49,
            9,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            128,
            127,
            127,
            49,
            9,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            129,
            130,
            131,
            132,
            133,
            9,
            0,
            10,
            0,
            0,
            0,
            42,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            10,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            50,
            0,
            0,
            0,
            0,
            10,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            134,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            135,
            54,
            56,
            56,
            57,
            58,
            0,
            59,
            0,
            0,
            0,
            61,
            0,
            0,
            62,
            0
        ],
        [
            0,
            136,
            0,
            0,
            0,
            137,
            138,
            0,
            58,
            0,
            59,
            0,
            0,
            0,
            139,
            0,
            136,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            140,
            141,
            141,
            57,
            58,
            0,
            0,
            0,
            0,
            60,
            140,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            140,
            141,
            141,
            57,
            58,
            0,
            0,
            0,
            0,
            0,
            140,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            142,
            143,
            144,
            145,
            146,
            58,
            0,
            59,
            0,
            0,
            0,
            139,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            147,
            0,
            0,
            148,
            0,
            59,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            149,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            53,
            54,
            56,
            56,
            57,
            58,
            0,
            59,
            0,
            0,
            0,
            61,
            0,
            0,
            62,
            0
        ],
        [
            0,
            150,
            151,
            0,
            0,
            137,
            138,
            0,
            58,
            0,
            59,
            0,
            0,
            0,
            139,
            0,
            150,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            152,
            153,
            153,
            57,
            58,
            0,
            59,
            0,
            0,
            0,
            154,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            155,
            116,
            156,
            157,
            8,
            9,
            0,
            10,
            0,
            0,
            158,
            120,
            0,
            0,
            16,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            121,
            121,
            0,
            9,
            0,
            10,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            75,
            3,
            4,
            5,
            159,
            160,
            8,
            161,
            0,
            162,
            0,
            11,
            12,
            163,
            0,
            75,
            16,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            40,
            164,
            0,
            9,
            0,
            10,
            0,
            0,
            0,
            42,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            165,
            44,
            44,
            8,
            9,
            0,
            0,
            0,
            0,
            0,
            165,
            0,
            0,
            0,
            0
        ],
        [
            0,
            124,
            64,
            0,
            0,
            40,
            164,
            0,
            9,
            0,
            10,
            0,
            0,
            0,
            42,
            0,
            124,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            70,
            70,
            0,
            71,
            0,
            72,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            71,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            166,
            0,
            0,
            167,
            0,
            72,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            168,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            19,
            74,
            74,
            22,
            23,
            0,
            24,
            0,
            0,
            0,
            26,
            0,
            0,
            27,
            0
        ],
        [
            0,
            0,
            0,
            0,
            79,
            80,
            80,
            22,
            23,
            0,
            0,
            0,
            0,
            0,
            79,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            169,
            170,
            171,
            172,
            22,
            23,
            0,
            24,
            0,
            0,
            173,
            174,
            0,
            0,
            27,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            175,
            175,
            0,
            23,
            0,
            24,
            0,
            0,
            0,
            78,
            0,
            0,
            0,
            0
        ],
        [
            0,
            75,
            0,
            176,
            0,
            177,
            177,
            22,
            23,
            0,
            24,
            0,
            0,
            0,
            78,
            0,
            75,
            0,
            0
        ],
        [
            0,
            178,
            90,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            178,
            0,
            0
        ],
        [
            0,
            75,
            0,
            0,
            0,
            175,
            179,
            0,
            23,
            0,
            24,
            0,
            0,
            0,
            78,
            0,
            75,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            180,
            180,
            22,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            82,
            83,
            84,
            85,
            23,
            0,
            24,
            0,
            0,
            0,
            78,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            83,
            83,
            85,
            23,
            0,
            24,
            0,
            0,
            0,
            78,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            181,
            181,
            85,
            23,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            182,
            181,
            181,
            85,
            23,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            183,
            184,
            185,
            186,
            187,
            23,
            0,
            24,
            0,
            0,
            0,
            78,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            24,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            86,
            0,
            0,
            0,
            0,
            24,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            188,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            189,
            170,
            190,
            191,
            22,
            23,
            0,
            24,
            0,
            0,
            192,
            174,
            0,
            0,
            27,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            175,
            175,
            0,
            23,
            0,
            24,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            76,
            193,
            0,
            23,
            0,
            24,
            0,
            0,
            0,
            78,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            194,
            80,
            80,
            22,
            23,
            0,
            0,
            0,
            0,
            0,
            194,
            0,
            0,
            0,
            0
        ],
        [
            0,
            178,
            90,
            0,
            0,
            76,
            193,
            0,
            23,
            0,
            24,
            0,
            0,
            0,
            78,
            0,
            178,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            29,
            95,
            31,
            32,
            33,
            0,
            34,
            0,
            0,
            0,
            36,
            0,
            0,
            37,
            0
        ],
        [
            0,
            0,
            0,
            0,
            100,
            101,
            101,
            32,
            33,
            0,
            0,
            0,
            0,
            0,
            100,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            195,
            196,
            197,
            198,
            32,
            33,
            0,
            34,
            0,
            0,
            199,
            200,
            0,
            0,
            37,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            201,
            201,
            0,
            33,
            0,
            34,
            0,
            0,
            0,
            99,
            0,
            0,
            0,
            0
        ],
        [
            0,
            96,
            0,
            202,
            0,
            203,
            203,
            32,
            33,
            0,
            34,
            0,
            0,
            0,
            99,
            0,
            96,
            0,
            0
        ],
        [
            0,
            204,
            111,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            204,
            0,
            0
        ],
        [
            0,
            96,
            0,
            0,
            0,
            201,
            205,
            0,
            33,
            0,
            34,
            0,
            0,
            0,
            99,
            0,
            96,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            206,
            206,
            32,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            103,
            104,
            105,
            106,
            33,
            0,
            34,
            0,
            0,
            0,
            99,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            104,
            104,
            106,
            33,
            0,
            34,
            0,
            0,
            0,
            99,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            207,
            207,
            106,
            33,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            208,
            207,
            207,
            106,
            33,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            209,
            210,
            211,
            212,
            213,
            33,
            0,
            34,
            0,
            0,
            0,
            99,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            34,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            107,
            0,
            0,
            0,
            0,
            34,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            214,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            215,
            196,
            216,
            217,
            32,
            33,
            0,
            34,
            0,
            0,
            218,
            200,
            0,
            0,
            37,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            201,
            201,
            0,
            33,
            0,
            34,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            97,
            219,
            0,
            33,
            0,
            34,
            0,
            0,
            0,
            99,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            220,
            101,
            101,
            32,
            33,
            0,
            0,
            0,
            0,
            0,
            220,
            0,
            0,
            0,
            0
        ],
        [
            0,
            204,
            111,
            0,
            0,
            97,
            219,
            0,
            33,
            0,
            34,
            0,
            0,
            0,
            99,
            0,
            204,
            0,
            0
        ],
        [
            0,
            0,
            0,
            221,
            116,
            222,
            222,
            8,
            9,
            0,
            10,
            0,
            0,
            0,
            120,
            0,
            0,
            16,
            0
        ],
        [
            0,
            223,
            0,
            0,
            0,
            40,
            224,
            0,
            9,
            0,
            10,
            0,
            0,
            0,
            42,
            0,
            223,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            225,
            44,
            44,
            8,
            9,
            0,
            0,
            0,
            0,
            119,
            225,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            115,
            116,
            117,
            222,
            8,
            9,
            0,
            10,
            0,
            0,
            119,
            120,
            0,
            0,
            16,
            0
        ],
        [
            0,
            0,
            0,
            115,
            116,
            222,
            222,
            8,
            9,
            0,
            10,
            0,
            0,
            0,
            120,
            0,
            0,
            16,
            0
        ],
        [
            0,
            226,
            64,
            0,
            0,
            40,
            224,
            0,
            9,
            0,
            10,
            0,
            0,
            0,
            42,
            0,
            226,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            9,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            39,
            0,
            0,
            0,
            121,
            121,
            0,
            9,
            0,
            10,
            0,
            0,
            0,
            42,
            0,
            39,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            44,
            44,
            8,
            9,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            227,
            0,
            228,
            229,
            0,
            9,
            0,
            10,
            0,
            0,
            230,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            39,
            0,
            122,
            0,
            121,
            121,
            0,
            9,
            0,
            10,
            0,
            0,
            0,
            42,
            0,
            39,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            8,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            231,
            231,
            49,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            232,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            130,
            131,
            132,
            133,
            9,
            0,
            10,
            0,
            0,
            0,
            42,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            131,
            131,
            133,
            9,
            0,
            10,
            0,
            0,
            0,
            42,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            233,
            233,
            133,
            9,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            234,
            233,
            233,
            133,
            9,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            235,
            236,
            237,
            238,
            239,
            9,
            0,
            10,
            0,
            0,
            0,
            42,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            54,
            56,
            56,
            57,
            58,
            0,
            59,
            0,
            0,
            0,
            61,
            0,
            0,
            62,
            0
        ],
        [
            0,
            0,
            0,
            240,
            241,
            242,
            243,
            57,
            58,
            0,
            59,
            0,
            0,
            244,
            245,
            0,
            0,
            62,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            246,
            246,
            0,
            58,
            0,
            59,
            0,
            0,
            0,
            139,
            0,
            0,
            0,
            0
        ],
        [
            0,
            136,
            0,
            247,
            0,
            248,
            248,
            57,
            58,
            0,
            59,
            0,
            0,
            0,
            139,
            0,
            136,
            0,
            0
        ],
        [
            0,
            249,
            151,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            249,
            0,
            0
        ],
        [
            0,
            136,
            0,
            0,
            0,
            246,
            250,
            0,
            58,
            0,
            59,
            0,
            0,
            0,
            139,
            0,
            136,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            251,
            251,
            57,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            143,
            144,
            145,
            146,
            58,
            0,
            59,
            0,
            0,
            0,
            139,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            144,
            144,
            146,
            58,
            0,
            59,
            0,
            0,
            0,
            139,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            252,
            252,
            146,
            58,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            253,
            252,
            252,
            146,
            58,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            254,
            255,
            256,
            257,
            258,
            58,
            0,
            59,
            0,
            0,
            0,
            139,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            59,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            147,
            0,
            0,
            0,
            0,
            59,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            259,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            260,
            241,
            261,
            262,
            57,
            58,
            0,
            59,
            0,
            0,
            263,
            245,
            0,
            0,
            62,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            246,
            246,
            0,
            58,
            0,
            59,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            137,
            264,
            0,
            58,
            0,
            59,
            0,
            0,
            0,
            139,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            265,
            141,
            141,
            57,
            58,
            0,
            0,
            0,
            0,
            0,
            265,
            0,
            0,
            0,
            0
        ],
        [
            0,
            249,
            151,
            0,
            0,
            137,
            264,
            0,
            58,
            0,
            59,
            0,
            0,
            0,
            139,
            0,
            249,
            0,
            0
        ],
        [
            0,
            0,
            0,
            221,
            116,
            222,
            222,
            8,
            9,
            0,
            10,
            0,
            0,
            0,
            120,
            0,
            0,
            16,
            0
        ],
        [
            0,
            0,
            0,
            0,
            225,
            44,
            44,
            8,
            9,
            0,
            0,
            0,
            0,
            158,
            225,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            155,
            116,
            156,
            222,
            8,
            9,
            0,
            10,
            0,
            0,
            158,
            120,
            0,
            0,
            16,
            0
        ],
        [
            0,
            0,
            0,
            155,
            116,
            222,
            222,
            8,
            9,
            0,
            10,
            0,
            0,
            0,
            120,
            0,
            0,
            16,
            0
        ],
        [
            0,
            0,
            0,
            0,
            43,
            266,
            266,
            8,
            161,
            0,
            24,
            0,
            0,
            12,
            267,
            0,
            0,
            0,
            0
        ],
        [
            0,
            75,
            0,
            176,
            43,
            268,
            268,
            269,
            161,
            0,
            24,
            0,
            0,
            0,
            267,
            0,
            75,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            270,
            0,
            0,
            271,
            0,
            162,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            272,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            273,
            274,
            0,
            0,
            40,
            41,
            0,
            9,
            0,
            10,
            0,
            0,
            0,
            42,
            0,
            273,
            0,
            0
        ],
        [
            0,
            0,
            0,
            40,
            0,
            123,
            123,
            8,
            9,
            0,
            10,
            0,
            0,
            0,
            42,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            121,
            275,
            0,
            9,
            0,
            10,
            0,
            0,
            0,
            42,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            72,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            166,
            0,
            0,
            0,
            0,
            72,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            276,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            277,
            170,
            278,
            278,
            22,
            23,
            0,
            24,
            0,
            0,
            0,
            174,
            0,
            0,
            27,
            0
        ],
        [
            0,
            279,
            0,
            0,
            0,
            76,
            280,
            0,
            23,
            0,
            24,
            0,
            0,
            0,
            78,
            0,
            279,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            281,
            80,
            80,
            22,
            23,
            0,
            0,
            0,
            0,
            173,
            281,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            169,
            170,
            171,
            278,
            22,
            23,
            0,
            24,
            0,
            0,
            173,
            174,
            0,
            0,
            27,
            0
        ],
        [
            0,
            0,
            0,
            169,
            170,
            278,
            278,
            22,
            23,
            0,
            24,
            0,
            0,
            0,
            174,
            0,
            0,
            27,
            0
        ],
        [
            0,
            282,
            90,
            0,
            0,
            76,
            280,
            0,
            23,
            0,
            24,
            0,
            0,
            0,
            78,
            0,
            282,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            23,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            75,
            0,
            0,
            0,
            175,
            175,
            0,
            23,
            0,
            24,
            0,
            0,
            0,
            78,
            0,
            75,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            80,
            80,
            22,
            23,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            283,
            0,
            284,
            285,
            0,
            23,
            0,
            24,
            0,
            0,
            286,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            75,
            0,
            176,
            0,
            175,
            175,
            0,
            23,
            0,
            24,
            0,
            0,
            0,
            78,
            0,
            75,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            22,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            287,
            287,
            85,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            288,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            184,
            185,
            186,
            187,
            23,
            0,
            24,
            0,
            0,
            0,
            78,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            185,
            185,
            187,
            23,
            0,
            24,
            0,
            0,
            0,
            78,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            289,
            289,
            187,
            23,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            290,
            289,
            289,
            187,
            23,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            291,
            292,
            293,
            294,
            295,
            23,
            0,
            24,
            0,
            0,
            0,
            78,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            277,
            170,
            278,
            278,
            22,
            23,
            0,
            24,
            0,
            0,
            0,
            174,
            0,
            0,
            27,
            0
        ],
        [
            0,
            0,
            0,
            0,
            281,
            80,
            80,
            22,
            23,
            0,
            0,
            0,
            0,
            192,
            281,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            189,
            170,
            190,
            278,
            22,
            23,
            0,
            24,
            0,
            0,
            192,
            174,
            0,
            0,
            27,
            0
        ],
        [
            0,
            0,
            0,
            189,
            170,
            278,
            278,
            22,
            23,
            0,
            24,
            0,
            0,
            0,
            174,
            0,
            0,
            27,
            0
        ],
        [
            0,
            0,
            0,
            76,
            0,
            177,
            177,
            22,
            23,
            0,
            24,
            0,
            0,
            0,
            78,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            175,
            296,
            0,
            23,
            0,
            24,
            0,
            0,
            0,
            78,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            297,
            196,
            298,
            298,
            32,
            33,
            0,
            34,
            0,
            0,
            0,
            200,
            0,
            0,
            37,
            0
        ],
        [
            0,
            299,
            0,
            0,
            0,
            97,
            300,
            0,
            33,
            0,
            34,
            0,
            0,
            0,
            99,
            0,
            299,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            301,
            101,
            101,
            32,
            33,
            0,
            0,
            0,
            0,
            199,
            301,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            195,
            196,
            197,
            298,
            32,
            33,
            0,
            34,
            0,
            0,
            199,
            200,
            0,
            0,
            37,
            0
        ],
        [
            0,
            0,
            0,
            195,
            196,
            298,
            298,
            32,
            33,
            0,
            34,
            0,
            0,
            0,
            200,
            0,
            0,
            37,
            0
        ],
        [
            0,
            302,
            111,
            0,
            0,
            97,
            300,
            0,
            33,
            0,
            34,
            0,
            0,
            0,
            99,
            0,
            302,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            33,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            96,
            0,
            0,
            0,
            201,
            201,
            0,
            33,
            0,
            34,
            0,
            0,
            0,
            99,
            0,
            96,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            101,
            101,
            32,
            33,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            303,
            0,
            304,
            305,
            0,
            33,
            0,
            34,
            0,
            0,
            306,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            96,
            0,
            202,
            0,
            201,
            201,
            0,
            33,
            0,
            34,
            0,
            0,
            0,
            99,
            0,
            96,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            32,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            307,
            307,
            106,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            308,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            210,
            211,
            212,
            213,
            33,
            0,
            34,
            0,
            0,
            0,
            99,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            211,
            211,
            213,
            33,
            0,
            34,
            0,
            0,
            0,
            99,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            309,
            309,
            213,
            33,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            310,
            309,
            309,
            213,
            33,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            311,
            312,
            313,
            314,
            315,
            33,
            0,
            34,
            0,
            0,
            0,
            99,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            297,
            196,
            298,
            298,
            32,
            33,
            0,
            34,
            0,
            0,
            0,
            200,
            0,
            0,
            37,
            0
        ],
        [
            0,
            0,
            0,
            0,
            301,
            101,
            101,
            32,
            33,
            0,
            0,
            0,
            0,
            218,
            301,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            215,
            196,
            216,
            298,
            32,
            33,
            0,
            34,
            0,
            0,
            218,
            200,
            0,
            0,
            37,
            0
        ],
        [
            0,
            0,
            0,
            215,
            196,
            298,
            298,
            32,
            33,
            0,
            34,
            0,
            0,
            0,
            200,
            0,
            0,
            37,
            0
        ],
        [
            0,
            0,
            0,
            97,
            0,
            203,
            203,
            32,
            33,
            0,
            34,
            0,
            0,
            0,
            99,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            201,
            316,
            0,
            33,
            0,
            34,
            0,
            0,
            0,
            99,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            116,
            222,
            222,
            8,
            9,
            0,
            10,
            0,
            0,
            0,
            120,
            0,
            0,
            16,
            0
        ],
        [
            0,
            0,
            0,
            0,
            225,
            44,
            44,
            8,
            9,
            0,
            0,
            0,
            0,
            0,
            225,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            317,
            318,
            319,
            320,
            8,
            9,
            0,
            10,
            0,
            0,
            321,
            322,
            0,
            0,
            16,
            0
        ],
        [
            0,
            223,
            0,
            323,
            0,
            123,
            123,
            8,
            9,
            0,
            10,
            0,
            0,
            0,
            42,
            0,
            223,
            0,
            0
        ],
        [
            0,
            223,
            0,
            0,
            0,
            121,
            324,
            0,
            9,
            0,
            10,
            0,
            0,
            0,
            42,
            0,
            223,
            0,
            0
        ],
        [
            0,
            0,
            0,
            325,
            318,
            326,
            327,
            8,
            9,
            0,
            10,
            0,
            0,
            328,
            322,
            0,
            0,
            16,
            0
        ],
        [
            0,
            0,
            0,
            64,
            0,
            121,
            121,
            0,
            9,
            0,
            10,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            9,
            0,
            0,
            0,
            0,
            230,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            227,
            0,
            228,
            121,
            0,
            9,
            0,
            10,
            0,
            0,
            230,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            227,
            0,
            121,
            121,
            0,
            9,
            0,
            10,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            49,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            46,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            329,
            329,
            133,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            330,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            236,
            237,
            238,
            239,
            9,
            0,
            10,
            0,
            0,
            0,
            42,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            237,
            237,
            239,
            9,
            0,
            10,
            0,
            0,
            0,
            42,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            331,
            331,
            239,
            9,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            332,
            331,
            331,
            239,
            9,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            333,
            40,
            121,
            334,
            0,
            9,
            0,
            10,
            0,
            0,
            0,
            42,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            335,
            241,
            336,
            336,
            57,
            58,
            0,
            59,
            0,
            0,
            0,
            245,
            0,
            0,
            62,
            0
        ],
        [
            0,
            337,
            0,
            0,
            0,
            137,
            338,
            0,
            58,
            0,
            59,
            0,
            0,
            0,
            139,
            0,
            337,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            339,
            141,
            141,
            57,
            58,
            0,
            0,
            0,
            0,
            244,
            339,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            240,
            241,
            242,
            336,
            57,
            58,
            0,
            59,
            0,
            0,
            244,
            245,
            0,
            0,
            62,
            0
        ],
        [
            0,
            0,
            0,
            240,
            241,
            336,
            336,
            57,
            58,
            0,
            59,
            0,
            0,
            0,
            245,
            0,
            0,
            62,
            0
        ],
        [
            0,
            340,
            151,
            0,
            0,
            137,
            338,
            0,
            58,
            0,
            59,
            0,
            0,
            0,
            139,
            0,
            340,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            58,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            136,
            0,
            0,
            0,
            246,
            246,
            0,
            58,
            0,
            59,
            0,
            0,
            0,
            139,
            0,
            136,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            141,
            141,
            57,
            58,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            341,
            0,
            342,
            343,
            0,
            58,
            0,
            59,
            0,
            0,
            344,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            136,
            0,
            247,
            0,
            246,
            246,
            0,
            58,
            0,
            59,
            0,
            0,
            0,
            139,
            0,
            136,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            57,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            345,
            345,
            146,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            346,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            255,
            256,
            257,
            258,
            58,
            0,
            59,
            0,
            0,
            0,
            139,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            256,
            256,
            258,
            58,
            0,
            59,
            0,
            0,
            0,
            139,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            347,
            347,
            258,
            58,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            348,
            347,
            347,
            258,
            58,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            349,
            350,
            351,
            352,
            353,
            58,
            0,
            59,
            0,
            0,
            0,
            139,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            335,
            241,
            336,
            336,
            57,
            58,
            0,
            59,
            0,
            0,
            0,
            245,
            0,
            0,
            62,
            0
        ],
        [
            0,
            0,
            0,
            0,
            339,
            141,
            141,
            57,
            58,
            0,
            0,
            0,
            0,
            263,
            339,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            260,
            241,
            261,
            336,
            57,
            58,
            0,
            59,
            0,
            0,
            263,
            245,
            0,
            0,
            62,
            0
        ],
        [
            0,
            0,
            0,
            260,
            241,
            336,
            336,
            57,
            58,
            0,
            59,
            0,
            0,
            0,
            245,
            0,
            0,
            62,
            0
        ],
        [
            0,
            0,
            0,
            137,
            0,
            248,
            248,
            57,
            58,
            0,
            59,
            0,
            0,
            0,
            139,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            246,
            354,
            0,
            58,
            0,
            59,
            0,
            0,
            0,
            139,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            126,
            126,
            8,
            23,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            355,
            90,
            0,
            0,
            121,
            125,
            0,
            9,
            0,
            10,
            0,
            0,
            0,
            42,
            0,
            355,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            356,
            356,
            269,
            23,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            357,
            358,
            359,
            360,
            361,
            161,
            0,
            162,
            0,
            0,
            0,
            362,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            162,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            270,
            0,
            0,
            0,
            0,
            162,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            363,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            364,
            116,
            365,
            366,
            8,
            161,
            0,
            162,
            0,
            0,
            367,
            120,
            0,
            0,
            16,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            368,
            368,
            0,
            161,
            0,
            162,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            40,
            0,
            121,
            121,
            0,
            9,
            0,
            10,
            0,
            0,
            0,
            42,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            170,
            278,
            278,
            22,
            23,
            0,
            24,
            0,
            0,
            0,
            174,
            0,
            0,
            27,
            0
        ],
        [
            0,
            0,
            0,
            0,
            281,
            80,
            80,
            22,
            23,
            0,
            0,
            0,
            0,
            0,
            281,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            369,
            370,
            371,
            372,
            22,
            23,
            0,
            24,
            0,
            0,
            373,
            374,
            0,
            0,
            27,
            0
        ],
        [
            0,
            279,
            0,
            375,
            0,
            177,
            177,
            22,
            23,
            0,
            24,
            0,
            0,
            0,
            78,
            0,
            279,
            0,
            0
        ],
        [
            0,
            279,
            0,
            0,
            0,
            175,
            376,
            0,
            23,
            0,
            24,
            0,
            0,
            0,
            78,
            0,
            279,
            0,
            0
        ],
        [
            0,
            0,
            0,
            377,
            370,
            378,
            379,
            22,
            23,
            0,
            24,
            0,
            0,
            380,
            374,
            0,
            0,
            27,
            0
        ],
        [
            0,
            0,
            0,
            90,
            0,
            175,
            175,
            0,
            23,
            0,
            24,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            23,
            0,
            0,
            0,
            0,
            286,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            283,
            0,
            284,
            175,
            0,
            23,
            0,
            24,
            0,
            0,
            286,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            283,
            0,
            175,
            175,
            0,
            23,
            0,
            24,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            85,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            82,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            381,
            381,
            187,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            382,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            292,
            293,
            294,
            295,
            23,
            0,
            24,
            0,
            0,
            0,
            78,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            293,
            293,
            295,
            23,
            0,
            24,
            0,
            0,
            0,
            78,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            383,
            383,
            295,
            23,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            384,
            383,
            383,
            295,
            23,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            385,
            76,
            175,
            386,
            0,
            23,
            0,
            24,
            0,
            0,
            0,
            78,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            76,
            0,
            175,
            175,
            0,
            23,
            0,
            24,
            0,
            0,
            0,
            78,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            196,
            298,
            298,
            32,
            33,
            0,
            34,
            0,
            0,
            0,
            200,
            0,
            0,
            37,
            0
        ],
        [
            0,
            0,
            0,
            0,
            301,
            101,
            101,
            32,
            33,
            0,
            0,
            0,
            0,
            0,
            301,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            387,
            388,
            389,
            390,
            32,
            33,
            0,
            34,
            0,
            0,
            391,
            392,
            0,
            0,
            37,
            0
        ],
        [
            0,
            299,
            0,
            393,
            0,
            203,
            203,
            32,
            33,
            0,
            34,
            0,
            0,
            0,
            99,
            0,
            299,
            0,
            0
        ],
        [
            0,
            299,
            0,
            0,
            0,
            201,
            394,
            0,
            33,
            0,
            34,
            0,
            0,
            0,
            99,
            0,
            299,
            0,
            0
        ],
        [
            0,
            0,
            0,
            395,
            388,
            396,
            397,
            32,
            33,
            0,
            34,
            0,
            0,
            398,
            392,
            0,
            0,
            37,
            0
        ],
        [
            0,
            0,
            0,
            111,
            0,
            201,
            201,
            0,
            33,
            0,
            34,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            33,
            0,
            0,
            0,
            0,
            306,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            303,
            0,
            304,
            201,
            0,
            33,
            0,
            34,
            0,
            0,
            306,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            303,
            0,
            201,
            201,
            0,
            33,
            0,
            34,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            106,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            103,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            399,
            399,
            213,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            400,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            312,
            313,
            314,
            315,
            33,
            0,
            34,
            0,
            0,
            0,
            99,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            313,
            313,
            315,
            33,
            0,
            34,
            0,
            0,
            0,
            99,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            401,
            401,
            315,
            33,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            402,
            401,
            401,
            315,
            33,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            403,
            97,
            201,
            404,
            0,
            33,
            0,
            34,
            0,
            0,
            0,
            99,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            97,
            0,
            201,
            201,
            0,
            33,
            0,
            34,
            0,
            0,
            0,
            99,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            405,
            318,
            406,
            406,
            8,
            9,
            0,
            10,
            0,
            0,
            0,
            322,
            0,
            0,
            16,
            0
        ],
        [
            0,
            407,
            0,
            0,
            0,
            40,
            408,
            0,
            9,
            0,
            10,
            0,
            0,
            0,
            42,
            0,
            407,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            409,
            44,
            44,
            8,
            9,
            0,
            0,
            0,
            0,
            321,
            409,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            317,
            318,
            319,
            406,
            8,
            9,
            0,
            10,
            0,
            0,
            321,
            322,
            0,
            0,
            16,
            0
        ],
        [
            0,
            0,
            0,
            317,
            318,
            406,
            406,
            8,
            9,
            0,
            10,
            0,
            0,
            0,
            322,
            0,
            0,
            16,
            0
        ],
        [
            0,
            410,
            64,
            0,
            0,
            40,
            408,
            0,
            9,
            0,
            10,
            0,
            0,
            0,
            42,
            0,
            410,
            0,
            0
        ],
        [
            0,
            223,
            0,
            0,
            0,
            121,
            121,
            0,
            9,
            0,
            10,
            0,
            0,
            0,
            42,
            0,
            223,
            0,
            0
        ],
        [
            0,
            223,
            0,
            323,
            0,
            121,
            121,
            0,
            9,
            0,
            10,
            0,
            0,
            0,
            42,
            0,
            223,
            0,
            0
        ],
        [
            0,
            0,
            0,
            405,
            318,
            406,
            406,
            8,
            9,
            0,
            10,
            0,
            0,
            0,
            322,
            0,
            0,
            16,
            0
        ],
        [
            0,
            0,
            0,
            0,
            409,
            44,
            44,
            8,
            9,
            0,
            0,
            0,
            0,
            328,
            409,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            325,
            318,
            326,
            406,
            8,
            9,
            0,
            10,
            0,
            0,
            328,
            322,
            0,
            0,
            16,
            0
        ],
        [
            0,
            0,
            0,
            325,
            318,
            406,
            406,
            8,
            9,
            0,
            10,
            0,
            0,
            0,
            322,
            0,
            0,
            16,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            133,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            130,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            411,
            411,
            239,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            412,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            40,
            121,
            334,
            0,
            9,
            0,
            10,
            0,
            0,
            0,
            42,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            413,
            0,
            0,
            0,
            9,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            241,
            336,
            336,
            57,
            58,
            0,
            59,
            0,
            0,
            0,
            245,
            0,
            0,
            62,
            0
        ],
        [
            0,
            0,
            0,
            0,
            339,
            141,
            141,
            57,
            58,
            0,
            0,
            0,
            0,
            0,
            339,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            414,
            415,
            416,
            417,
            57,
            58,
            0,
            59,
            0,
            0,
            418,
            419,
            0,
            0,
            62,
            0
        ],
        [
            0,
            337,
            0,
            420,
            0,
            248,
            248,
            57,
            58,
            0,
            59,
            0,
            0,
            0,
            139,
            0,
            337,
            0,
            0
        ],
        [
            0,
            337,
            0,
            0,
            0,
            246,
            421,
            0,
            58,
            0,
            59,
            0,
            0,
            0,
            139,
            0,
            337,
            0,
            0
        ],
        [
            0,
            0,
            0,
            422,
            415,
            423,
            424,
            57,
            58,
            0,
            59,
            0,
            0,
            425,
            419,
            0,
            0,
            62,
            0
        ],
        [
            0,
            0,
            0,
            151,
            0,
            246,
            246,
            0,
            58,
            0,
            59,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            58,
            0,
            0,
            0,
            0,
            344,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            341,
            0,
            342,
            246,
            0,
            58,
            0,
            59,
            0,
            0,
            344,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            341,
            0,
            246,
            246,
            0,
            58,
            0,
            59,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            146,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            143,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            426,
            426,
            258,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            427,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            350,
            351,
            352,
            353,
            58,
            0,
            59,
            0,
            0,
            0,
            139,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            351,
            351,
            353,
            58,
            0,
            59,
            0,
            0,
            0,
            139,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            428,
            428,
            353,
            58,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            429,
            428,
            428,
            353,
            58,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            430,
            137,
            246,
            431,
            0,
            58,
            0,
            59,
            0,
            0,
            0,
            139,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            137,
            0,
            246,
            246,
            0,
            58,
            0,
            59,
            0,
            0,
            0,
            139,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            432,
            116,
            433,
            434,
            8,
            161,
            0,
            162,
            0,
            0,
            435,
            120,
            0,
            0,
            16,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            180,
            180,
            269,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            358,
            359,
            360,
            361,
            161,
            0,
            162,
            0,
            0,
            0,
            362,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            359,
            359,
            361,
            161,
            0,
            162,
            0,
            0,
            0,
            362,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            436,
            436,
            361,
            161,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            437,
            436,
            436,
            361,
            161,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            438,
            439,
            440,
            441,
            442,
            161,
            0,
            162,
            0,
            0,
            0,
            362,
            0,
            0,
            0,
            0
        ],
        [
            0,
            443,
            274,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            443,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            444,
            116,
            445,
            445,
            8,
            161,
            0,
            162,
            0,
            0,
            0,
            120,
            0,
            0,
            16,
            0
        ],
        [
            0,
            0,
            0,
            0,
            225,
            44,
            44,
            8,
            161,
            0,
            0,
            0,
            0,
            367,
            225,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            364,
            116,
            365,
            445,
            8,
            161,
            0,
            162,
            0,
            0,
            367,
            120,
            0,
            0,
            16,
            0
        ],
        [
            0,
            0,
            0,
            364,
            116,
            445,
            445,
            8,
            161,
            0,
            162,
            0,
            0,
            0,
            120,
            0,
            0,
            16,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            161,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            446,
            370,
            447,
            447,
            22,
            23,
            0,
            24,
            0,
            0,
            0,
            374,
            0,
            0,
            27,
            0
        ],
        [
            0,
            448,
            0,
            0,
            0,
            76,
            449,
            0,
            23,
            0,
            24,
            0,
            0,
            0,
            78,
            0,
            448,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            450,
            80,
            80,
            22,
            23,
            0,
            0,
            0,
            0,
            373,
            450,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            369,
            370,
            371,
            447,
            22,
            23,
            0,
            24,
            0,
            0,
            373,
            374,
            0,
            0,
            27,
            0
        ],
        [
            0,
            0,
            0,
            369,
            370,
            447,
            447,
            22,
            23,
            0,
            24,
            0,
            0,
            0,
            374,
            0,
            0,
            27,
            0
        ],
        [
            0,
            451,
            90,
            0,
            0,
            76,
            449,
            0,
            23,
            0,
            24,
            0,
            0,
            0,
            78,
            0,
            451,
            0,
            0
        ],
        [
            0,
            279,
            0,
            0,
            0,
            175,
            175,
            0,
            23,
            0,
            24,
            0,
            0,
            0,
            78,
            0,
            279,
            0,
            0
        ],
        [
            0,
            279,
            0,
            375,
            0,
            175,
            175,
            0,
            23,
            0,
            24,
            0,
            0,
            0,
            78,
            0,
            279,
            0,
            0
        ],
        [
            0,
            0,
            0,
            446,
            370,
            447,
            447,
            22,
            23,
            0,
            24,
            0,
            0,
            0,
            374,
            0,
            0,
            27,
            0
        ],
        [
            0,
            0,
            0,
            0,
            450,
            80,
            80,
            22,
            23,
            0,
            0,
            0,
            0,
            380,
            450,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            377,
            370,
            378,
            447,
            22,
            23,
            0,
            24,
            0,
            0,
            380,
            374,
            0,
            0,
            27,
            0
        ],
        [
            0,
            0,
            0,
            377,
            370,
            447,
            447,
            22,
            23,
            0,
            24,
            0,
            0,
            0,
            374,
            0,
            0,
            27,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            187,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            184,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            452,
            452,
            295,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            453,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            76,
            175,
            386,
            0,
            23,
            0,
            24,
            0,
            0,
            0,
            78,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            454,
            0,
            0,
            0,
            23,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            455,
            388,
            456,
            456,
            32,
            33,
            0,
            34,
            0,
            0,
            0,
            392,
            0,
            0,
            37,
            0
        ],
        [
            0,
            457,
            0,
            0,
            0,
            97,
            458,
            0,
            33,
            0,
            34,
            0,
            0,
            0,
            99,
            0,
            457,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            459,
            101,
            101,
            32,
            33,
            0,
            0,
            0,
            0,
            391,
            459,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            387,
            388,
            389,
            456,
            32,
            33,
            0,
            34,
            0,
            0,
            391,
            392,
            0,
            0,
            37,
            0
        ],
        [
            0,
            0,
            0,
            387,
            388,
            456,
            456,
            32,
            33,
            0,
            34,
            0,
            0,
            0,
            392,
            0,
            0,
            37,
            0
        ],
        [
            0,
            460,
            111,
            0,
            0,
            97,
            458,
            0,
            33,
            0,
            34,
            0,
            0,
            0,
            99,
            0,
            460,
            0,
            0
        ],
        [
            0,
            299,
            0,
            0,
            0,
            201,
            201,
            0,
            33,
            0,
            34,
            0,
            0,
            0,
            99,
            0,
            299,
            0,
            0
        ],
        [
            0,
            299,
            0,
            393,
            0,
            201,
            201,
            0,
            33,
            0,
            34,
            0,
            0,
            0,
            99,
            0,
            299,
            0,
            0
        ],
        [
            0,
            0,
            0,
            455,
            388,
            456,
            456,
            32,
            33,
            0,
            34,
            0,
            0,
            0,
            392,
            0,
            0,
            37,
            0
        ],
        [
            0,
            0,
            0,
            0,
            459,
            101,
            101,
            32,
            33,
            0,
            0,
            0,
            0,
            398,
            459,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            395,
            388,
            396,
            456,
            32,
            33,
            0,
            34,
            0,
            0,
            398,
            392,
            0,
            0,
            37,
            0
        ],
        [
            0,
            0,
            0,
            395,
            388,
            456,
            456,
            32,
            33,
            0,
            34,
            0,
            0,
            0,
            392,
            0,
            0,
            37,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            213,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            210,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            461,
            461,
            315,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            462,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            97,
            201,
            404,
            0,
            33,
            0,
            34,
            0,
            0,
            0,
            99,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            463,
            0,
            0,
            0,
            33,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            318,
            406,
            406,
            8,
            9,
            0,
            10,
            0,
            0,
            0,
            322,
            0,
            0,
            16,
            0
        ],
        [
            0,
            0,
            0,
            0,
            409,
            44,
            44,
            8,
            9,
            0,
            0,
            0,
            0,
            0,
            409,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            464,
            465,
            466,
            467,
            8,
            9,
            0,
            10,
            0,
            0,
            468,
            469,
            0,
            0,
            16,
            0
        ],
        [
            0,
            407,
            0,
            470,
            0,
            123,
            123,
            8,
            9,
            0,
            10,
            0,
            0,
            0,
            42,
            0,
            407,
            0,
            0
        ],
        [
            0,
            407,
            0,
            0,
            0,
            121,
            471,
            0,
            9,
            0,
            10,
            0,
            0,
            0,
            42,
            0,
            407,
            0,
            0
        ],
        [
            0,
            0,
            0,
            472,
            465,
            473,
            474,
            8,
            9,
            0,
            10,
            0,
            0,
            475,
            469,
            0,
            0,
            16,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            239,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            236,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            476,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            477,
            415,
            478,
            478,
            57,
            58,
            0,
            59,
            0,
            0,
            0,
            419,
            0,
            0,
            62,
            0
        ],
        [
            0,
            479,
            0,
            0,
            0,
            137,
            480,
            0,
            58,
            0,
            59,
            0,
            0,
            0,
            139,
            0,
            479,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            481,
            141,
            141,
            57,
            58,
            0,
            0,
            0,
            0,
            418,
            481,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            414,
            415,
            416,
            478,
            57,
            58,
            0,
            59,
            0,
            0,
            418,
            419,
            0,
            0,
            62,
            0
        ],
        [
            0,
            0,
            0,
            414,
            415,
            478,
            478,
            57,
            58,
            0,
            59,
            0,
            0,
            0,
            419,
            0,
            0,
            62,
            0
        ],
        [
            0,
            482,
            151,
            0,
            0,
            137,
            480,
            0,
            58,
            0,
            59,
            0,
            0,
            0,
            139,
            0,
            482,
            0,
            0
        ],
        [
            0,
            337,
            0,
            0,
            0,
            246,
            246,
            0,
            58,
            0,
            59,
            0,
            0,
            0,
            139,
            0,
            337,
            0,
            0
        ],
        [
            0,
            337,
            0,
            420,
            0,
            246,
            246,
            0,
            58,
            0,
            59,
            0,
            0,
            0,
            139,
            0,
            337,
            0,
            0
        ],
        [
            0,
            0,
            0,
            477,
            415,
            478,
            478,
            57,
            58,
            0,
            59,
            0,
            0,
            0,
            419,
            0,
            0,
            62,
            0
        ],
        [
            0,
            0,
            0,
            0,
            481,
            141,
            141,
            57,
            58,
            0,
            0,
            0,
            0,
            425,
            481,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            422,
            415,
            423,
            478,
            57,
            58,
            0,
            59,
            0,
            0,
            425,
            419,
            0,
            0,
            62,
            0
        ],
        [
            0,
            0,
            0,
            422,
            415,
            478,
            478,
            57,
            58,
            0,
            59,
            0,
            0,
            0,
            419,
            0,
            0,
            62,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            258,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            255,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            483,
            483,
            353,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            484,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            137,
            246,
            431,
            0,
            58,
            0,
            59,
            0,
            0,
            0,
            139,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            485,
            0,
            0,
            0,
            58,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            444,
            116,
            445,
            445,
            8,
            161,
            0,
            162,
            0,
            0,
            0,
            120,
            0,
            0,
            16,
            0
        ],
        [
            0,
            0,
            0,
            0,
            225,
            44,
            44,
            8,
            161,
            0,
            0,
            0,
            0,
            435,
            225,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            432,
            116,
            433,
            445,
            8,
            161,
            0,
            162,
            0,
            0,
            435,
            120,
            0,
            0,
            16,
            0
        ],
        [
            0,
            0,
            0,
            432,
            116,
            445,
            445,
            8,
            161,
            0,
            162,
            0,
            0,
            0,
            120,
            0,
            0,
            16,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            486,
            486,
            361,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            487,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            439,
            440,
            441,
            442,
            161,
            0,
            162,
            0,
            0,
            0,
            362,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            440,
            440,
            442,
            161,
            0,
            162,
            0,
            0,
            0,
            362,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            488,
            488,
            442,
            161,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            489,
            488,
            488,
            442,
            161,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            490,
            491,
            492,
            493,
            494,
            161,
            0,
            162,
            0,
            0,
            0,
            362,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            495,
            0,
            496,
            497,
            0,
            161,
            0,
            162,
            0,
            0,
            498,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            116,
            445,
            445,
            8,
            161,
            0,
            162,
            0,
            0,
            0,
            120,
            0,
            0,
            16,
            0
        ],
        [
            0,
            0,
            0,
            0,
            225,
            44,
            44,
            8,
            161,
            0,
            0,
            0,
            0,
            0,
            225,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            370,
            447,
            447,
            22,
            23,
            0,
            24,
            0,
            0,
            0,
            374,
            0,
            0,
            27,
            0
        ],
        [
            0,
            0,
            0,
            0,
            450,
            80,
            80,
            22,
            23,
            0,
            0,
            0,
            0,
            0,
            450,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            499,
            500,
            501,
            502,
            22,
            23,
            0,
            24,
            0,
            0,
            503,
            504,
            0,
            0,
            27,
            0
        ],
        [
            0,
            448,
            0,
            505,
            0,
            177,
            177,
            22,
            23,
            0,
            24,
            0,
            0,
            0,
            78,
            0,
            448,
            0,
            0
        ],
        [
            0,
            448,
            0,
            0,
            0,
            175,
            506,
            0,
            23,
            0,
            24,
            0,
            0,
            0,
            78,
            0,
            448,
            0,
            0
        ],
        [
            0,
            0,
            0,
            507,
            500,
            508,
            509,
            22,
            23,
            0,
            24,
            0,
            0,
            510,
            504,
            0,
            0,
            27,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            295,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            292,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            511,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            388,
            456,
            456,
            32,
            33,
            0,
            34,
            0,
            0,
            0,
            392,
            0,
            0,
            37,
            0
        ],
        [
            0,
            0,
            0,
            0,
            459,
            101,
            101,
            32,
            33,
            0,
            0,
            0,
            0,
            0,
            459,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            512,
            513,
            514,
            515,
            32,
            33,
            0,
            34,
            0,
            0,
            516,
            517,
            0,
            0,
            37,
            0
        ],
        [
            0,
            457,
            0,
            518,
            0,
            203,
            203,
            32,
            33,
            0,
            34,
            0,
            0,
            0,
            99,
            0,
            457,
            0,
            0
        ],
        [
            0,
            457,
            0,
            0,
            0,
            201,
            519,
            0,
            33,
            0,
            34,
            0,
            0,
            0,
            99,
            0,
            457,
            0,
            0
        ],
        [
            0,
            0,
            0,
            520,
            513,
            521,
            522,
            32,
            33,
            0,
            34,
            0,
            0,
            523,
            517,
            0,
            0,
            37,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            315,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            312,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            524,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            525,
            465,
            526,
            526,
            8,
            9,
            0,
            10,
            0,
            0,
            0,
            469,
            0,
            0,
            16,
            0
        ],
        [
            0,
            527,
            0,
            0,
            0,
            40,
            528,
            0,
            9,
            0,
            10,
            0,
            0,
            0,
            42,
            0,
            527,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            529,
            44,
            44,
            8,
            9,
            0,
            0,
            0,
            0,
            468,
            529,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            464,
            465,
            466,
            526,
            8,
            9,
            0,
            10,
            0,
            0,
            468,
            469,
            0,
            0,
            16,
            0
        ],
        [
            0,
            0,
            0,
            464,
            465,
            526,
            526,
            8,
            9,
            0,
            10,
            0,
            0,
            0,
            469,
            0,
            0,
            16,
            0
        ],
        [
            0,
            530,
            64,
            0,
            0,
            40,
            528,
            0,
            9,
            0,
            10,
            0,
            0,
            0,
            42,
            0,
            530,
            0,
            0
        ],
        [
            0,
            407,
            0,
            0,
            0,
            121,
            121,
            0,
            9,
            0,
            10,
            0,
            0,
            0,
            42,
            0,
            407,
            0,
            0
        ],
        [
            0,
            407,
            0,
            470,
            0,
            121,
            121,
            0,
            9,
            0,
            10,
            0,
            0,
            0,
            42,
            0,
            407,
            0,
            0
        ],
        [
            0,
            0,
            0,
            525,
            465,
            526,
            526,
            8,
            9,
            0,
            10,
            0,
            0,
            0,
            469,
            0,
            0,
            16,
            0
        ],
        [
            0,
            0,
            0,
            0,
            529,
            44,
            44,
            8,
            9,
            0,
            0,
            0,
            0,
            475,
            529,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            472,
            465,
            473,
            526,
            8,
            9,
            0,
            10,
            0,
            0,
            475,
            469,
            0,
            0,
            16,
            0
        ],
        [
            0,
            0,
            0,
            472,
            465,
            526,
            526,
            8,
            9,
            0,
            10,
            0,
            0,
            0,
            469,
            0,
            0,
            16,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            40,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            415,
            478,
            478,
            57,
            58,
            0,
            59,
            0,
            0,
            0,
            419,
            0,
            0,
            62,
            0
        ],
        [
            0,
            0,
            0,
            0,
            481,
            141,
            141,
            57,
            58,
            0,
            0,
            0,
            0,
            0,
            481,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            531,
            532,
            533,
            534,
            57,
            58,
            0,
            59,
            0,
            0,
            535,
            536,
            0,
            0,
            62,
            0
        ],
        [
            0,
            479,
            0,
            537,
            0,
            248,
            248,
            57,
            58,
            0,
            59,
            0,
            0,
            0,
            139,
            0,
            479,
            0,
            0
        ],
        [
            0,
            479,
            0,
            0,
            0,
            246,
            538,
            0,
            58,
            0,
            59,
            0,
            0,
            0,
            139,
            0,
            479,
            0,
            0
        ],
        [
            0,
            0,
            0,
            539,
            532,
            540,
            541,
            57,
            58,
            0,
            59,
            0,
            0,
            542,
            536,
            0,
            0,
            62,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            353,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            350,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            543,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            361,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            358,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            544,
            544,
            442,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            545,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            491,
            492,
            493,
            494,
            161,
            0,
            162,
            0,
            0,
            0,
            362,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            492,
            492,
            494,
            161,
            0,
            162,
            0,
            0,
            0,
            362,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            546,
            546,
            494,
            161,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            547,
            546,
            546,
            494,
            161,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            548,
            549,
            368,
            550,
            0,
            161,
            0,
            162,
            0,
            0,
            0,
            362,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            274,
            0,
            368,
            368,
            0,
            161,
            0,
            162,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            161,
            0,
            0,
            0,
            0,
            498,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            495,
            0,
            496,
            368,
            0,
            161,
            0,
            162,
            0,
            0,
            498,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            495,
            0,
            368,
            368,
            0,
            161,
            0,
            162,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            551,
            500,
            552,
            552,
            22,
            23,
            0,
            24,
            0,
            0,
            0,
            504,
            0,
            0,
            27,
            0
        ],
        [
            0,
            553,
            0,
            0,
            0,
            76,
            554,
            0,
            23,
            0,
            24,
            0,
            0,
            0,
            78,
            0,
            553,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            555,
            80,
            80,
            22,
            23,
            0,
            0,
            0,
            0,
            503,
            555,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            499,
            500,
            501,
            552,
            22,
            23,
            0,
            24,
            0,
            0,
            503,
            504,
            0,
            0,
            27,
            0
        ],
        [
            0,
            0,
            0,
            499,
            500,
            552,
            552,
            22,
            23,
            0,
            24,
            0,
            0,
            0,
            504,
            0,
            0,
            27,
            0
        ],
        [
            0,
            556,
            90,
            0,
            0,
            76,
            554,
            0,
            23,
            0,
            24,
            0,
            0,
            0,
            78,
            0,
            556,
            0,
            0
        ],
        [
            0,
            448,
            0,
            0,
            0,
            175,
            175,
            0,
            23,
            0,
            24,
            0,
            0,
            0,
            78,
            0,
            448,
            0,
            0
        ],
        [
            0,
            448,
            0,
            505,
            0,
            175,
            175,
            0,
            23,
            0,
            24,
            0,
            0,
            0,
            78,
            0,
            448,
            0,
            0
        ],
        [
            0,
            0,
            0,
            551,
            500,
            552,
            552,
            22,
            23,
            0,
            24,
            0,
            0,
            0,
            504,
            0,
            0,
            27,
            0
        ],
        [
            0,
            0,
            0,
            0,
            555,
            80,
            80,
            22,
            23,
            0,
            0,
            0,
            0,
            510,
            555,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            507,
            500,
            508,
            552,
            22,
            23,
            0,
            24,
            0,
            0,
            510,
            504,
            0,
            0,
            27,
            0
        ],
        [
            0,
            0,
            0,
            507,
            500,
            552,
            552,
            22,
            23,
            0,
            24,
            0,
            0,
            0,
            504,
            0,
            0,
            27,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            76,
            0,
            0
        ],
        [
            0,
            0,
            0,
            557,
            513,
            558,
            558,
            32,
            33,
            0,
            34,
            0,
            0,
            0,
            517,
            0,
            0,
            37,
            0
        ],
        [
            0,
            559,
            0,
            0,
            0,
            97,
            560,
            0,
            33,
            0,
            34,
            0,
            0,
            0,
            99,
            0,
            559,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            561,
            101,
            101,
            32,
            33,
            0,
            0,
            0,
            0,
            516,
            561,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            512,
            513,
            514,
            558,
            32,
            33,
            0,
            34,
            0,
            0,
            516,
            517,
            0,
            0,
            37,
            0
        ],
        [
            0,
            0,
            0,
            512,
            513,
            558,
            558,
            32,
            33,
            0,
            34,
            0,
            0,
            0,
            517,
            0,
            0,
            37,
            0
        ],
        [
            0,
            562,
            111,
            0,
            0,
            97,
            560,
            0,
            33,
            0,
            34,
            0,
            0,
            0,
            99,
            0,
            562,
            0,
            0
        ],
        [
            0,
            457,
            0,
            0,
            0,
            201,
            201,
            0,
            33,
            0,
            34,
            0,
            0,
            0,
            99,
            0,
            457,
            0,
            0
        ],
        [
            0,
            457,
            0,
            518,
            0,
            201,
            201,
            0,
            33,
            0,
            34,
            0,
            0,
            0,
            99,
            0,
            457,
            0,
            0
        ],
        [
            0,
            0,
            0,
            557,
            513,
            558,
            558,
            32,
            33,
            0,
            34,
            0,
            0,
            0,
            517,
            0,
            0,
            37,
            0
        ],
        [
            0,
            0,
            0,
            0,
            561,
            101,
            101,
            32,
            33,
            0,
            0,
            0,
            0,
            523,
            561,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            520,
            513,
            521,
            558,
            32,
            33,
            0,
            34,
            0,
            0,
            523,
            517,
            0,
            0,
            37,
            0
        ],
        [
            0,
            0,
            0,
            520,
            513,
            558,
            558,
            32,
            33,
            0,
            34,
            0,
            0,
            0,
            517,
            0,
            0,
            37,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            97,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            465,
            526,
            526,
            8,
            9,
            0,
            10,
            0,
            0,
            0,
            469,
            0,
            0,
            16,
            0
        ],
        [
            0,
            0,
            0,
            0,
            529,
            44,
            44,
            8,
            9,
            0,
            0,
            0,
            0,
            0,
            529,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            563,
            66,
            564,
            565,
            8,
            9,
            0,
            10,
            0,
            0,
            566,
            68,
            0,
            0,
            16,
            0
        ],
        [
            0,
            527,
            0,
            567,
            0,
            123,
            123,
            8,
            9,
            0,
            10,
            0,
            0,
            0,
            42,
            0,
            527,
            0,
            0
        ],
        [
            0,
            527,
            0,
            0,
            0,
            121,
            568,
            0,
            9,
            0,
            10,
            0,
            0,
            0,
            42,
            0,
            527,
            0,
            0
        ],
        [
            0,
            0,
            0,
            569,
            66,
            570,
            571,
            8,
            9,
            0,
            10,
            0,
            0,
            572,
            68,
            0,
            0,
            16,
            0
        ],
        [
            0,
            0,
            0,
            573,
            532,
            574,
            574,
            57,
            58,
            0,
            59,
            0,
            0,
            0,
            536,
            0,
            0,
            62,
            0
        ],
        [
            0,
            575,
            0,
            0,
            0,
            137,
            576,
            0,
            58,
            0,
            59,
            0,
            0,
            0,
            139,
            0,
            575,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            577,
            141,
            141,
            57,
            58,
            0,
            0,
            0,
            0,
            535,
            577,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            531,
            532,
            533,
            574,
            57,
            58,
            0,
            59,
            0,
            0,
            535,
            536,
            0,
            0,
            62,
            0
        ],
        [
            0,
            0,
            0,
            531,
            532,
            574,
            574,
            57,
            58,
            0,
            59,
            0,
            0,
            0,
            536,
            0,
            0,
            62,
            0
        ],
        [
            0,
            578,
            151,
            0,
            0,
            137,
            576,
            0,
            58,
            0,
            59,
            0,
            0,
            0,
            139,
            0,
            578,
            0,
            0
        ],
        [
            0,
            479,
            0,
            0,
            0,
            246,
            246,
            0,
            58,
            0,
            59,
            0,
            0,
            0,
            139,
            0,
            479,
            0,
            0
        ],
        [
            0,
            479,
            0,
            537,
            0,
            246,
            246,
            0,
            58,
            0,
            59,
            0,
            0,
            0,
            139,
            0,
            479,
            0,
            0
        ],
        [
            0,
            0,
            0,
            573,
            532,
            574,
            574,
            57,
            58,
            0,
            59,
            0,
            0,
            0,
            536,
            0,
            0,
            62,
            0
        ],
        [
            0,
            0,
            0,
            0,
            577,
            141,
            141,
            57,
            58,
            0,
            0,
            0,
            0,
            542,
            577,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            539,
            532,
            540,
            574,
            57,
            58,
            0,
            59,
            0,
            0,
            542,
            536,
            0,
            0,
            62,
            0
        ],
        [
            0,
            0,
            0,
            539,
            532,
            574,
            574,
            57,
            58,
            0,
            59,
            0,
            0,
            0,
            536,
            0,
            0,
            62,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            137,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            442,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            439,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            579,
            579,
            494,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            580,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            549,
            368,
            550,
            0,
            161,
            0,
            162,
            0,
            0,
            0,
            362,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            368,
            368,
            0,
            161,
            0,
            162,
            0,
            0,
            0,
            362,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            581,
            0,
            0,
            0,
            161,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            500,
            552,
            552,
            22,
            23,
            0,
            24,
            0,
            0,
            0,
            504,
            0,
            0,
            27,
            0
        ],
        [
            0,
            0,
            0,
            0,
            555,
            80,
            80,
            22,
            23,
            0,
            0,
            0,
            0,
            0,
            555,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            582,
            91,
            583,
            584,
            22,
            23,
            0,
            24,
            0,
            0,
            585,
            93,
            0,
            0,
            27,
            0
        ],
        [
            0,
            553,
            0,
            586,
            0,
            177,
            177,
            22,
            23,
            0,
            24,
            0,
            0,
            0,
            78,
            0,
            553,
            0,
            0
        ],
        [
            0,
            553,
            0,
            0,
            0,
            175,
            587,
            0,
            23,
            0,
            24,
            0,
            0,
            0,
            78,
            0,
            553,
            0,
            0
        ],
        [
            0,
            0,
            0,
            588,
            91,
            589,
            590,
            22,
            23,
            0,
            24,
            0,
            0,
            591,
            93,
            0,
            0,
            27,
            0
        ],
        [
            0,
            0,
            0,
            0,
            513,
            558,
            558,
            32,
            33,
            0,
            34,
            0,
            0,
            0,
            517,
            0,
            0,
            37,
            0
        ],
        [
            0,
            0,
            0,
            0,
            561,
            101,
            101,
            32,
            33,
            0,
            0,
            0,
            0,
            0,
            561,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            592,
            112,
            593,
            594,
            32,
            33,
            0,
            34,
            0,
            0,
            595,
            114,
            0,
            0,
            37,
            0
        ],
        [
            0,
            559,
            0,
            596,
            0,
            203,
            203,
            32,
            33,
            0,
            34,
            0,
            0,
            0,
            99,
            0,
            559,
            0,
            0
        ],
        [
            0,
            559,
            0,
            0,
            0,
            201,
            597,
            0,
            33,
            0,
            34,
            0,
            0,
            0,
            99,
            0,
            559,
            0,
            0
        ],
        [
            0,
            0,
            0,
            598,
            112,
            599,
            600,
            32,
            33,
            0,
            34,
            0,
            0,
            601,
            114,
            0,
            0,
            37,
            0
        ],
        [
            0,
            0,
            0,
            602,
            66,
            67,
            67,
            8,
            9,
            0,
            10,
            0,
            0,
            0,
            68,
            0,
            0,
            16,
            0
        ],
        [
            0,
            0,
            0,
            0,
            165,
            44,
            44,
            8,
            9,
            0,
            0,
            0,
            0,
            566,
            165,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            563,
            66,
            564,
            67,
            8,
            9,
            0,
            10,
            0,
            0,
            566,
            68,
            0,
            0,
            16,
            0
        ],
        [
            0,
            0,
            0,
            563,
            66,
            67,
            67,
            8,
            9,
            0,
            10,
            0,
            0,
            0,
            68,
            0,
            0,
            16,
            0
        ],
        [
            0,
            527,
            0,
            0,
            0,
            121,
            121,
            0,
            9,
            0,
            10,
            0,
            0,
            0,
            42,
            0,
            527,
            0,
            0
        ],
        [
            0,
            527,
            0,
            567,
            0,
            121,
            121,
            0,
            9,
            0,
            10,
            0,
            0,
            0,
            42,
            0,
            527,
            0,
            0
        ],
        [
            0,
            0,
            0,
            602,
            66,
            67,
            67,
            8,
            9,
            0,
            10,
            0,
            0,
            0,
            68,
            0,
            0,
            16,
            0
        ],
        [
            0,
            0,
            0,
            0,
            165,
            44,
            44,
            8,
            9,
            0,
            0,
            0,
            0,
            572,
            165,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            569,
            66,
            570,
            67,
            8,
            9,
            0,
            10,
            0,
            0,
            572,
            68,
            0,
            0,
            16,
            0
        ],
        [
            0,
            0,
            0,
            569,
            66,
            67,
            67,
            8,
            9,
            0,
            10,
            0,
            0,
            0,
            68,
            0,
            0,
            16,
            0
        ],
        [
            0,
            0,
            0,
            0,
            532,
            574,
            574,
            57,
            58,
            0,
            59,
            0,
            0,
            0,
            536,
            0,
            0,
            62,
            0
        ],
        [
            0,
            0,
            0,
            0,
            577,
            141,
            141,
            57,
            58,
            0,
            0,
            0,
            0,
            0,
            577,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            603,
            152,
            604,
            605,
            57,
            58,
            0,
            59,
            0,
            0,
            606,
            154,
            0,
            0,
            62,
            0
        ],
        [
            0,
            575,
            0,
            607,
            0,
            248,
            248,
            57,
            58,
            0,
            59,
            0,
            0,
            0,
            139,
            0,
            575,
            0,
            0
        ],
        [
            0,
            575,
            0,
            0,
            0,
            246,
            608,
            0,
            58,
            0,
            59,
            0,
            0,
            0,
            139,
            0,
            575,
            0,
            0
        ],
        [
            0,
            0,
            0,
            609,
            152,
            610,
            611,
            57,
            58,
            0,
            59,
            0,
            0,
            612,
            154,
            0,
            0,
            62,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            494,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            491,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            613,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            614,
            91,
            92,
            92,
            22,
            23,
            0,
            24,
            0,
            0,
            0,
            93,
            0,
            0,
            27,
            0
        ],
        [
            0,
            0,
            0,
            0,
            194,
            80,
            80,
            22,
            23,
            0,
            0,
            0,
            0,
            585,
            194,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            582,
            91,
            583,
            92,
            22,
            23,
            0,
            24,
            0,
            0,
            585,
            93,
            0,
            0,
            27,
            0
        ],
        [
            0,
            0,
            0,
            582,
            91,
            92,
            92,
            22,
            23,
            0,
            24,
            0,
            0,
            0,
            93,
            0,
            0,
            27,
            0
        ],
        [
            0,
            553,
            0,
            0,
            0,
            175,
            175,
            0,
            23,
            0,
            24,
            0,
            0,
            0,
            78,
            0,
            553,
            0,
            0
        ],
        [
            0,
            553,
            0,
            586,
            0,
            175,
            175,
            0,
            23,
            0,
            24,
            0,
            0,
            0,
            78,
            0,
            553,
            0,
            0
        ],
        [
            0,
            0,
            0,
            614,
            91,
            92,
            92,
            22,
            23,
            0,
            24,
            0,
            0,
            0,
            93,
            0,
            0,
            27,
            0
        ],
        [
            0,
            0,
            0,
            0,
            194,
            80,
            80,
            22,
            23,
            0,
            0,
            0,
            0,
            591,
            194,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            588,
            91,
            589,
            92,
            22,
            23,
            0,
            24,
            0,
            0,
            591,
            93,
            0,
            0,
            27,
            0
        ],
        [
            0,
            0,
            0,
            588,
            91,
            92,
            92,
            22,
            23,
            0,
            24,
            0,
            0,
            0,
            93,
            0,
            0,
            27,
            0
        ],
        [
            0,
            0,
            0,
            615,
            112,
            113,
            113,
            32,
            33,
            0,
            34,
            0,
            0,
            0,
            114,
            0,
            0,
            37,
            0
        ],
        [
            0,
            0,
            0,
            0,
            220,
            101,
            101,
            32,
            33,
            0,
            0,
            0,
            0,
            595,
            220,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            592,
            112,
            593,
            113,
            32,
            33,
            0,
            34,
            0,
            0,
            595,
            114,
            0,
            0,
            37,
            0
        ],
        [
            0,
            0,
            0,
            592,
            112,
            113,
            113,
            32,
            33,
            0,
            34,
            0,
            0,
            0,
            114,
            0,
            0,
            37,
            0
        ],
        [
            0,
            559,
            0,
            0,
            0,
            201,
            201,
            0,
            33,
            0,
            34,
            0,
            0,
            0,
            99,
            0,
            559,
            0,
            0
        ],
        [
            0,
            559,
            0,
            596,
            0,
            201,
            201,
            0,
            33,
            0,
            34,
            0,
            0,
            0,
            99,
            0,
            559,
            0,
            0
        ],
        [
            0,
            0,
            0,
            615,
            112,
            113,
            113,
            32,
            33,
            0,
            34,
            0,
            0,
            0,
            114,
            0,
            0,
            37,
            0
        ],
        [
            0,
            0,
            0,
            0,
            220,
            101,
            101,
            32,
            33,
            0,
            0,
            0,
            0,
            601,
            220,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            598,
            112,
            599,
            113,
            32,
            33,
            0,
            34,
            0,
            0,
            601,
            114,
            0,
            0,
            37,
            0
        ],
        [
            0,
            0,
            0,
            598,
            112,
            113,
            113,
            32,
            33,
            0,
            34,
            0,
            0,
            0,
            114,
            0,
            0,
            37,
            0
        ],
        [
            0,
            0,
            0,
            0,
            66,
            67,
            67,
            8,
            9,
            0,
            10,
            0,
            0,
            0,
            68,
            0,
            0,
            16,
            0
        ],
        [
            0,
            0,
            0,
            616,
            152,
            153,
            153,
            57,
            58,
            0,
            59,
            0,
            0,
            0,
            154,
            0,
            0,
            62,
            0
        ],
        [
            0,
            0,
            0,
            0,
            265,
            141,
            141,
            57,
            58,
            0,
            0,
            0,
            0,
            606,
            265,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            603,
            152,
            604,
            153,
            57,
            58,
            0,
            59,
            0,
            0,
            606,
            154,
            0,
            0,
            62,
            0
        ],
        [
            0,
            0,
            0,
            603,
            152,
            153,
            153,
            57,
            58,
            0,
            59,
            0,
            0,
            0,
            154,
            0,
            0,
            62,
            0
        ],
        [
            0,
            575,
            0,
            0,
            0,
            246,
            246,
            0,
            58,
            0,
            59,
            0,
            0,
            0,
            139,
            0,
            575,
            0,
            0
        ],
        [
            0,
            575,
            0,
            607,
            0,
            246,
            246,
            0,
            58,
            0,
            59,
            0,
            0,
            0,
            139,
            0,
            575,
            0,
            0
        ],
        [
            0,
            0,
            0,
            616,
            152,
            153,
            153,
            57,
            58,
            0,
            59,
            0,
            0,
            0,
            154,
            0,
            0,
            62,
            0
        ],
        [
            0,
            0,
            0,
            0,
            265,
            141,
            141,
            57,
            58,
            0,
            0,
            0,
            0,
            612,
            265,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            609,
            152,
            610,
            153,
            57,
            58,
            0,
            59,
            0,
            0,
            612,
            154,
            0,
            0,
            62,
            0
        ],
        [
            0,
            0,
            0,
            609,
            152,
            153,
            153,
            57,
            58,
            0,
            59,
            0,
            0,
            0,
            154,
            0,
            0,
            62,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            549,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            91,
            92,
            92,
            22,
            23,
            0,
            24,
            0,
            0,
            0,
            93,
            0,
            0,
            27,
            0
        ],
        [
            0,
            0,
            0,
            0,
            112,
            113,
            113,
            32,
            33,
            0,
            34,
            0,
            0,
            0,
            114,
            0,
            0,
            37,
            0
        ],
        [
            0,
            0,
            0,
            0,
            152,
            153,
            153,
            57,
            58,
            0,
            59,
            0,
            0,
            0,
            154,
            0,
            0,
            62,
            0
        ]
    ];
var accepting = [
        false,
        true,
        true,
        true,
        true,
        true,
        false,
        false,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        false,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        false,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        false,
        true,
        false,
        true,
        true,
        false,
        false,
        true,
        true,
        true,
        true,
        true,
        true,
        false,
        false,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        false,
        true,
        true,
        false,
        true,
        true,
        true,
        false,
        true,
        true,
        true,
        false,
        true,
        false,
        true,
        true,
        false,
        false,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        false,
        true,
        true,
        false,
        true,
        true,
        true,
        false,
        true,
        false,
        true,
        true,
        false,
        false,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        false,
        true,
        true,
        true,
        false,
        true,
        true,
        true,
        false,
        true,
        false,
        true,
        true,
        false,
        false,
        false,
        true,
        true,
        false,
        false,
        true,
        true,
        true,
        true,
        true,
        true,
        false,
        true,
        false,
        true,
        true,
        false,
        false,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        false,
        true,
        true,
        false,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        false,
        true,
        true,
        true,
        false,
        true,
        false,
        true,
        true,
        false,
        false,
        false,
        true,
        true,
        false,
        false,
        true,
        true,
        true,
        false,
        true,
        true,
        true,
        true,
        true,
        true,
        false,
        true,
        true,
        true,
        false,
        true,
        false,
        true,
        true,
        false,
        false,
        false,
        true,
        true,
        false,
        false,
        true,
        true,
        true,
        false,
        true,
        true,
        true,
        true,
        true,
        false,
        true,
        true,
        true,
        true,
        true,
        false,
        true,
        true,
        false,
        false,
        false,
        false,
        true,
        true,
        false,
        false,
        true,
        true,
        true,
        false,
        true,
        true,
        true,
        false,
        true,
        false,
        true,
        true,
        false,
        false,
        false,
        true,
        true,
        false,
        false,
        true,
        true,
        true,
        false,
        true,
        true,
        true,
        true,
        false,
        true,
        false,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        false,
        true,
        true,
        true,
        true,
        true,
        false,
        true,
        true,
        false,
        false,
        false,
        false,
        true,
        true,
        false,
        false,
        true,
        true,
        true,
        false,
        true,
        true,
        true,
        true,
        true,
        false,
        true,
        true,
        false,
        false,
        false,
        false,
        true,
        true,
        false,
        false,
        true,
        true,
        true,
        true,
        false,
        true,
        true,
        true,
        true,
        true,
        true,
        false,
        true,
        true,
        false,
        false,
        false,
        false,
        true,
        false,
        true,
        false,
        true,
        true,
        true,
        true,
        true,
        false,
        true,
        true,
        false,
        false,
        false,
        false,
        true,
        true,
        false,
        false,
        true,
        true,
        true,
        false,
        true,
        true,
        false,
        false,
        true,
        false,
        true,
        true,
        false,
        true,
        true,
        false,
        true,
        true,
        false,
        true,
        true,
        true,
        true,
        true,
        true,
        false,
        true,
        true,
        false,
        false,
        false,
        false,
        true,
        false,
        true,
        true,
        false,
        true,
        true,
        true,
        true,
        true,
        true,
        false,
        true,
        true,
        false,
        false,
        false,
        false,
        true,
        false,
        true,
        false,
        true,
        true,
        true,
        true,
        false,
        false,
        false,
        true,
        true,
        false,
        true,
        true,
        true,
        true,
        true,
        true,
        false,
        true,
        true,
        false,
        false,
        false,
        false,
        true,
        false,
        true,
        false,
        true,
        true,
        false,
        false,
        true,
        true,
        false,
        false,
        true,
        true,
        true,
        false,
        true,
        false,
        true,
        true,
        true,
        true,
        false,
        false,
        false,
        true,
        false,
        true,
        true,
        true,
        true,
        false,
        false,
        false,
        true,
        true,
        false,
        true,
        true,
        true,
        true,
        true,
        true,
        false,
        true,
        true,
        false,
        true,
        false,
        true,
        true,
        true,
        true,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        true,
        true,
        false,
        false,
        true,
        true,
        false,
        true,
        true,
        true,
        true,
        false,
        true,
        true,
        true,
        true,
        true,
        true,
        false,
        true,
        true,
        false,
        true,
        true,
        false,
        true,
        true,
        true,
        true,
        true,
        true,
        false,
        true,
        true,
        false,
        true,
        false,
        true,
        true,
        true,
        true,
        true,
        true,
        false,
        true,
        true,
        true,
        true,
        true,
        true,
        false,
        true,
        true,
        false,
        false,
        false,
        false,
        false,
        true,
        true,
        false,
        true,
        false,
        true,
        true,
        true,
        true,
        true,
        false,
        true,
        true,
        true,
        true,
        true,
        false,
        true,
        true,
        true,
        true,
        true,
        false,
        true,
        true,
        true,
        false,
        true,
        true,
        true,
        true,
        false,
        false,
        false,
        true,
        false,
        true,
        true,
        true,
        true,
        true,
        false,
        true,
        true,
        true,
        false,
        true,
        true,
        true,
        true,
        true,
        false,
        true,
        true,
        true,
        true,
        false,
        true,
        true,
        true,
        true,
        true,
        false,
        true,
        true,
        false,
        true,
        true,
        true
    ];
var tags = [
        [],
        ['broken_cluster'],
        ['consonant_syllable'],
        ['vowel_syllable'],
        ['broken_cluster'],
        ['broken_cluster'],
        [],
        [],
        ['broken_cluster'],
        ['broken_cluster'],
        ['broken_cluster'],
        ['standalone_cluster'],
        ['broken_cluster'],
        ['broken_cluster'],
        ['broken_cluster'],
        ['consonant_syllable'],
        ['broken_cluster'],
        ['symbol_cluster'],
        ['consonant_syllable'],
        ['consonant_syllable'],
        [],
        ['consonant_syllable'],
        ['consonant_syllable'],
        ['consonant_syllable'],
        ['consonant_syllable'],
        ['consonant_syllable'],
        ['consonant_syllable'],
        ['consonant_syllable'],
        ['vowel_syllable'],
        ['vowel_syllable'],
        [],
        ['vowel_syllable'],
        ['vowel_syllable'],
        ['vowel_syllable'],
        ['vowel_syllable'],
        ['vowel_syllable'],
        ['vowel_syllable'],
        ['vowel_syllable'],
        ['broken_cluster'],
        ['broken_cluster'],
        ['broken_cluster'],
        ['broken_cluster'],
        [],
        ['broken_cluster'],
        [],
        ['broken_cluster'],
        ['broken_cluster'],
        [],
        [],
        ['broken_cluster'],
        ['broken_cluster'],
        ['broken_cluster'],
        ['broken_cluster'],
        ['standalone_cluster'],
        ['standalone_cluster'],
        [],
        [],
        ['standalone_cluster'],
        ['standalone_cluster'],
        ['standalone_cluster'],
        ['standalone_cluster'],
        ['standalone_cluster'],
        ['standalone_cluster'],
        ['broken_cluster'],
        ['broken_cluster'],
        [
            'consonant_syllable',
            'broken_cluster'
        ],
        ['broken_cluster'],
        [],
        ['broken_cluster'],
        ['symbol_cluster'],
        [],
        ['symbol_cluster'],
        ['symbol_cluster'],
        ['consonant_syllable'],
        [],
        ['consonant_syllable'],
        ['consonant_syllable'],
        ['consonant_syllable'],
        [],
        ['consonant_syllable'],
        [],
        ['consonant_syllable'],
        ['consonant_syllable'],
        [],
        [],
        ['consonant_syllable'],
        ['consonant_syllable'],
        ['consonant_syllable'],
        ['consonant_syllable'],
        ['consonant_syllable'],
        ['consonant_syllable'],
        ['consonant_syllable'],
        [],
        ['consonant_syllable'],
        ['vowel_syllable'],
        [],
        ['vowel_syllable'],
        ['vowel_syllable'],
        ['vowel_syllable'],
        [],
        ['vowel_syllable'],
        [],
        ['vowel_syllable'],
        ['vowel_syllable'],
        [],
        [],
        ['vowel_syllable'],
        ['vowel_syllable'],
        ['vowel_syllable'],
        ['vowel_syllable'],
        ['vowel_syllable'],
        ['vowel_syllable'],
        ['vowel_syllable'],
        [],
        ['vowel_syllable'],
        ['broken_cluster'],
        ['broken_cluster'],
        [],
        ['broken_cluster'],
        ['broken_cluster'],
        ['broken_cluster'],
        [],
        ['broken_cluster'],
        [],
        ['broken_cluster'],
        ['broken_cluster'],
        [],
        [],
        [],
        ['broken_cluster'],
        ['broken_cluster'],
        [],
        [],
        ['broken_cluster'],
        ['broken_cluster'],
        ['standalone_cluster'],
        ['standalone_cluster'],
        ['standalone_cluster'],
        ['standalone_cluster'],
        [],
        ['standalone_cluster'],
        [],
        ['standalone_cluster'],
        ['standalone_cluster'],
        [],
        [],
        ['standalone_cluster'],
        ['standalone_cluster'],
        ['standalone_cluster'],
        ['standalone_cluster'],
        ['standalone_cluster'],
        ['standalone_cluster'],
        ['standalone_cluster'],
        [],
        ['standalone_cluster'],
        ['broken_cluster'],
        [],
        ['broken_cluster'],
        ['broken_cluster'],
        ['consonant_syllable'],
        ['consonant_syllable'],
        [
            'consonant_syllable',
            'broken_cluster'
        ],
        [
            'consonant_syllable',
            'broken_cluster'
        ],
        ['broken_cluster'],
        ['broken_cluster'],
        ['broken_cluster'],
        ['symbol_cluster'],
        ['symbol_cluster'],
        ['symbol_cluster'],
        ['consonant_syllable'],
        ['consonant_syllable'],
        [],
        ['consonant_syllable'],
        ['consonant_syllable'],
        ['consonant_syllable'],
        [],
        ['consonant_syllable'],
        [],
        ['consonant_syllable'],
        ['consonant_syllable'],
        [],
        [],
        [],
        ['consonant_syllable'],
        ['consonant_syllable'],
        [],
        [],
        ['consonant_syllable'],
        ['consonant_syllable'],
        ['consonant_syllable'],
        [],
        ['consonant_syllable'],
        ['consonant_syllable'],
        ['consonant_syllable'],
        ['consonant_syllable'],
        ['vowel_syllable'],
        ['vowel_syllable'],
        [],
        ['vowel_syllable'],
        ['vowel_syllable'],
        ['vowel_syllable'],
        [],
        ['vowel_syllable'],
        [],
        ['vowel_syllable'],
        ['vowel_syllable'],
        [],
        [],
        [],
        ['vowel_syllable'],
        ['vowel_syllable'],
        [],
        [],
        ['vowel_syllable'],
        ['vowel_syllable'],
        ['vowel_syllable'],
        [],
        ['vowel_syllable'],
        ['vowel_syllable'],
        ['vowel_syllable'],
        ['vowel_syllable'],
        ['broken_cluster'],
        [],
        ['broken_cluster'],
        ['broken_cluster'],
        ['broken_cluster'],
        ['broken_cluster'],
        ['broken_cluster'],
        [],
        ['broken_cluster'],
        ['broken_cluster'],
        [],
        [],
        [],
        [],
        ['broken_cluster'],
        ['broken_cluster'],
        [],
        [],
        ['broken_cluster'],
        ['standalone_cluster'],
        ['standalone_cluster'],
        [],
        ['standalone_cluster'],
        ['standalone_cluster'],
        ['standalone_cluster'],
        [],
        ['standalone_cluster'],
        [],
        ['standalone_cluster'],
        ['standalone_cluster'],
        [],
        [],
        [],
        ['standalone_cluster'],
        ['standalone_cluster'],
        [],
        [],
        ['standalone_cluster'],
        ['standalone_cluster'],
        ['standalone_cluster'],
        [],
        ['standalone_cluster'],
        ['standalone_cluster'],
        ['standalone_cluster'],
        ['standalone_cluster'],
        [],
        ['broken_cluster'],
        [],
        [
            'consonant_syllable',
            'broken_cluster'
        ],
        [
            'consonant_syllable',
            'broken_cluster'
        ],
        [
            'consonant_syllable',
            'broken_cluster'
        ],
        [
            'consonant_syllable',
            'broken_cluster'
        ],
        [
            'consonant_syllable',
            'broken_cluster'
        ],
        [
            'consonant_syllable',
            'broken_cluster'
        ],
        ['broken_cluster'],
        ['symbol_cluster'],
        ['consonant_syllable'],
        [],
        ['consonant_syllable'],
        ['consonant_syllable'],
        ['consonant_syllable'],
        ['consonant_syllable'],
        ['consonant_syllable'],
        [],
        ['consonant_syllable'],
        ['consonant_syllable'],
        [],
        [],
        [],
        [],
        ['consonant_syllable'],
        ['consonant_syllable'],
        [],
        [],
        ['consonant_syllable'],
        ['consonant_syllable'],
        ['vowel_syllable'],
        [],
        ['vowel_syllable'],
        ['vowel_syllable'],
        ['vowel_syllable'],
        ['vowel_syllable'],
        ['vowel_syllable'],
        [],
        ['vowel_syllable'],
        ['vowel_syllable'],
        [],
        [],
        [],
        [],
        ['vowel_syllable'],
        ['vowel_syllable'],
        [],
        [],
        ['vowel_syllable'],
        ['vowel_syllable'],
        ['broken_cluster'],
        ['broken_cluster'],
        [],
        ['broken_cluster'],
        ['broken_cluster'],
        ['broken_cluster'],
        ['broken_cluster'],
        ['broken_cluster'],
        ['broken_cluster'],
        [],
        ['broken_cluster'],
        ['broken_cluster'],
        [],
        [],
        [],
        [],
        ['broken_cluster'],
        [],
        ['standalone_cluster'],
        [],
        ['standalone_cluster'],
        ['standalone_cluster'],
        ['standalone_cluster'],
        ['standalone_cluster'],
        ['standalone_cluster'],
        [],
        ['standalone_cluster'],
        ['standalone_cluster'],
        [],
        [],
        [],
        [],
        ['standalone_cluster'],
        ['standalone_cluster'],
        [],
        [],
        ['standalone_cluster'],
        ['standalone_cluster'],
        [
            'consonant_syllable',
            'broken_cluster'
        ],
        [],
        [
            'consonant_syllable',
            'broken_cluster'
        ],
        [
            'consonant_syllable',
            'broken_cluster'
        ],
        [],
        [],
        [
            'consonant_syllable',
            'broken_cluster'
        ],
        [],
        [
            'consonant_syllable',
            'broken_cluster'
        ],
        [
            'consonant_syllable',
            'broken_cluster'
        ],
        [],
        [
            'consonant_syllable',
            'broken_cluster'
        ],
        [
            'consonant_syllable',
            'broken_cluster'
        ],
        [],
        ['consonant_syllable'],
        ['consonant_syllable'],
        [],
        ['consonant_syllable'],
        ['consonant_syllable'],
        ['consonant_syllable'],
        ['consonant_syllable'],
        ['consonant_syllable'],
        ['consonant_syllable'],
        [],
        ['consonant_syllable'],
        ['consonant_syllable'],
        [],
        [],
        [],
        [],
        ['consonant_syllable'],
        [],
        ['vowel_syllable'],
        ['vowel_syllable'],
        [],
        ['vowel_syllable'],
        ['vowel_syllable'],
        ['vowel_syllable'],
        ['vowel_syllable'],
        ['vowel_syllable'],
        ['vowel_syllable'],
        [],
        ['vowel_syllable'],
        ['vowel_syllable'],
        [],
        [],
        [],
        [],
        ['vowel_syllable'],
        [],
        ['broken_cluster'],
        [],
        ['broken_cluster'],
        ['broken_cluster'],
        ['broken_cluster'],
        ['broken_cluster'],
        [],
        [],
        [],
        ['standalone_cluster'],
        ['standalone_cluster'],
        [],
        ['standalone_cluster'],
        ['standalone_cluster'],
        ['standalone_cluster'],
        ['standalone_cluster'],
        ['standalone_cluster'],
        ['standalone_cluster'],
        [],
        ['standalone_cluster'],
        ['standalone_cluster'],
        [],
        [],
        [],
        [],
        ['standalone_cluster'],
        [],
        [
            'consonant_syllable',
            'broken_cluster'
        ],
        [],
        [
            'consonant_syllable',
            'broken_cluster'
        ],
        [
            'consonant_syllable',
            'broken_cluster'
        ],
        [],
        [],
        [
            'consonant_syllable',
            'broken_cluster'
        ],
        [
            'consonant_syllable',
            'broken_cluster'
        ],
        [],
        [],
        [
            'consonant_syllable',
            'broken_cluster'
        ],
        [
            'consonant_syllable',
            'broken_cluster'
        ],
        [
            'consonant_syllable',
            'broken_cluster'
        ],
        [],
        ['consonant_syllable'],
        [],
        ['consonant_syllable'],
        ['consonant_syllable'],
        ['consonant_syllable'],
        ['consonant_syllable'],
        [],
        [],
        [],
        ['vowel_syllable'],
        [],
        ['vowel_syllable'],
        ['vowel_syllable'],
        ['vowel_syllable'],
        ['vowel_syllable'],
        [],
        [],
        [],
        ['broken_cluster'],
        ['broken_cluster'],
        [],
        ['broken_cluster'],
        ['broken_cluster'],
        ['broken_cluster'],
        ['broken_cluster'],
        ['broken_cluster'],
        ['broken_cluster'],
        [],
        ['broken_cluster'],
        ['broken_cluster'],
        [],
        ['standalone_cluster'],
        [],
        ['standalone_cluster'],
        ['standalone_cluster'],
        ['standalone_cluster'],
        ['standalone_cluster'],
        [],
        [],
        [],
        [],
        [],
        [],
        [],
        [
            'consonant_syllable',
            'broken_cluster'
        ],
        [
            'consonant_syllable',
            'broken_cluster'
        ],
        [],
        [],
        [
            'consonant_syllable',
            'broken_cluster'
        ],
        [
            'consonant_syllable',
            'broken_cluster'
        ],
        [],
        [
            'consonant_syllable',
            'broken_cluster'
        ],
        [
            'consonant_syllable',
            'broken_cluster'
        ],
        ['consonant_syllable'],
        ['consonant_syllable'],
        [],
        ['consonant_syllable'],
        ['consonant_syllable'],
        ['consonant_syllable'],
        ['consonant_syllable'],
        ['consonant_syllable'],
        ['consonant_syllable'],
        [],
        ['consonant_syllable'],
        ['consonant_syllable'],
        [],
        ['vowel_syllable'],
        ['vowel_syllable'],
        [],
        ['vowel_syllable'],
        ['vowel_syllable'],
        ['vowel_syllable'],
        ['vowel_syllable'],
        ['vowel_syllable'],
        ['vowel_syllable'],
        [],
        ['vowel_syllable'],
        ['vowel_syllable'],
        [],
        ['broken_cluster'],
        [],
        ['broken_cluster'],
        ['broken_cluster'],
        ['broken_cluster'],
        ['broken_cluster'],
        ['standalone_cluster'],
        ['standalone_cluster'],
        [],
        ['standalone_cluster'],
        ['standalone_cluster'],
        ['standalone_cluster'],
        ['standalone_cluster'],
        ['standalone_cluster'],
        ['standalone_cluster'],
        [],
        ['standalone_cluster'],
        ['standalone_cluster'],
        [],
        [],
        [],
        [],
        [],
        [
            'consonant_syllable',
            'broken_cluster'
        ],
        [
            'consonant_syllable',
            'broken_cluster'
        ],
        [],
        ['consonant_syllable'],
        [],
        ['consonant_syllable'],
        ['consonant_syllable'],
        ['consonant_syllable'],
        ['consonant_syllable'],
        ['vowel_syllable'],
        [],
        ['vowel_syllable'],
        ['vowel_syllable'],
        ['vowel_syllable'],
        ['vowel_syllable'],
        ['broken_cluster'],
        [],
        ['broken_cluster'],
        ['broken_cluster'],
        ['broken_cluster'],
        ['broken_cluster'],
        ['broken_cluster'],
        [],
        ['broken_cluster'],
        ['broken_cluster'],
        ['standalone_cluster'],
        [],
        ['standalone_cluster'],
        ['standalone_cluster'],
        ['standalone_cluster'],
        ['standalone_cluster'],
        [],
        [],
        [],
        ['consonant_syllable'],
        [],
        ['consonant_syllable'],
        ['consonant_syllable'],
        ['consonant_syllable'],
        ['consonant_syllable'],
        ['consonant_syllable'],
        [],
        ['consonant_syllable'],
        ['consonant_syllable'],
        ['vowel_syllable'],
        [],
        ['vowel_syllable'],
        ['vowel_syllable'],
        ['vowel_syllable'],
        ['vowel_syllable'],
        ['vowel_syllable'],
        [],
        ['vowel_syllable'],
        ['vowel_syllable'],
        ['broken_cluster'],
        ['standalone_cluster'],
        [],
        ['standalone_cluster'],
        ['standalone_cluster'],
        ['standalone_cluster'],
        ['standalone_cluster'],
        ['standalone_cluster'],
        [],
        ['standalone_cluster'],
        ['standalone_cluster'],
        [],
        ['consonant_syllable'],
        ['vowel_syllable'],
        ['standalone_cluster']
    ];
var indicMachine = {
        stateTable: stateTable,
        accepting: accepting,
        tags: tags
    };
var categories = [
        'O',
        'IND',
        'S',
        'GB',
        'B',
        'FM',
        'CGJ',
        'VMAbv',
        'VMPst',
        'VAbv',
        'VPst',
        'CMBlw',
        'VPre',
        'VBlw',
        'H',
        'VMBlw',
        'CMAbv',
        'MBlw',
        'CS',
        'R',
        'SUB',
        'MPst',
        'MPre',
        'FAbv',
        'FPst',
        'FBlw',
        'SMAbv',
        'SMBlw',
        'VMPre',
        'ZWNJ',
        'ZWJ',
        'WJ',
        'VS',
        'N',
        'HN',
        'MAbv'
    ];
var decompositions$1 = {
        '2507': [
            2503,
            2494
        ],
        '2508': [
            2503,
            2519
        ],
        '2888': [
            2887,
            2902
        ],
        '2891': [
            2887,
            2878
        ],
        '2892': [
            2887,
            2903
        ],
        '3018': [
            3014,
            3006
        ],
        '3019': [
            3015,
            3006
        ],
        '3020': [
            3014,
            3031
        ],
        '3144': [
            3142,
            3158
        ],
        '3264': [
            3263,
            3285
        ],
        '3271': [
            3270,
            3285
        ],
        '3272': [
            3270,
            3286
        ],
        '3274': [
            3270,
            3266
        ],
        '3275': [
            3270,
            3266,
            3285
        ],
        '3402': [
            3398,
            3390
        ],
        '3403': [
            3399,
            3390
        ],
        '3404': [
            3398,
            3415
        ],
        '3546': [
            3545,
            3530
        ],
        '3548': [
            3545,
            3535
        ],
        '3549': [
            3545,
            3535,
            3530
        ],
        '3550': [
            3545,
            3551
        ],
        '3635': [
            3661,
            3634
        ],
        '3763': [
            3789,
            3762
        ],
        '3955': [
            3953,
            3954
        ],
        '3957': [
            3953,
            3956
        ],
        '3958': [
            4018,
            3968
        ],
        '3959': [
            4018,
            3953,
            3968
        ],
        '3960': [
            4019,
            3968
        ],
        '3961': [
            4019,
            3953,
            3968
        ],
        '3969': [
            3953,
            3968
        ],
        '6971': [
            6970,
            6965
        ],
        '6973': [
            6972,
            6965
        ],
        '6976': [
            6974,
            6965
        ],
        '6977': [
            6975,
            6965
        ],
        '6979': [
            6978,
            6965
        ],
        '69934': [
            69937,
            69927
        ],
        '69935': [
            69938,
            69927
        ],
        '70475': [
            70471,
            70462
        ],
        '70476': [
            70471,
            70487
        ],
        '70843': [
            70841,
            70842
        ],
        '70844': [
            70841,
            70832
        ],
        '70846': [
            70841,
            70845
        ],
        '71098': [
            71096,
            71087
        ],
        '71099': [
            71097,
            71087
        ]
    };
var stateTable$1 = [
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            2,
            2,
            3,
            4,
            4,
            5,
            0,
            6,
            7,
            8,
            9,
            10,
            11,
            12,
            13,
            14,
            15,
            16,
            0,
            17,
            18,
            11,
            19,
            20,
            21,
            22,
            0,
            0,
            23,
            0,
            0,
            2,
            0,
            24,
            0,
            25
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            26,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            27,
            28,
            0,
            0,
            0,
            0,
            27,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            29,
            0,
            30,
            31,
            32,
            33,
            34,
            35,
            36,
            37,
            38,
            39,
            40,
            0,
            0,
            41,
            35,
            42,
            43,
            44,
            45,
            0,
            0,
            46,
            0,
            0,
            0,
            39,
            0,
            0,
            47
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            5,
            0,
            6,
            7,
            0,
            0,
            0,
            0,
            0,
            0,
            14,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            20,
            21,
            22,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            5,
            0,
            0,
            7,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            20,
            21,
            22,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            5,
            0,
            6,
            7,
            8,
            9,
            0,
            0,
            12,
            0,
            14,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            20,
            21,
            22,
            0,
            0,
            23,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            5,
            0,
            6,
            7,
            0,
            9,
            0,
            0,
            0,
            0,
            14,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            20,
            21,
            22,
            0,
            0,
            23,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            5,
            0,
            6,
            7,
            8,
            9,
            10,
            11,
            12,
            13,
            14,
            0,
            16,
            0,
            0,
            18,
            11,
            19,
            20,
            21,
            22,
            0,
            0,
            23,
            0,
            0,
            0,
            0,
            0,
            0,
            25
        ],
        [
            0,
            0,
            0,
            0,
            0,
            5,
            0,
            6,
            7,
            8,
            9,
            0,
            11,
            12,
            0,
            14,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            20,
            21,
            22,
            0,
            0,
            23,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            5,
            0,
            6,
            7,
            0,
            9,
            0,
            0,
            12,
            0,
            14,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            20,
            21,
            22,
            0,
            0,
            23,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            18,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            5,
            0,
            0,
            7,
            0,
            0,
            0,
            0,
            0,
            0,
            14,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            20,
            21,
            22,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            5,
            0,
            6,
            7,
            8,
            9,
            10,
            11,
            12,
            13,
            14,
            15,
            16,
            0,
            0,
            18,
            11,
            19,
            20,
            21,
            22,
            0,
            0,
            23,
            0,
            0,
            0,
            0,
            0,
            0,
            25
        ],
        [
            0,
            0,
            0,
            0,
            0,
            5,
            0,
            6,
            7,
            8,
            9,
            0,
            11,
            12,
            0,
            14,
            0,
            0,
            0,
            0,
            0,
            11,
            0,
            20,
            21,
            22,
            0,
            0,
            23,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            4,
            4,
            5,
            0,
            6,
            7,
            8,
            9,
            10,
            11,
            12,
            13,
            14,
            15,
            16,
            0,
            0,
            18,
            11,
            19,
            20,
            21,
            22,
            0,
            0,
            23,
            0,
            0,
            0,
            0,
            0,
            0,
            25
        ],
        [
            0,
            0,
            0,
            0,
            0,
            5,
            0,
            6,
            7,
            8,
            9,
            48,
            11,
            12,
            13,
            14,
            48,
            16,
            0,
            0,
            18,
            11,
            19,
            20,
            21,
            22,
            0,
            0,
            23,
            0,
            0,
            0,
            49,
            0,
            0,
            25
        ],
        [
            0,
            0,
            0,
            0,
            0,
            5,
            0,
            6,
            7,
            8,
            9,
            0,
            11,
            12,
            0,
            14,
            0,
            16,
            0,
            0,
            0,
            11,
            0,
            20,
            21,
            22,
            0,
            0,
            23,
            0,
            0,
            0,
            0,
            0,
            0,
            25
        ],
        [
            0,
            0,
            0,
            0,
            0,
            5,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            20,
            21,
            22,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            5,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            21,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            5,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            21,
            22,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            5,
            0,
            6,
            7,
            0,
            0,
            0,
            0,
            0,
            0,
            14,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            20,
            21,
            22,
            0,
            0,
            23,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            50,
            0,
            51,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            5,
            0,
            6,
            7,
            8,
            9,
            0,
            11,
            12,
            0,
            14,
            0,
            16,
            0,
            0,
            0,
            11,
            0,
            20,
            21,
            22,
            0,
            0,
            23,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            27,
            28,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            28,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            29,
            0,
            30,
            31,
            0,
            0,
            0,
            0,
            0,
            0,
            38,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            43,
            44,
            45,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            29,
            0,
            0,
            31,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            43,
            44,
            45,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            29,
            0,
            30,
            31,
            32,
            33,
            0,
            0,
            36,
            0,
            38,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            43,
            44,
            45,
            0,
            0,
            46,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            29,
            0,
            30,
            31,
            0,
            33,
            0,
            0,
            0,
            0,
            38,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            43,
            44,
            45,
            0,
            0,
            46,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            29,
            0,
            30,
            31,
            32,
            33,
            34,
            35,
            36,
            37,
            38,
            0,
            40,
            0,
            0,
            41,
            35,
            42,
            43,
            44,
            45,
            0,
            0,
            46,
            0,
            0,
            0,
            0,
            0,
            0,
            47
        ],
        [
            0,
            0,
            0,
            0,
            0,
            29,
            0,
            30,
            31,
            32,
            33,
            0,
            35,
            36,
            0,
            38,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            43,
            44,
            45,
            0,
            0,
            46,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            29,
            0,
            30,
            31,
            0,
            33,
            0,
            0,
            36,
            0,
            38,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            43,
            44,
            45,
            0,
            0,
            46,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            41,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            29,
            0,
            0,
            31,
            0,
            0,
            0,
            0,
            0,
            0,
            38,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            43,
            44,
            45,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            29,
            0,
            30,
            31,
            32,
            33,
            34,
            35,
            36,
            37,
            38,
            39,
            40,
            0,
            0,
            41,
            35,
            42,
            43,
            44,
            45,
            0,
            0,
            46,
            0,
            0,
            0,
            0,
            0,
            0,
            47
        ],
        [
            0,
            0,
            0,
            0,
            0,
            29,
            0,
            30,
            31,
            32,
            33,
            0,
            35,
            36,
            0,
            38,
            0,
            0,
            0,
            0,
            0,
            35,
            0,
            43,
            44,
            45,
            0,
            0,
            46,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            29,
            0,
            30,
            31,
            32,
            33,
            52,
            35,
            36,
            37,
            38,
            52,
            40,
            0,
            0,
            41,
            35,
            42,
            43,
            44,
            45,
            0,
            0,
            46,
            0,
            0,
            0,
            53,
            0,
            0,
            47
        ],
        [
            0,
            0,
            0,
            0,
            0,
            29,
            0,
            30,
            31,
            32,
            33,
            0,
            35,
            36,
            0,
            38,
            0,
            40,
            0,
            0,
            0,
            35,
            0,
            43,
            44,
            45,
            0,
            0,
            46,
            0,
            0,
            0,
            0,
            0,
            0,
            47
        ],
        [
            0,
            0,
            0,
            0,
            0,
            29,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            43,
            44,
            45,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            29,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            44,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            29,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            44,
            45,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            29,
            0,
            30,
            31,
            0,
            0,
            0,
            0,
            0,
            0,
            38,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            43,
            44,
            45,
            0,
            0,
            46,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            29,
            0,
            30,
            31,
            32,
            33,
            0,
            35,
            36,
            0,
            38,
            0,
            40,
            0,
            0,
            0,
            35,
            0,
            43,
            44,
            45,
            0,
            0,
            46,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            5,
            0,
            6,
            7,
            8,
            9,
            48,
            11,
            12,
            13,
            14,
            0,
            16,
            0,
            0,
            18,
            11,
            19,
            20,
            21,
            22,
            0,
            0,
            23,
            0,
            0,
            0,
            0,
            0,
            0,
            25
        ],
        [
            0,
            0,
            0,
            0,
            0,
            5,
            0,
            6,
            7,
            8,
            9,
            48,
            11,
            12,
            13,
            14,
            48,
            16,
            0,
            0,
            18,
            11,
            19,
            20,
            21,
            22,
            0,
            0,
            23,
            0,
            0,
            0,
            0,
            0,
            0,
            25
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            51,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            54,
            0,
            0
        ],
        [
            0,
            0,
            0,
            0,
            0,
            29,
            0,
            30,
            31,
            32,
            33,
            52,
            35,
            36,
            37,
            38,
            0,
            40,
            0,
            0,
            41,
            35,
            42,
            43,
            44,
            45,
            0,
            0,
            46,
            0,
            0,
            0,
            0,
            0,
            0,
            47
        ],
        [
            0,
            0,
            0,
            0,
            0,
            29,
            0,
            30,
            31,
            32,
            33,
            52,
            35,
            36,
            37,
            38,
            52,
            40,
            0,
            0,
            41,
            35,
            42,
            43,
            44,
            45,
            0,
            0,
            46,
            0,
            0,
            0,
            0,
            0,
            0,
            47
        ],
        [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            50,
            0,
            51,
            0
        ]
    ];
var accepting$1 = [
        false,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        false,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true
    ];
var tags$1 = [
        [],
        ['broken_cluster'],
        ['independent_cluster'],
        ['symbol_cluster'],
        ['standard_cluster'],
        ['broken_cluster'],
        ['broken_cluster'],
        ['broken_cluster'],
        ['broken_cluster'],
        ['broken_cluster'],
        ['broken_cluster'],
        ['broken_cluster'],
        ['broken_cluster'],
        [],
        ['broken_cluster'],
        ['broken_cluster'],
        ['broken_cluster'],
        ['broken_cluster'],
        ['broken_cluster'],
        ['broken_cluster'],
        ['broken_cluster'],
        ['broken_cluster'],
        ['broken_cluster'],
        ['broken_cluster'],
        ['numeral_cluster'],
        ['broken_cluster'],
        ['independent_cluster'],
        ['symbol_cluster'],
        ['symbol_cluster'],
        ['standard_cluster'],
        ['standard_cluster'],
        ['standard_cluster'],
        ['standard_cluster'],
        ['standard_cluster'],
        ['standard_cluster'],
        ['standard_cluster'],
        ['standard_cluster'],
        ['virama_terminated_cluster'],
        ['standard_cluster'],
        ['standard_cluster'],
        ['standard_cluster'],
        ['standard_cluster'],
        ['standard_cluster'],
        ['standard_cluster'],
        ['standard_cluster'],
        ['standard_cluster'],
        ['standard_cluster'],
        ['standard_cluster'],
        ['broken_cluster'],
        ['broken_cluster'],
        ['numeral_cluster'],
        ['number_joiner_terminated_cluster'],
        ['standard_cluster'],
        ['standard_cluster'],
        ['numeral_cluster']
    ];
var useData = {
        categories: categories,
        decompositions: decompositions$1,
        stateTable: stateTable$1,
        accepting: accepting$1,
        tags: tags$1
    };
var CATEGORIES = {
        X: 1 << 0,
        C: 1 << 1,
        V: 1 << 2,
        N: 1 << 3,
        H: 1 << 4,
        ZWNJ: 1 << 5,
        ZWJ: 1 << 6,
        M: 1 << 7,
        SM: 1 << 8,
        VD: 1 << 9,
        A: 1 << 10,
        Placeholder: 1 << 11,
        Dotted_Circle: 1 << 12,
        RS: 1 << 13,
        Coeng: 1 << 14,
        Repha: 1 << 15,
        Ra: 1 << 16,
        CM: 1 << 17,
        Symbol: 1 << 18
    };
var POSITIONS = {
        Start: 1 << 0,
        Ra_To_Become_Reph: 1 << 1,
        Pre_M: 1 << 2,
        Pre_C: 1 << 3,
        Base_C: 1 << 4,
        After_Main: 1 << 5,
        Above_C: 1 << 6,
        Before_Sub: 1 << 7,
        Below_C: 1 << 8,
        After_Sub: 1 << 9,
        Before_Post: 1 << 10,
        Post_C: 1 << 11,
        After_Post: 1 << 12,
        Final_C: 1 << 13,
        SMVD: 1 << 14,
        End: 1 << 15
    };
var CONSONANT_FLAGS = CATEGORIES.C | CATEGORIES.Ra | CATEGORIES.CM | CATEGORIES.V | CATEGORIES.Placeholder | CATEGORIES.Dotted_Circle;
var JOINER_FLAGS = CATEGORIES.ZWJ | CATEGORIES.ZWNJ;
var HALANT_OR_COENG_FLAGS = CATEGORIES.H | CATEGORIES.Coeng;
var INDIC_CONFIGS = {
        Default: {
            hasOldSpec: false,
            virama: 0,
            basePos: 'Last',
            rephPos: POSITIONS.Before_Post,
            rephMode: 'Implicit',
            blwfMode: 'Pre_And_Post'
        },
        Devanagari: {
            hasOldSpec: true,
            virama: 2381,
            basePos: 'Last',
            rephPos: POSITIONS.Before_Post,
            rephMode: 'Implicit',
            blwfMode: 'Pre_And_Post'
        },
        Bengali: {
            hasOldSpec: true,
            virama: 2509,
            basePos: 'Last',
            rephPos: POSITIONS.After_Sub,
            rephMode: 'Implicit',
            blwfMode: 'Pre_And_Post'
        },
        Gurmukhi: {
            hasOldSpec: true,
            virama: 2637,
            basePos: 'Last',
            rephPos: POSITIONS.Before_Sub,
            rephMode: 'Implicit',
            blwfMode: 'Pre_And_Post'
        },
        Gujarati: {
            hasOldSpec: true,
            virama: 2765,
            basePos: 'Last',
            rephPos: POSITIONS.Before_Post,
            rephMode: 'Implicit',
            blwfMode: 'Pre_And_Post'
        },
        Oriya: {
            hasOldSpec: true,
            virama: 2893,
            basePos: 'Last',
            rephPos: POSITIONS.After_Main,
            rephMode: 'Implicit',
            blwfMode: 'Pre_And_Post'
        },
        Tamil: {
            hasOldSpec: true,
            virama: 3021,
            basePos: 'Last',
            rephPos: POSITIONS.After_Post,
            rephMode: 'Implicit',
            blwfMode: 'Pre_And_Post'
        },
        Telugu: {
            hasOldSpec: true,
            virama: 3149,
            basePos: 'Last',
            rephPos: POSITIONS.After_Post,
            rephMode: 'Explicit',
            blwfMode: 'Post_Only'
        },
        Kannada: {
            hasOldSpec: true,
            virama: 3277,
            basePos: 'Last',
            rephPos: POSITIONS.After_Post,
            rephMode: 'Implicit',
            blwfMode: 'Post_Only'
        },
        Malayalam: {
            hasOldSpec: true,
            virama: 3405,
            basePos: 'Last',
            rephPos: POSITIONS.After_Main,
            rephMode: 'Log_Repha',
            blwfMode: 'Pre_And_Post'
        },
        Khmer: {
            hasOldSpec: false,
            virama: 6098,
            basePos: 'First',
            rephPos: POSITIONS.Ra_To_Become_Reph,
            rephMode: 'Vis_Repha',
            blwfMode: 'Pre_And_Post'
        }
    };
var INDIC_DECOMPOSITIONS = {
        6078: [
            6081,
            6078
        ],
        6079: [
            6081,
            6079
        ],
        6080: [
            6081,
            6080
        ],
        6084: [
            6081,
            6084
        ],
        6085: [
            6081,
            6085
        ]
    };
var _class$6;
var _temp$2;
var decompositions = useData.decompositions;
var trie$1 = new UnicodeTrie(Buffer('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', 'base64'));
var stateMachine = new StateMachine(indicMachine);
var IndicShaper = (_temp$2 = _class$6 = function (_DefaultShaper) {
        _inherits(IndicShaper, _DefaultShaper);
        function IndicShaper() {
            _classCallCheck(this, IndicShaper);
            return _possibleConstructorReturn(this, _DefaultShaper.apply(this, arguments));
        }
        IndicShaper.planFeatures = function planFeatures(plan) {
            plan.addStage(setupSyllables);
            plan.addStage([
                'locl',
                'ccmp'
            ]);
            plan.addStage(initialReordering);
            plan.addStage('nukt');
            plan.addStage('akhn');
            plan.addStage('rphf', false);
            plan.addStage('rkrf');
            plan.addStage('pref', false);
            plan.addStage('blwf', false);
            plan.addStage('abvf', false);
            plan.addStage('half', false);
            plan.addStage('pstf', false);
            plan.addStage('vatu');
            plan.addStage('cjct');
            plan.addStage('cfar', false);
            plan.addStage(finalReordering);
            plan.addStage({
                local: ['init'],
                global: [
                    'pres',
                    'abvs',
                    'blws',
                    'psts',
                    'haln',
                    'dist',
                    'abvm',
                    'blwm',
                    'calt',
                    'clig'
                ]
            });
            plan.unicodeScript = fromOpenType(plan.script);
            plan.indicConfig = INDIC_CONFIGS[plan.unicodeScript] || INDIC_CONFIGS.Default;
            plan.isOldSpec = plan.indicConfig.hasOldSpec && plan.script[plan.script.length - 1] !== '2';
        };
        IndicShaper.assignFeatures = function assignFeatures(plan, glyphs) {
            var _loop = function _loop(i) {
                var codepoint = glyphs[i].codePoints[0];
                var d = INDIC_DECOMPOSITIONS[codepoint] || decompositions[codepoint];
                if (d) {
                    var decomposed = d.map(function (c) {
                            var g = plan.font.glyphForCodePoint(c);
                            return new GlyphInfo(plan.font, g.id, [c], glyphs[i].features);
                        });
                    glyphs.splice.apply(glyphs, [
                        i,
                        1
                    ].concat(decomposed));
                }
            };
            for (var i = glyphs.length - 1; i >= 0; i--) {
                _loop(i);
            }
        };
        return IndicShaper;
    }(DefaultShaper), _class$6.zeroMarkWidths = 'NONE', _temp$2);
function indicCategory(glyph) {
    return trie$1.get(glyph.codePoints[0]) >> 8;
}
function indicPosition(glyph) {
    return 1 << (trie$1.get(glyph.codePoints[0]) & 255);
}
var IndicInfo = function IndicInfo(category, position, syllableType, syllable) {
    _classCallCheck(this, IndicInfo);
    this.category = category;
    this.position = position;
    this.syllableType = syllableType;
    this.syllable = syllable;
};
function setupSyllables(font, glyphs) {
    var syllable = 0;
    var last = 0;
    for (var _iterator = stateMachine.match(glyphs.map(indicCategory)), _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _getIterator(_iterator);;) {
        var _ref;
        if (_isArray) {
            if (_i >= _iterator.length)
                break;
            _ref = _iterator[_i++];
        } else {
            _i = _iterator.next();
            if (_i.done)
                break;
            _ref = _i.value;
        }
        var _ref2 = _ref, start = _ref2[0], end = _ref2[1], tags = _ref2[2];
        if (start > last) {
            ++syllable;
            for (var _i2 = last; _i2 < start; _i2++) {
                glyphs[_i2].shaperInfo = new IndicInfo(CATEGORIES.X, POSITIONS.End, 'non_indic_cluster', syllable);
            }
        }
        ++syllable;
        for (var _i3 = start; _i3 <= end; _i3++) {
            glyphs[_i3].shaperInfo = new IndicInfo(1 << indicCategory(glyphs[_i3]), indicPosition(glyphs[_i3]), tags[0], syllable);
        }
        last = end + 1;
    }
    if (last < glyphs.length) {
        ++syllable;
        for (var i = last; i < glyphs.length; i++) {
            glyphs[i].shaperInfo = new IndicInfo(CATEGORIES.X, POSITIONS.End, 'non_indic_cluster', syllable);
        }
    }
}
function isConsonant(glyph) {
    return glyph.shaperInfo.category & CONSONANT_FLAGS;
}
function isJoiner(glyph) {
    return glyph.shaperInfo.category & JOINER_FLAGS;
}
function isHalantOrCoeng(glyph) {
    return glyph.shaperInfo.category & HALANT_OR_COENG_FLAGS;
}
function wouldSubstitute(glyphs, feature) {
    for (var _iterator2 = glyphs, _isArray2 = Array.isArray(_iterator2), _i4 = 0, _iterator2 = _isArray2 ? _iterator2 : _getIterator(_iterator2);;) {
        var _glyph$features;
        var _ref3;
        if (_isArray2) {
            if (_i4 >= _iterator2.length)
                break;
            _ref3 = _iterator2[_i4++];
        } else {
            _i4 = _iterator2.next();
            if (_i4.done)
                break;
            _ref3 = _i4.value;
        }
        var glyph = _ref3;
        glyph.features = (_glyph$features = {}, _glyph$features[feature] = true, _glyph$features);
    }
    var GSUB = glyphs[0]._font._layoutEngine.engine.GSUBProcessor;
    GSUB.applyFeatures([feature], glyphs);
    return glyphs.length === 1;
}
function consonantPosition(font, consonant, virama) {
    var glyphs = [
            virama,
            consonant,
            virama
        ];
    if (wouldSubstitute(glyphs.slice(0, 2), 'blwf') || wouldSubstitute(glyphs.slice(1, 3), 'blwf')) {
        return POSITIONS.Below_C;
    } else if (wouldSubstitute(glyphs.slice(0, 2), 'pstf') || wouldSubstitute(glyphs.slice(1, 3), 'pstf')) {
        return POSITIONS.Post_C;
    } else if (wouldSubstitute(glyphs.slice(0, 2), 'pref') || wouldSubstitute(glyphs.slice(1, 3), 'pref')) {
        return POSITIONS.Post_C;
    }
    return POSITIONS.Base_C;
}
function initialReordering(font, glyphs, plan) {
    var indicConfig = plan.indicConfig;
    var features = font._layoutEngine.engine.GSUBProcessor.features;
    var dottedCircle = font.glyphForCodePoint(9676).id;
    var virama = font.glyphForCodePoint(indicConfig.virama).id;
    if (virama) {
        var info = new GlyphInfo(font, virama, [indicConfig.virama]);
        for (var i = 0; i < glyphs.length; i++) {
            if (glyphs[i].shaperInfo.position === POSITIONS.Base_C) {
                glyphs[i].shaperInfo.position = consonantPosition(font, glyphs[i].copy(), info);
            }
        }
    }
    for (var start = 0, end = nextSyllable(glyphs, 0); start < glyphs.length; start = end, end = nextSyllable(glyphs, start)) {
        var _glyphs$start$shaperI = glyphs[start].shaperInfo, category = _glyphs$start$shaperI.category, syllableType = _glyphs$start$shaperI.syllableType;
        if (syllableType === 'symbol_cluster' || syllableType === 'non_indic_cluster') {
            continue;
        }
        if (syllableType === 'broken_cluster' && dottedCircle) {
            var g = new GlyphInfo(font, dottedCircle, [9676]);
            g.shaperInfo = new IndicInfo(1 << indicCategory(g), indicPosition(g), glyphs[start].shaperInfo.syllableType, glyphs[start].shaperInfo.syllable);
            var _i5 = start;
            while (_i5 < end && glyphs[_i5].shaperInfo.category === CATEGORIES.Repha) {
                _i5++;
            }
            glyphs.splice(_i5++, 0, g);
            end++;
        }
        var base = end;
        var limit = start;
        var hasReph = false;
        if (indicConfig.rephPos !== POSITIONS.Ra_To_Become_Reph && features.rphf && start + 3 <= end && (indicConfig.rephMode === 'Implicit' && !isJoiner(glyphs[start + 2]) || indicConfig.rephMode === 'Explicit' && glyphs[start + 2].shaperInfo.category === CATEGORIES.ZWJ)) {
            var _g = [
                    glyphs[start].copy(),
                    glyphs[start + 1].copy(),
                    glyphs[start + 2].copy()
                ];
            if (wouldSubstitute(_g.slice(0, 2), 'rphf') || indicConfig.rephMode === 'Explicit' && wouldSubstitute(_g, 'rphf')) {
                limit += 2;
                while (limit < end && isJoiner(glyphs[limit])) {
                    limit++;
                }
                base = start;
                hasReph = true;
            }
        } else if (indicConfig.rephMode === 'Log_Repha' && glyphs[start].shaperInfo.category === CATEGORIES.Repha) {
            limit++;
            while (limit < end && isJoiner(glyphs[limit])) {
                limit++;
            }
            base = start;
            hasReph = true;
        }
        switch (indicConfig.basePos) {
        case 'Last': {
                var _i6 = end;
                var seenBelow = false;
                do {
                    var _info = glyphs[--_i6].shaperInfo;
                    if (isConsonant(glyphs[_i6])) {
                        if (_info.position !== POSITIONS.Below_C && (_info.position !== POSITIONS.Post_C || seenBelow)) {
                            base = _i6;
                            break;
                        }
                        if (_info.position === POSITIONS.Below_C) {
                            seenBelow = true;
                        }
                        base = _i6;
                    } else if (start < _i6 && _info.category === CATEGORIES.ZWJ && glyphs[_i6 - 1].shaperInfo.category === CATEGORIES.H) {
                        break;
                    }
                } while (_i6 > limit);
                break;
            }
        case 'First': {
                base = start;
                for (var _i7 = base + 1; _i7 < end; _i7++) {
                    if (isConsonant(glyphs[_i7])) {
                        glyphs[_i7].shaperInfo.position = POSITIONS.Below_C;
                    }
                }
            }
        }
        if (hasReph && base === start && limit - base <= 2) {
            hasReph = false;
        }
        for (var _i8 = start; _i8 < base; _i8++) {
            var _info2 = glyphs[_i8].shaperInfo;
            _info2.position = Math.min(POSITIONS.Pre_C, _info2.position);
        }
        if (base < end) {
            glyphs[base].shaperInfo.position = POSITIONS.Base_C;
        }
        for (var _i9 = base + 1; _i9 < end; _i9++) {
            if (glyphs[_i9].shaperInfo.category === CATEGORIES.M) {
                for (var j = _i9 + 1; j < end; j++) {
                    if (isConsonant(glyphs[j])) {
                        glyphs[j].shaperInfo.position = POSITIONS.Final_C;
                        break;
                    }
                }
                break;
            }
        }
        if (hasReph) {
            glyphs[start].shaperInfo.position = POSITIONS.Ra_To_Become_Reph;
        }
        if (plan.isOldSpec) {
            var disallowDoubleHalants = plan.unicodeScript !== 'Malayalam';
            for (var _i10 = base + 1; _i10 < end; _i10++) {
                if (glyphs[_i10].shaperInfo.category === CATEGORIES.H) {
                    var _j = void 0;
                    for (_j = end - 1; _j > _i10; _j--) {
                        if (isConsonant(glyphs[_j]) || disallowDoubleHalants && glyphs[_j].shaperInfo.category === CATEGORIES.H) {
                            break;
                        }
                    }
                    if (glyphs[_j].shaperInfo.category !== CATEGORIES.H && _j > _i10) {
                        var t = glyphs[_i10];
                        glyphs.splice.apply(glyphs, [
                            _i10,
                            0
                        ].concat(glyphs.splice(_i10 + 1, _j - _i10)));
                        glyphs[_j] = t;
                    }
                    break;
                }
            }
        }
        var lastPos = POSITIONS.Start;
        for (var _i11 = start; _i11 < end; _i11++) {
            var _info3 = glyphs[_i11].shaperInfo;
            if (_info3.category & (JOINER_FLAGS | CATEGORIES.N | CATEGORIES.RS | CATEGORIES.CM | HALANT_OR_COENG_FLAGS & _info3.category)) {
                _info3.position = lastPos;
                if (_info3.category === CATEGORIES.H && _info3.position === POSITIONS.Pre_M) {
                    for (var _j2 = _i11; _j2 > start; _j2--) {
                        if (glyphs[_j2 - 1].shaperInfo.position !== POSITIONS.Pre_M) {
                            _info3.position = glyphs[_j2 - 1].shaperInfo.position;
                            break;
                        }
                    }
                }
            } else if (_info3.position !== POSITIONS.SMVD) {
                lastPos = _info3.position;
            }
        }
        var last = base;
        for (var _i12 = base + 1; _i12 < end; _i12++) {
            if (isConsonant(glyphs[_i12])) {
                for (var _j3 = last + 1; _j3 < _i12; _j3++) {
                    if (glyphs[_j3].shaperInfo.position < POSITIONS.SMVD) {
                        glyphs[_j3].shaperInfo.position = glyphs[_i12].shaperInfo.position;
                    }
                }
                last = _i12;
            } else if (glyphs[_i12].shaperInfo.category === CATEGORIES.M) {
                last = _i12;
            }
        }
        var arr = glyphs.slice(start, end);
        arr.sort(function (a, b) {
            return a.shaperInfo.position - b.shaperInfo.position;
        });
        glyphs.splice.apply(glyphs, [
            start,
            arr.length
        ].concat(arr));
        for (var _i13 = start; _i13 < end; _i13++) {
            if (glyphs[_i13].shaperInfo.position === POSITIONS.Base_C) {
                base = _i13;
                break;
            }
        }
        for (var _i14 = start; _i14 < end && glyphs[_i14].shaperInfo.position === POSITIONS.Ra_To_Become_Reph; _i14++) {
            glyphs[_i14].features.rphf = true;
        }
        var blwf = !plan.isOldSpec && indicConfig.blwfMode === 'Pre_And_Post';
        for (var _i15 = start; _i15 < base; _i15++) {
            glyphs[_i15].features.half = true;
            if (blwf) {
                glyphs[_i15].features.blwf = true;
            }
        }
        for (var _i16 = base + 1; _i16 < end; _i16++) {
            glyphs[_i16].features.abvf = true;
            glyphs[_i16].features.pstf = true;
            glyphs[_i16].features.blwf = true;
        }
        if (plan.isOldSpec && plan.unicodeScript === 'Devanagari') {
            for (var _i17 = start; _i17 + 1 < base; _i17++) {
                if (glyphs[_i17].shaperInfo.category === CATEGORIES.Ra && glyphs[_i17 + 1].shaperInfo.category === CATEGORIES.H && (_i17 + 1 === base || glyphs[_i17 + 2].shaperInfo.category === CATEGORIES.ZWJ)) {
                    glyphs[_i17].features.blwf = true;
                    glyphs[_i17 + 1].features.blwf = true;
                }
            }
        }
        var prefLen = 2;
        if (features.pref && base + prefLen < end) {
            for (var _i18 = base + 1; _i18 + prefLen - 1 < end; _i18++) {
                var _g2 = [
                        glyphs[_i18].copy(),
                        glyphs[_i18 + 1].copy()
                    ];
                if (wouldSubstitute(_g2, 'pref')) {
                    for (var _j4 = 0; _j4 < prefLen; _j4++) {
                        glyphs[_i18++].features.pref = true;
                    }
                    if (features.cfar) {
                        for (; _i18 < end; _i18++) {
                            glyphs[_i18].features.cfar = true;
                        }
                    }
                    break;
                }
            }
        }
        for (var _i19 = start + 1; _i19 < end; _i19++) {
            if (isJoiner(glyphs[_i19])) {
                var nonJoiner = glyphs[_i19].shaperInfo.category === CATEGORIES.ZWNJ;
                var _j5 = _i19;
                do {
                    _j5--;
                    if (nonJoiner) {
                        delete glyphs[_j5].features.half;
                    }
                } while (_j5 > start && !isConsonant(glyphs[_j5]));
            }
        }
    }
}
function finalReordering(font, glyphs, plan) {
    var indicConfig = plan.indicConfig;
    var features = font._layoutEngine.engine.GSUBProcessor.features;
    for (var start = 0, end = nextSyllable(glyphs, 0); start < glyphs.length; start = end, end = nextSyllable(glyphs, start)) {
        var tryPref = !!features.pref;
        var base = start;
        for (; base < end; base++) {
            if (glyphs[base].shaperInfo.position >= POSITIONS.Base_C) {
                if (tryPref && base + 1 < end) {
                    for (var i = base + 1; i < end; i++) {
                        if (glyphs[i].features.pref) {
                            if (!(glyphs[i].substituted && glyphs[i].isLigated && !glyphs[i].isMultiplied)) {
                                base = i;
                                while (base < end && isHalantOrCoeng(glyphs[base])) {
                                    base++;
                                }
                                glyphs[base].shaperInfo.position = POSITIONS.BASE_C;
                                tryPref = false;
                            }
                            break;
                        }
                    }
                }
                if (plan.unicodeScript === 'Malayalam') {
                    for (var _i20 = base + 1; _i20 < end; _i20++) {
                        while (_i20 < end && isJoiner(glyphs[_i20])) {
                            _i20++;
                        }
                        if (_i20 === end || !isHalantOrCoeng(glyphs[_i20])) {
                            break;
                        }
                        _i20++;
                        while (_i20 < end && isJoiner(glyphs[_i20])) {
                            _i20++;
                        }
                        if (_i20 < end && isConsonant(glyphs[_i20]) && glyphs[_i20].shaperInfo.position === POSITIONS.Below_C) {
                            base = _i20;
                            glyphs[base].shaperInfo.position = POSITIONS.Base_C;
                        }
                    }
                }
                if (start < base && glyphs[base].shaperInfo.position > POSITIONS.Base_C) {
                    base--;
                }
                break;
            }
        }
        if (base === end && start < base && glyphs[base - 1].shaperInfo.category === CATEGORIES.ZWJ) {
            base--;
        }
        if (base < end) {
            while (start < base && glyphs[base].shaperInfo.category & (CATEGORIES.N | HALANT_OR_COENG_FLAGS)) {
                base--;
            }
        }
        if (start + 1 < end && start < base) {
            var newPos = base === end ? base - 2 : base - 1;
            if (plan.unicodeScript !== 'Malayalam' && plan.unicodeScript !== 'Tamil') {
                while (newPos > start && !(glyphs[newPos].shaperInfo.category & (CATEGORIES.M | HALANT_OR_COENG_FLAGS))) {
                    newPos--;
                }
                if (isHalantOrCoeng(glyphs[newPos]) && glyphs[newPos].shaperInfo.position !== POSITIONS.Pre_M) {
                    if (newPos + 1 < end && isJoiner(glyphs[newPos + 1])) {
                        newPos++;
                    }
                } else {
                    newPos = start;
                }
            }
            if (start < newPos && glyphs[newPos].shaperInfo.position !== POSITIONS.Pre_M) {
                for (var _i21 = newPos; _i21 > start; _i21--) {
                    if (glyphs[_i21 - 1].shaperInfo.position === POSITIONS.Pre_M) {
                        var oldPos = _i21 - 1;
                        if (oldPos < base && base <= newPos) {
                            base--;
                        }
                        var tmp = glyphs[oldPos];
                        glyphs.splice.apply(glyphs, [
                            oldPos,
                            0
                        ].concat(glyphs.splice(oldPos + 1, newPos - oldPos)));
                        glyphs[newPos] = tmp;
                        newPos--;
                    }
                }
            }
        }
        if (start + 1 < end && glyphs[start].shaperInfo.position === POSITIONS.Ra_To_Become_Reph && glyphs[start].shaperInfo.category === CATEGORIES.Repha !== (glyphs[start].isLigated && !glyphs[start].isMultiplied)) {
            var newRephPos = void 0;
            var rephPos = indicConfig.rephPos;
            var found = false;
            if (rephPos !== POSITIONS.After_Post) {
                newRephPos = start + 1;
                while (newRephPos < base && !isHalantOrCoeng(glyphs[newRephPos])) {
                    newRephPos++;
                }
                if (newRephPos < base && isHalantOrCoeng(glyphs[newRephPos])) {
                    if (newRephPos + 1 < base && isJoiner(glyphs[newRephPos + 1])) {
                        newRephPos++;
                    }
                    found = true;
                }
                if (!found && rephPos === POSITIONS.After_Main) {
                    newRephPos = base;
                    while (newRephPos + 1 < end && glyphs[newRephPos + 1].shaperInfo.position <= POSITIONS.After_Main) {
                        newRephPos++;
                    }
                    found = newRephPos < end;
                }
                if (!found && rephPos === POSITIONS.After_Sub) {
                    newRephPos = base;
                    while (newRephPos + 1 < end && !(glyphs[newRephPos + 1].shaperInfo.position & (POSITIONS.Post_C | POSITIONS.After_Post | POSITIONS.SMVD))) {
                        newRephPos++;
                    }
                    found = newRephPos < end;
                }
            }
            if (!found) {
                newRephPos = start + 1;
                while (newRephPos < base && !isHalantOrCoeng(glyphs[newRephPos])) {
                    newRephPos++;
                }
                if (newRephPos < base && isHalantOrCoeng(glyphs[newRephPos])) {
                    if (newRephPos + 1 < base && isJoiner(glyphs[newRephPos + 1])) {
                        newRephPos++;
                    }
                    found = true;
                }
            }
            if (!found) {
                newRephPos = end - 1;
                while (newRephPos > start && glyphs[newRephPos].shaperInfo.position === POSITIONS.SMVD) {
                    newRephPos--;
                }
                if (isHalantOrCoeng(glyphs[newRephPos])) {
                    for (var _i22 = base + 1; _i22 < newRephPos; _i22++) {
                        if (glyphs[_i22].shaperInfo.category === CATEGORIES.M) {
                            newRephPos--;
                        }
                    }
                }
            }
            var reph = glyphs[start];
            glyphs.splice.apply(glyphs, [
                start,
                0
            ].concat(glyphs.splice(start + 1, newRephPos - start)));
            glyphs[newRephPos] = reph;
            if (start < base && base <= newRephPos) {
                base--;
            }
        }
        if (tryPref && base + 1 < end) {
            for (var _i23 = base + 1; _i23 < end; _i23++) {
                if (glyphs[_i23].features.pref) {
                    if (glyphs[_i23].isLigated && !glyphs[_i23].isMultiplied) {
                        var _newPos = base;
                        if (plan.unicodeScript !== 'Malayalam' && plan.unicodeScript !== 'Tamil') {
                            while (_newPos > start && !(glyphs[_newPos - 1].shaperInfo.category & (CATEGORIES.M | HALANT_OR_COENG_FLAGS))) {
                                _newPos--;
                            }
                            if (_newPos > start && glyphs[_newPos - 1].shaperInfo.category === CATEGORIES.M) {
                                var _oldPos2 = _i23;
                                for (var j = base + 1; j < _oldPos2; j++) {
                                    if (glyphs[j].shaperInfo.category === CATEGORIES.M) {
                                        _newPos--;
                                        break;
                                    }
                                }
                            }
                        }
                        if (_newPos > start && isHalantOrCoeng(glyphs[_newPos - 1])) {
                            if (_newPos < end && isJoiner(glyphs[_newPos])) {
                                _newPos++;
                            }
                        }
                        var _oldPos = _i23;
                        var _tmp = glyphs[_oldPos];
                        glyphs.splice.apply(glyphs, [
                            _newPos + 1,
                            0
                        ].concat(glyphs.splice(_newPos, _oldPos - _newPos)));
                        glyphs[_newPos] = _tmp;
                        if (_newPos <= base && base < _oldPos) {
                            base++;
                        }
                    }
                    break;
                }
            }
        }
        if (glyphs[start].shaperInfo.position === POSITIONS.Pre_M && (!start || !/Cf|Mn/.test(unicode.getCategory(glyphs[start - 1].codePoints[0])))) {
            glyphs[start].features.init = true;
        }
    }
}
function nextSyllable(glyphs, start) {
    if (start >= glyphs.length)
        return start;
    var syllable = glyphs[start].shaperInfo.syllable;
    while (++start < glyphs.length && glyphs[start].shaperInfo.syllable === syllable) {
    }
    return start;
}
var _class$7;
var _temp$3;
var categories$1 = useData.categories;
var decompositions$2 = useData.decompositions;
var trie$2 = new UnicodeTrie(Buffer('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', 'base64'));
var stateMachine$1 = new StateMachine(useData);
var UniversalShaper = (_temp$3 = _class$7 = function (_DefaultShaper) {
        _inherits(UniversalShaper, _DefaultShaper);
        function UniversalShaper() {
            _classCallCheck(this, UniversalShaper);
            return _possibleConstructorReturn(this, _DefaultShaper.apply(this, arguments));
        }
        UniversalShaper.planFeatures = function planFeatures(plan) {
            plan.addStage(setupSyllables$1);
            plan.addStage([
                'locl',
                'ccmp',
                'nukt',
                'akhn'
            ]);
            plan.addStage(clearSubstitutionFlags);
            plan.addStage(['rphf'], false);
            plan.addStage(recordRphf);
            plan.addStage(clearSubstitutionFlags);
            plan.addStage(['pref']);
            plan.addStage(recordPref);
            plan.addStage([
                'rkrf',
                'abvf',
                'blwf',
                'half',
                'pstf',
                'vatu',
                'cjct'
            ]);
            plan.addStage(reorder);
            plan.addStage([
                'abvs',
                'blws',
                'pres',
                'psts',
                'dist',
                'abvm',
                'blwm'
            ]);
        };
        UniversalShaper.assignFeatures = function assignFeatures(plan, glyphs) {
            var _loop = function _loop(i) {
                var codepoint = glyphs[i].codePoints[0];
                if (decompositions$2[codepoint]) {
                    var decomposed = decompositions$2[codepoint].map(function (c) {
                            var g = plan.font.glyphForCodePoint(c);
                            return new GlyphInfo(plan.font, g.id, [c], glyphs[i].features);
                        });
                    glyphs.splice.apply(glyphs, [
                        i,
                        1
                    ].concat(decomposed));
                }
            };
            for (var i = glyphs.length - 1; i >= 0; i--) {
                _loop(i);
            }
        };
        return UniversalShaper;
    }(DefaultShaper), _class$7.zeroMarkWidths = 'BEFORE_GPOS', _temp$3);
function useCategory(glyph) {
    return trie$2.get(glyph.codePoints[0]);
}
var USEInfo = function USEInfo(category, syllableType, syllable) {
    _classCallCheck(this, USEInfo);
    this.category = category;
    this.syllableType = syllableType;
    this.syllable = syllable;
};
function setupSyllables$1(font, glyphs) {
    var syllable = 0;
    for (var _iterator = stateMachine$1.match(glyphs.map(useCategory)), _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _getIterator(_iterator);;) {
        var _ref;
        if (_isArray) {
            if (_i >= _iterator.length)
                break;
            _ref = _iterator[_i++];
        } else {
            _i = _iterator.next();
            if (_i.done)
                break;
            _ref = _i.value;
        }
        var _ref2 = _ref, start = _ref2[0], end = _ref2[1], tags = _ref2[2];
        ++syllable;
        for (var i = start; i <= end; i++) {
            glyphs[i].shaperInfo = new USEInfo(categories$1[useCategory(glyphs[i])], tags[0], syllable);
        }
        var limit = glyphs[start].shaperInfo.category === 'R' ? 1 : Math.min(3, end - start);
        for (var _i2 = start; _i2 < start + limit; _i2++) {
            glyphs[_i2].features.rphf = true;
        }
    }
}
function clearSubstitutionFlags(font, glyphs) {
    for (var _iterator2 = glyphs, _isArray2 = Array.isArray(_iterator2), _i3 = 0, _iterator2 = _isArray2 ? _iterator2 : _getIterator(_iterator2);;) {
        var _ref3;
        if (_isArray2) {
            if (_i3 >= _iterator2.length)
                break;
            _ref3 = _iterator2[_i3++];
        } else {
            _i3 = _iterator2.next();
            if (_i3.done)
                break;
            _ref3 = _i3.value;
        }
        var glyph = _ref3;
        glyph.substituted = false;
    }
}
function recordRphf(font, glyphs) {
    for (var _iterator3 = glyphs, _isArray3 = Array.isArray(_iterator3), _i4 = 0, _iterator3 = _isArray3 ? _iterator3 : _getIterator(_iterator3);;) {
        var _ref4;
        if (_isArray3) {
            if (_i4 >= _iterator3.length)
                break;
            _ref4 = _iterator3[_i4++];
        } else {
            _i4 = _iterator3.next();
            if (_i4.done)
                break;
            _ref4 = _i4.value;
        }
        var glyph = _ref4;
        if (glyph.substituted && glyph.features.rphf) {
            glyph.shaperInfo.category = 'R';
        }
    }
}
function recordPref(font, glyphs) {
    for (var _iterator4 = glyphs, _isArray4 = Array.isArray(_iterator4), _i5 = 0, _iterator4 = _isArray4 ? _iterator4 : _getIterator(_iterator4);;) {
        var _ref5;
        if (_isArray4) {
            if (_i5 >= _iterator4.length)
                break;
            _ref5 = _iterator4[_i5++];
        } else {
            _i5 = _iterator4.next();
            if (_i5.done)
                break;
            _ref5 = _i5.value;
        }
        var glyph = _ref5;
        if (glyph.substituted) {
            glyph.shaperInfo.category = 'VPre';
        }
    }
}
function reorder(font, glyphs) {
    var dottedCircle = font.glyphForCodePoint(9676).id;
    for (var start = 0, end = nextSyllable$1(glyphs, 0); start < glyphs.length; start = end, end = nextSyllable$1(glyphs, start)) {
        var i = void 0, j = void 0;
        var info = glyphs[start].shaperInfo;
        var type = info.syllableType;
        if (type !== 'virama_terminated_cluster' && type !== 'standard_cluster' && type !== 'broken_cluster') {
            continue;
        }
        if (type === 'broken_cluster' && dottedCircle) {
            var g = new GlyphInfo(font, dottedCircle, [9676]);
            g.shaperInfo = info;
            for (i = start; i < end && glyphs[i].shaperInfo.category === 'R'; i++) {
            }
            glyphs.splice(++i, 0, g);
            end++;
        }
        if (info.category === 'R' && end - start > 1) {
            for (i = start + 1; i < end; i++) {
                info = glyphs[i].shaperInfo;
                if (isBase(info) || isHalant(glyphs[i])) {
                    if (isHalant(glyphs[i])) {
                        i--;
                    }
                    glyphs.splice.apply(glyphs, [
                        start,
                        0
                    ].concat(glyphs.splice(start + 1, i - start), [glyphs[i]]));
                    break;
                }
            }
        }
        for (i = start, j = end; i < end; i++) {
            info = glyphs[i].shaperInfo;
            if (isBase(info) || isHalant(glyphs[i])) {
                j = isHalant(glyphs[i]) ? i + 1 : i;
            } else if ((info.category === 'VPre' || info.category === 'VMPre') && j < i) {
                glyphs.splice.apply(glyphs, [
                    j,
                    1,
                    glyphs[i]
                ].concat(glyphs.splice(j, i - j)));
            }
        }
    }
}
function nextSyllable$1(glyphs, start) {
    if (start >= glyphs.length)
        return start;
    var syllable = glyphs[start].shaperInfo.syllable;
    while (++start < glyphs.length && glyphs[start].shaperInfo.syllable === syllable) {
    }
    return start;
}
function isHalant(glyph) {
    return glyph.shaperInfo.category === 'H' && !glyph.isLigated;
}
function isBase(info) {
    return info.category === 'B' || info.category === 'GB';
}
var SHAPERS = {
        arab: ArabicShaper,
        mong: ArabicShaper,
        syrc: ArabicShaper,
        'nko ': ArabicShaper,
        phag: ArabicShaper,
        mand: ArabicShaper,
        mani: ArabicShaper,
        phlp: ArabicShaper,
        hang: HangulShaper,
        bng2: IndicShaper,
        beng: IndicShaper,
        dev2: IndicShaper,
        deva: IndicShaper,
        gjr2: IndicShaper,
        gujr: IndicShaper,
        guru: IndicShaper,
        gur2: IndicShaper,
        knda: IndicShaper,
        knd2: IndicShaper,
        mlm2: IndicShaper,
        mlym: IndicShaper,
        ory2: IndicShaper,
        orya: IndicShaper,
        taml: IndicShaper,
        tml2: IndicShaper,
        telu: IndicShaper,
        tel2: IndicShaper,
        khmr: IndicShaper,
        bali: UniversalShaper,
        batk: UniversalShaper,
        brah: UniversalShaper,
        bugi: UniversalShaper,
        buhd: UniversalShaper,
        cakm: UniversalShaper,
        cham: UniversalShaper,
        dupl: UniversalShaper,
        egyp: UniversalShaper,
        gran: UniversalShaper,
        hano: UniversalShaper,
        java: UniversalShaper,
        kthi: UniversalShaper,
        kali: UniversalShaper,
        khar: UniversalShaper,
        khoj: UniversalShaper,
        sind: UniversalShaper,
        lepc: UniversalShaper,
        limb: UniversalShaper,
        mahj: UniversalShaper,
        mtei: UniversalShaper,
        modi: UniversalShaper,
        hmng: UniversalShaper,
        rjng: UniversalShaper,
        saur: UniversalShaper,
        shrd: UniversalShaper,
        sidd: UniversalShaper,
        sinh: UniversalShaper,
        sund: UniversalShaper,
        sylo: UniversalShaper,
        tglg: UniversalShaper,
        tagb: UniversalShaper,
        tale: UniversalShaper,
        lana: UniversalShaper,
        tavt: UniversalShaper,
        takr: UniversalShaper,
        tibt: UniversalShaper,
        tfng: UniversalShaper,
        tirh: UniversalShaper,
        latn: DefaultShaper,
        DFLT: DefaultShaper
    };
function choose(script) {
    if (!Array.isArray(script)) {
        script = [script];
    }
    for (var _iterator = script, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _getIterator(_iterator);;) {
        var _ref;
        if (_isArray) {
            if (_i >= _iterator.length)
                break;
            _ref = _iterator[_i++];
        } else {
            _i = _iterator.next();
            if (_i.done)
                break;
            _ref = _i.value;
        }
        var s = _ref;
        var shaper = SHAPERS[s];
        if (shaper) {
            return shaper;
        }
    }
    return DefaultShaper;
}
var GSUBProcessor = function (_OTProcessor) {
        _inherits(GSUBProcessor, _OTProcessor);
        function GSUBProcessor() {
            _classCallCheck(this, GSUBProcessor);
            return _possibleConstructorReturn(this, _OTProcessor.apply(this, arguments));
        }
        GSUBProcessor.prototype.applyLookup = function applyLookup(lookupType, table) {
            var _this2 = this;
            switch (lookupType) {
            case 1: {
                    var index = this.coverageIndex(table.coverage);
                    if (index === -1) {
                        return false;
                    }
                    var glyph = this.glyphIterator.cur;
                    switch (table.version) {
                    case 1:
                        glyph.id = glyph.id + table.deltaGlyphID & 65535;
                        break;
                    case 2:
                        glyph.id = table.substitute.get(index);
                        break;
                    }
                    return true;
                }
            case 2: {
                    var _index = this.coverageIndex(table.coverage);
                    if (_index !== -1) {
                        var _glyphs;
                        var sequence = table.sequences.get(_index);
                        if (sequence.length === 0) {
                            this.glyphs.splice(this.glyphIterator.index, 1);
                            return true;
                        }
                        this.glyphIterator.cur.id = sequence[0];
                        this.glyphIterator.cur.ligatureComponent = 0;
                        var features = this.glyphIterator.cur.features;
                        var curGlyph = this.glyphIterator.cur;
                        var replacement = sequence.slice(1).map(function (gid, i) {
                                var glyph = new GlyphInfo(_this2.font, gid, undefined, features);
                                glyph.shaperInfo = curGlyph.shaperInfo;
                                glyph.isLigated = curGlyph.isLigated;
                                glyph.ligatureComponent = i + 1;
                                glyph.substituted = true;
                                glyph.isMultiplied = true;
                                return glyph;
                            });
                        (_glyphs = this.glyphs).splice.apply(_glyphs, [
                            this.glyphIterator.index + 1,
                            0
                        ].concat(replacement));
                        return true;
                    }
                    return false;
                }
            case 3: {
                    var _index2 = this.coverageIndex(table.coverage);
                    if (_index2 !== -1) {
                        var USER_INDEX = 0;
                        this.glyphIterator.cur.id = table.alternateSet.get(_index2)[USER_INDEX];
                        return true;
                    }
                    return false;
                }
            case 4: {
                    var _index3 = this.coverageIndex(table.coverage);
                    if (_index3 === -1) {
                        return false;
                    }
                    for (var _iterator = table.ligatureSets.get(_index3), _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _getIterator(_iterator);;) {
                        var _ref;
                        if (_isArray) {
                            if (_i >= _iterator.length)
                                break;
                            _ref = _iterator[_i++];
                        } else {
                            _i = _iterator.next();
                            if (_i.done)
                                break;
                            _ref = _i.value;
                        }
                        var ligature = _ref;
                        var matched = this.sequenceMatchIndices(1, ligature.components);
                        if (!matched) {
                            continue;
                        }
                        var _curGlyph = this.glyphIterator.cur;
                        var characters = _curGlyph.codePoints.slice();
                        for (var _iterator2 = matched, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _getIterator(_iterator2);;) {
                            var _ref2;
                            if (_isArray2) {
                                if (_i2 >= _iterator2.length)
                                    break;
                                _ref2 = _iterator2[_i2++];
                            } else {
                                _i2 = _iterator2.next();
                                if (_i2.done)
                                    break;
                                _ref2 = _i2.value;
                            }
                            var _index4 = _ref2;
                            characters.push.apply(characters, this.glyphs[_index4].codePoints);
                        }
                        var ligatureGlyph = new GlyphInfo(this.font, ligature.glyph, characters, _curGlyph.features);
                        ligatureGlyph.shaperInfo = _curGlyph.shaperInfo;
                        ligatureGlyph.isLigated = true;
                        ligatureGlyph.substituted = true;
                        var isMarkLigature = _curGlyph.isMark;
                        for (var i = 0; i < matched.length && isMarkLigature; i++) {
                            isMarkLigature = this.glyphs[matched[i]].isMark;
                        }
                        ligatureGlyph.ligatureID = isMarkLigature ? null : this.ligatureID++;
                        var lastLigID = _curGlyph.ligatureID;
                        var lastNumComps = _curGlyph.codePoints.length;
                        var curComps = lastNumComps;
                        var idx = this.glyphIterator.index + 1;
                        for (var _iterator3 = matched, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _getIterator(_iterator3);;) {
                            var _ref3;
                            if (_isArray3) {
                                if (_i3 >= _iterator3.length)
                                    break;
                                _ref3 = _iterator3[_i3++];
                            } else {
                                _i3 = _iterator3.next();
                                if (_i3.done)
                                    break;
                                _ref3 = _i3.value;
                            }
                            var matchIndex = _ref3;
                            if (isMarkLigature) {
                                idx = matchIndex;
                            } else {
                                while (idx < matchIndex) {
                                    var ligatureComponent = curComps - lastNumComps + Math.min(this.glyphs[idx].ligatureComponent || 1, lastNumComps);
                                    this.glyphs[idx].ligatureID = ligatureGlyph.ligatureID;
                                    this.glyphs[idx].ligatureComponent = ligatureComponent;
                                    idx++;
                                }
                            }
                            lastLigID = this.glyphs[idx].ligatureID;
                            lastNumComps = this.glyphs[idx].codePoints.length;
                            curComps += lastNumComps;
                            idx++;
                        }
                        if (lastLigID && !isMarkLigature) {
                            for (var _i4 = idx; _i4 < this.glyphs.length; _i4++) {
                                if (this.glyphs[_i4].ligatureID === lastLigID) {
                                    var ligatureComponent = curComps - lastNumComps + Math.min(this.glyphs[_i4].ligatureComponent || 1, lastNumComps);
                                    this.glyphs[_i4].ligatureComponent = ligatureComponent;
                                } else {
                                    break;
                                }
                            }
                        }
                        for (var _i5 = matched.length - 1; _i5 >= 0; _i5--) {
                            this.glyphs.splice(matched[_i5], 1);
                        }
                        this.glyphs[this.glyphIterator.index] = ligatureGlyph;
                        return true;
                    }
                    return false;
                }
            case 5:
                return this.applyContext(table);
            case 6:
                return this.applyChainingContext(table);
            case 7:
                return this.applyLookup(table.lookupType, table.extension);
            default:
                throw new Error('GSUB lookupType ' + lookupType + ' is not supported');
            }
        };
        return GSUBProcessor;
    }(OTProcessor);
var GPOSProcessor = function (_OTProcessor) {
        _inherits(GPOSProcessor, _OTProcessor);
        function GPOSProcessor() {
            _classCallCheck(this, GPOSProcessor);
            return _possibleConstructorReturn(this, _OTProcessor.apply(this, arguments));
        }
        GPOSProcessor.prototype.applyPositionValue = function applyPositionValue(sequenceIndex, value) {
            var position = this.positions[this.glyphIterator.peekIndex(sequenceIndex)];
            if (value.xAdvance != null) {
                position.xAdvance += value.xAdvance;
            }
            if (value.yAdvance != null) {
                position.yAdvance += value.yAdvance;
            }
            if (value.xPlacement != null) {
                position.xOffset += value.xPlacement;
            }
            if (value.yPlacement != null) {
                position.yOffset += value.yPlacement;
            }
            var variationProcessor = this.font._variationProcessor;
            var variationStore = this.font.GDEF && this.font.GDEF.itemVariationStore;
            if (variationProcessor && variationStore) {
                if (value.xPlaDevice) {
                    position.xOffset += variationProcessor.getDelta(variationStore, value.xPlaDevice.a, value.xPlaDevice.b);
                }
                if (value.yPlaDevice) {
                    position.yOffset += variationProcessor.getDelta(variationStore, value.yPlaDevice.a, value.yPlaDevice.b);
                }
                if (value.xAdvDevice) {
                    position.xAdvance += variationProcessor.getDelta(variationStore, value.xAdvDevice.a, value.xAdvDevice.b);
                }
                if (value.yAdvDevice) {
                    position.yAdvance += variationProcessor.getDelta(variationStore, value.yAdvDevice.a, value.yAdvDevice.b);
                }
            }
        };
        GPOSProcessor.prototype.applyLookup = function applyLookup(lookupType, table) {
            switch (lookupType) {
            case 1: {
                    var index = this.coverageIndex(table.coverage);
                    if (index === -1) {
                        return false;
                    }
                    switch (table.version) {
                    case 1:
                        this.applyPositionValue(0, table.value);
                        break;
                    case 2:
                        this.applyPositionValue(0, table.values.get(index));
                        break;
                    }
                    return true;
                }
            case 2: {
                    var nextGlyph = this.glyphIterator.peek();
                    if (!nextGlyph) {
                        return false;
                    }
                    var _index = this.coverageIndex(table.coverage);
                    if (_index === -1) {
                        return false;
                    }
                    switch (table.version) {
                    case 1:
                        var set = table.pairSets.get(_index);
                        for (var _iterator = set, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _getIterator(_iterator);;) {
                            var _ref;
                            if (_isArray) {
                                if (_i >= _iterator.length)
                                    break;
                                _ref = _iterator[_i++];
                            } else {
                                _i = _iterator.next();
                                if (_i.done)
                                    break;
                                _ref = _i.value;
                            }
                            var _pair = _ref;
                            if (_pair.secondGlyph === nextGlyph.id) {
                                this.applyPositionValue(0, _pair.value1);
                                this.applyPositionValue(1, _pair.value2);
                                return true;
                            }
                        }
                        return false;
                    case 2:
                        var class1 = this.getClassID(this.glyphIterator.cur.id, table.classDef1);
                        var class2 = this.getClassID(nextGlyph.id, table.classDef2);
                        if (class1 === -1 || class2 === -1) {
                            return false;
                        }
                        var pair = table.classRecords.get(class1).get(class2);
                        this.applyPositionValue(0, pair.value1);
                        this.applyPositionValue(1, pair.value2);
                        return true;
                    }
                }
            case 3: {
                    var nextIndex = this.glyphIterator.peekIndex();
                    var _nextGlyph = this.glyphs[nextIndex];
                    if (!_nextGlyph) {
                        return false;
                    }
                    var curRecord = table.entryExitRecords[this.coverageIndex(table.coverage)];
                    if (!curRecord || !curRecord.exitAnchor) {
                        return false;
                    }
                    var nextRecord = table.entryExitRecords[this.coverageIndex(table.coverage, _nextGlyph.id)];
                    if (!nextRecord || !nextRecord.entryAnchor) {
                        return false;
                    }
                    var entry = this.getAnchor(nextRecord.entryAnchor);
                    var exit = this.getAnchor(curRecord.exitAnchor);
                    var cur = this.positions[this.glyphIterator.index];
                    var next = this.positions[nextIndex];
                    switch (this.direction) {
                    case 'ltr':
                        cur.xAdvance = exit.x + cur.xOffset;
                        var d = entry.x + next.xOffset;
                        next.xAdvance -= d;
                        next.xOffset -= d;
                        break;
                    case 'rtl':
                        d = exit.x + cur.xOffset;
                        cur.xAdvance -= d;
                        cur.xOffset -= d;
                        next.xAdvance = entry.x + next.xOffset;
                        break;
                    }
                    if (this.glyphIterator.flags.rightToLeft) {
                        this.glyphIterator.cur.cursiveAttachment = nextIndex;
                        cur.yOffset = entry.y - exit.y;
                    } else {
                        _nextGlyph.cursiveAttachment = this.glyphIterator.index;
                        cur.yOffset = exit.y - entry.y;
                    }
                    return true;
                }
            case 4: {
                    var markIndex = this.coverageIndex(table.markCoverage);
                    if (markIndex === -1) {
                        return false;
                    }
                    var baseGlyphIndex = this.glyphIterator.index;
                    while (--baseGlyphIndex >= 0 && (this.glyphs[baseGlyphIndex].isMark || this.glyphs[baseGlyphIndex].ligatureComponent > 0)) {
                    }
                    if (baseGlyphIndex < 0) {
                        return false;
                    }
                    var baseIndex = this.coverageIndex(table.baseCoverage, this.glyphs[baseGlyphIndex].id);
                    if (baseIndex === -1) {
                        return false;
                    }
                    var markRecord = table.markArray[markIndex];
                    var baseAnchor = table.baseArray[baseIndex][markRecord.class];
                    this.applyAnchor(markRecord, baseAnchor, baseGlyphIndex);
                    return true;
                }
            case 5: {
                    var _markIndex = this.coverageIndex(table.markCoverage);
                    if (_markIndex === -1) {
                        return false;
                    }
                    var _baseGlyphIndex = this.glyphIterator.index;
                    while (--_baseGlyphIndex >= 0 && this.glyphs[_baseGlyphIndex].isMark) {
                    }
                    if (_baseGlyphIndex < 0) {
                        return false;
                    }
                    var ligIndex = this.coverageIndex(table.ligatureCoverage, this.glyphs[_baseGlyphIndex].id);
                    if (ligIndex === -1) {
                        return false;
                    }
                    var ligAttach = table.ligatureArray[ligIndex];
                    var markGlyph = this.glyphIterator.cur;
                    var ligGlyph = this.glyphs[_baseGlyphIndex];
                    var compIndex = ligGlyph.ligatureID && ligGlyph.ligatureID === markGlyph.ligatureID && markGlyph.ligatureComponent > 0 ? Math.min(markGlyph.ligatureComponent, ligGlyph.codePoints.length) - 1 : ligGlyph.codePoints.length - 1;
                    var _markRecord = table.markArray[_markIndex];
                    var _baseAnchor = ligAttach[compIndex][_markRecord.class];
                    this.applyAnchor(_markRecord, _baseAnchor, _baseGlyphIndex);
                    return true;
                }
            case 6: {
                    var mark1Index = this.coverageIndex(table.mark1Coverage);
                    if (mark1Index === -1) {
                        return false;
                    }
                    var prevIndex = this.glyphIterator.peekIndex(-1);
                    var prev = this.glyphs[prevIndex];
                    if (!prev || !prev.isMark) {
                        return false;
                    }
                    var _cur = this.glyphIterator.cur;
                    var good = false;
                    if (_cur.ligatureID === prev.ligatureID) {
                        if (!_cur.ligatureID) {
                            good = true;
                        } else if (_cur.ligatureComponent === prev.ligatureComponent) {
                            good = true;
                        }
                    } else {
                        if (_cur.ligatureID && !_cur.ligatureComponent || prev.ligatureID && !prev.ligatureComponent) {
                            good = true;
                        }
                    }
                    if (!good) {
                        return false;
                    }
                    var mark2Index = this.coverageIndex(table.mark2Coverage, prev.id);
                    if (mark2Index === -1) {
                        return false;
                    }
                    var _markRecord2 = table.mark1Array[mark1Index];
                    var _baseAnchor2 = table.mark2Array[mark2Index][_markRecord2.class];
                    this.applyAnchor(_markRecord2, _baseAnchor2, prevIndex);
                    return true;
                }
            case 7:
                return this.applyContext(table);
            case 8:
                return this.applyChainingContext(table);
            case 9:
                return this.applyLookup(table.lookupType, table.extension);
            default:
                throw new Error('Unsupported GPOS table: ' + lookupType);
            }
        };
        GPOSProcessor.prototype.applyAnchor = function applyAnchor(markRecord, baseAnchor, baseGlyphIndex) {
            var baseCoords = this.getAnchor(baseAnchor);
            var markCoords = this.getAnchor(markRecord.markAnchor);
            var basePos = this.positions[baseGlyphIndex];
            var markPos = this.positions[this.glyphIterator.index];
            markPos.xOffset = baseCoords.x - markCoords.x;
            markPos.yOffset = baseCoords.y - markCoords.y;
            this.glyphIterator.cur.markAttachment = baseGlyphIndex;
        };
        GPOSProcessor.prototype.getAnchor = function getAnchor(anchor) {
            var x = anchor.xCoordinate;
            var y = anchor.yCoordinate;
            var variationProcessor = this.font._variationProcessor;
            var variationStore = this.font.GDEF && this.font.GDEF.itemVariationStore;
            if (variationProcessor && variationStore) {
                if (anchor.xDeviceTable) {
                    x += variationProcessor.getDelta(variationStore, anchor.xDeviceTable.a, anchor.xDeviceTable.b);
                }
                if (anchor.yDeviceTable) {
                    y += variationProcessor.getDelta(variationStore, anchor.yDeviceTable.a, anchor.yDeviceTable.b);
                }
            }
            return {
                x: x,
                y: y
            };
        };
        GPOSProcessor.prototype.applyFeatures = function applyFeatures(userFeatures, glyphs, advances) {
            _OTProcessor.prototype.applyFeatures.call(this, userFeatures, glyphs, advances);
            for (var i = 0; i < this.glyphs.length; i++) {
                this.fixCursiveAttachment(i);
            }
            this.fixMarkAttachment();
        };
        GPOSProcessor.prototype.fixCursiveAttachment = function fixCursiveAttachment(i) {
            var glyph = this.glyphs[i];
            if (glyph.cursiveAttachment != null) {
                var j = glyph.cursiveAttachment;
                glyph.cursiveAttachment = null;
                this.fixCursiveAttachment(j);
                this.positions[i].yOffset += this.positions[j].yOffset;
            }
        };
        GPOSProcessor.prototype.fixMarkAttachment = function fixMarkAttachment() {
            for (var i = 0; i < this.glyphs.length; i++) {
                var glyph = this.glyphs[i];
                if (glyph.markAttachment != null) {
                    var j = glyph.markAttachment;
                    this.positions[i].xOffset += this.positions[j].xOffset;
                    this.positions[i].yOffset += this.positions[j].yOffset;
                    if (this.direction === 'ltr') {
                        for (var k = j; k < i; k++) {
                            this.positions[i].xOffset -= this.positions[k].xAdvance;
                            this.positions[i].yOffset -= this.positions[k].yAdvance;
                        }
                    } else {
                        for (var _k = j + 1; _k < i + 1; _k++) {
                            this.positions[i].xOffset += this.positions[_k].xAdvance;
                            this.positions[i].yOffset += this.positions[_k].yAdvance;
                        }
                    }
                }
            }
        };
        return GPOSProcessor;
    }(OTProcessor);
var OTLayoutEngine = function () {
        function OTLayoutEngine(font) {
            _classCallCheck(this, OTLayoutEngine);
            this.font = font;
            this.glyphInfos = null;
            this.plan = null;
            this.GSUBProcessor = null;
            this.GPOSProcessor = null;
            this.fallbackPosition = true;
            if (font.GSUB) {
                this.GSUBProcessor = new GSUBProcessor(font, font.GSUB);
            }
            if (font.GPOS) {
                this.GPOSProcessor = new GPOSProcessor(font, font.GPOS);
            }
        }
        OTLayoutEngine.prototype.setup = function setup(glyphRun) {
            var _this = this;
            this.glyphInfos = glyphRun.glyphs.map(function (glyph) {
                return new GlyphInfo(_this.font, glyph.id, [].concat(glyph.codePoints));
            });
            var script = null;
            if (this.GPOSProcessor) {
                script = this.GPOSProcessor.selectScript(glyphRun.script, glyphRun.language, glyphRun.direction);
            }
            if (this.GSUBProcessor) {
                script = this.GSUBProcessor.selectScript(glyphRun.script, glyphRun.language, glyphRun.direction);
            }
            this.shaper = choose(script);
            this.plan = new ShapingPlan(this.font, script, glyphRun.direction);
            this.shaper.plan(this.plan, this.glyphInfos, glyphRun.features);
            for (var key in this.plan.allFeatures) {
                glyphRun.features[key] = true;
            }
        };
        OTLayoutEngine.prototype.substitute = function substitute(glyphRun) {
            var _this2 = this;
            if (this.GSUBProcessor) {
                this.plan.process(this.GSUBProcessor, this.glyphInfos);
                glyphRun.glyphs = this.glyphInfos.map(function (glyphInfo) {
                    return _this2.font.getGlyph(glyphInfo.id, glyphInfo.codePoints);
                });
            }
        };
        OTLayoutEngine.prototype.position = function position(glyphRun) {
            if (this.shaper.zeroMarkWidths === 'BEFORE_GPOS') {
                this.zeroMarkAdvances(glyphRun.positions);
            }
            if (this.GPOSProcessor) {
                this.plan.process(this.GPOSProcessor, this.glyphInfos, glyphRun.positions);
            }
            if (this.shaper.zeroMarkWidths === 'AFTER_GPOS') {
                this.zeroMarkAdvances(glyphRun.positions);
            }
            if (glyphRun.direction === 'rtl') {
                glyphRun.glyphs.reverse();
                glyphRun.positions.reverse();
            }
            return this.GPOSProcessor && this.GPOSProcessor.features;
        };
        OTLayoutEngine.prototype.zeroMarkAdvances = function zeroMarkAdvances(positions) {
            for (var i = 0; i < this.glyphInfos.length; i++) {
                if (this.glyphInfos[i].isMark) {
                    positions[i].xAdvance = 0;
                    positions[i].yAdvance = 0;
                }
            }
        };
        OTLayoutEngine.prototype.cleanup = function cleanup() {
            this.glyphInfos = null;
            this.plan = null;
            this.shaper = null;
        };
        OTLayoutEngine.prototype.getAvailableFeatures = function getAvailableFeatures(script, language) {
            var features = [];
            if (this.GSUBProcessor) {
                this.GSUBProcessor.selectScript(script, language);
                features.push.apply(features, _Object$keys(this.GSUBProcessor.features));
            }
            if (this.GPOSProcessor) {
                this.GPOSProcessor.selectScript(script, language);
                features.push.apply(features, _Object$keys(this.GPOSProcessor.features));
            }
            return features;
        };
        return OTLayoutEngine;
    }();
var LayoutEngine = function () {
        function LayoutEngine(font) {
            _classCallCheck(this, LayoutEngine);
            this.font = font;
            this.unicodeLayoutEngine = null;
            this.kernProcessor = null;
            if (this.font.morx) {
                this.engine = new AATLayoutEngine(this.font);
            } else if (this.font.GSUB || this.font.GPOS) {
                this.engine = new OTLayoutEngine(this.font);
            }
        }
        LayoutEngine.prototype.layout = function layout(string, features, script, language, direction) {
            if (typeof features === 'string') {
                direction = language;
                language = script;
                script = features;
                features = [];
            }
            if (typeof string === 'string') {
                if (script == null) {
                    script = forString(string);
                }
                var glyphs = this.font.glyphsForString(string);
            } else {
                if (script == null) {
                    var codePoints = [];
                    for (var _iterator = string, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _getIterator(_iterator);;) {
                        var _ref;
                        if (_isArray) {
                            if (_i >= _iterator.length)
                                break;
                            _ref = _iterator[_i++];
                        } else {
                            _i = _iterator.next();
                            if (_i.done)
                                break;
                            _ref = _i.value;
                        }
                        var glyph = _ref;
                        codePoints.push.apply(codePoints, glyph.codePoints);
                    }
                    script = forCodePoints(codePoints);
                }
                var glyphs = string;
            }
            var glyphRun = new GlyphRun(glyphs, features, script, language, direction);
            if (glyphs.length === 0) {
                glyphRun.positions = [];
                return glyphRun;
            }
            if (this.engine && this.engine.setup) {
                this.engine.setup(glyphRun);
            }
            this.substitute(glyphRun);
            this.position(glyphRun);
            this.hideDefaultIgnorables(glyphRun.glyphs, glyphRun.positions);
            if (this.engine && this.engine.cleanup) {
                this.engine.cleanup();
            }
            return glyphRun;
        };
        LayoutEngine.prototype.substitute = function substitute(glyphRun) {
            if (this.engine && this.engine.substitute) {
                this.engine.substitute(glyphRun);
            }
        };
        LayoutEngine.prototype.position = function position(glyphRun) {
            glyphRun.positions = glyphRun.glyphs.map(function (glyph) {
                return new GlyphPosition(glyph.advanceWidth);
            });
            var positioned = null;
            if (this.engine && this.engine.position) {
                positioned = this.engine.position(glyphRun);
            }
            if (!positioned && (!this.engine || this.engine.fallbackPosition)) {
                if (!this.unicodeLayoutEngine) {
                    this.unicodeLayoutEngine = new UnicodeLayoutEngine(this.font);
                }
                this.unicodeLayoutEngine.positionGlyphs(glyphRun.glyphs, glyphRun.positions);
            }
            if ((!positioned || !positioned.kern) && glyphRun.features.kern !== false && this.font.kern) {
                if (!this.kernProcessor) {
                    this.kernProcessor = new KernProcessor(this.font);
                }
                this.kernProcessor.process(glyphRun.glyphs, glyphRun.positions);
                glyphRun.features.kern = true;
            }
        };
        LayoutEngine.prototype.hideDefaultIgnorables = function hideDefaultIgnorables(glyphs, positions) {
            var space = this.font.glyphForCodePoint(32);
            for (var i = 0; i < glyphs.length; i++) {
                if (this.isDefaultIgnorable(glyphs[i].codePoints[0])) {
                    glyphs[i] = space;
                    positions[i].xAdvance = 0;
                    positions[i].yAdvance = 0;
                }
            }
        };
        LayoutEngine.prototype.isDefaultIgnorable = function isDefaultIgnorable(ch) {
            var plane = ch >> 16;
            if (plane === 0) {
                switch (ch >> 8) {
                case 0:
                    return ch === 173;
                case 3:
                    return ch === 847;
                case 6:
                    return ch === 1564;
                case 23:
                    return 6068 <= ch && ch <= 6069;
                case 24:
                    return 6155 <= ch && ch <= 6158;
                case 32:
                    return 8203 <= ch && ch <= 8207 || 8234 <= ch && ch <= 8238 || 8288 <= ch && ch <= 8303;
                case 254:
                    return 65024 <= ch && ch <= 65039 || ch === 65279;
                case 255:
                    return 65520 <= ch && ch <= 65528;
                default:
                    return false;
                }
            } else {
                switch (plane) {
                case 1:
                    return 113824 <= ch && ch <= 113827 || 119155 <= ch && ch <= 119162;
                case 14:
                    return 917504 <= ch && ch <= 921599;
                default:
                    return false;
                }
            }
        };
        LayoutEngine.prototype.getAvailableFeatures = function getAvailableFeatures(script, language) {
            var features = [];
            if (this.engine) {
                features.push.apply(features, this.engine.getAvailableFeatures(script, language));
            }
            if (this.font.kern && features.indexOf('kern') === -1) {
                features.push('kern');
            }
            return features;
        };
        LayoutEngine.prototype.stringsForGlyph = function stringsForGlyph(gid) {
            var result = new _Set();
            var codePoints = this.font._cmapProcessor.codePointsForGlyph(gid);
            for (var _iterator2 = codePoints, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _getIterator(_iterator2);;) {
                var _ref2;
                if (_isArray2) {
                    if (_i2 >= _iterator2.length)
                        break;
                    _ref2 = _iterator2[_i2++];
                } else {
                    _i2 = _iterator2.next();
                    if (_i2.done)
                        break;
                    _ref2 = _i2.value;
                }
                var codePoint = _ref2;
                result.add(_String$fromCodePoint(codePoint));
            }
            if (this.engine && this.engine.stringsForGlyph) {
                for (var _iterator3 = this.engine.stringsForGlyph(gid), _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _getIterator(_iterator3);;) {
                    var _ref3;
                    if (_isArray3) {
                        if (_i3 >= _iterator3.length)
                            break;
                        _ref3 = _iterator3[_i3++];
                    } else {
                        _i3 = _iterator3.next();
                        if (_i3.done)
                            break;
                        _ref3 = _i3.value;
                    }
                    var string = _ref3;
                    result.add(string);
                }
            }
            return _Array$from(result);
        };
        return LayoutEngine;
    }();
var SVG_COMMANDS = {
        moveTo: 'M',
        lineTo: 'L',
        quadraticCurveTo: 'Q',
        bezierCurveTo: 'C',
        closePath: 'Z'
    };
var Path = function () {
        function Path() {
            _classCallCheck(this, Path);
            this.commands = [];
            this._bbox = null;
            this._cbox = null;
        }
        Path.prototype.toFunction = function toFunction() {
            var cmds = this.commands.map(function (c) {
                    return '  ctx.' + c.command + '(' + c.args.join(', ') + ');';
                });
            return new Function('ctx', cmds.join('\n'));
        };
        Path.prototype.toSVG = function toSVG() {
            var cmds = this.commands.map(function (c) {
                    var args = c.args.map(function (arg) {
                            return Math.round(arg * 100) / 100;
                        });
                    return '' + SVG_COMMANDS[c.command] + args.join(' ');
                });
            return cmds.join('');
        };
        Path.prototype.mapPoints = function mapPoints(fn) {
            var path = new Path();
            for (var _iterator = this.commands, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _getIterator(_iterator);;) {
                var _ref;
                if (_isArray) {
                    if (_i >= _iterator.length)
                        break;
                    _ref = _iterator[_i++];
                } else {
                    _i = _iterator.next();
                    if (_i.done)
                        break;
                    _ref = _i.value;
                }
                var c = _ref;
                var args = [];
                for (var _i2 = 0; _i2 < c.args.length; _i2 += 2) {
                    var _fn = fn(c.args[_i2], c.args[_i2 + 1]), x = _fn[0], y = _fn[1];
                    args.push(x, y);
                }
                path[c.command].apply(path, args);
            }
            return path;
        };
        Path.prototype.transform = function transform(m0, m1, m2, m3, m4, m5) {
            return this.mapPoints(function (x, y) {
                x = m0 * x + m2 * y + m4;
                y = m1 * x + m3 * y + m5;
                return [
                    x,
                    y
                ];
            });
        };
        Path.prototype.translate = function translate(x, y) {
            return this.transform(1, 0, 0, 1, x, y);
        };
        Path.prototype.rotate = function rotate(angle) {
            var cos = Math.cos(angle);
            var sin = Math.sin(angle);
            return this.transform(cos, sin, -sin, cos, 0, 0);
        };
        Path.prototype.scale = function scale(scaleX) {
            var scaleY = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : scaleX;
            return this.transform(scaleX, 0, 0, scaleY, 0, 0);
        };
        _createClass(Path, [
            {
                key: 'cbox',
                get: function get() {
                    if (!this._cbox) {
                        var cbox = new BBox();
                        for (var _iterator2 = this.commands, _isArray2 = Array.isArray(_iterator2), _i3 = 0, _iterator2 = _isArray2 ? _iterator2 : _getIterator(_iterator2);;) {
                            var _ref2;
                            if (_isArray2) {
                                if (_i3 >= _iterator2.length)
                                    break;
                                _ref2 = _iterator2[_i3++];
                            } else {
                                _i3 = _iterator2.next();
                                if (_i3.done)
                                    break;
                                _ref2 = _i3.value;
                            }
                            var command = _ref2;
                            for (var _i4 = 0; _i4 < command.args.length; _i4 += 2) {
                                cbox.addPoint(command.args[_i4], command.args[_i4 + 1]);
                            }
                        }
                        this._cbox = _Object$freeze(cbox);
                    }
                    return this._cbox;
                }
            },
            {
                key: 'bbox',
                get: function get() {
                    if (this._bbox) {
                        return this._bbox;
                    }
                    var bbox = new BBox();
                    var cx = 0, cy = 0;
                    var f = function f(t) {
                        return Math.pow(1 - t, 3) * p0[i] + 3 * Math.pow(1 - t, 2) * t * p1[i] + 3 * (1 - t) * Math.pow(t, 2) * p2[i] + Math.pow(t, 3) * p3[i];
                    };
                    for (var _iterator3 = this.commands, _isArray3 = Array.isArray(_iterator3), _i5 = 0, _iterator3 = _isArray3 ? _iterator3 : _getIterator(_iterator3);;) {
                        var _ref3;
                        if (_isArray3) {
                            if (_i5 >= _iterator3.length)
                                break;
                            _ref3 = _iterator3[_i5++];
                        } else {
                            _i5 = _iterator3.next();
                            if (_i5.done)
                                break;
                            _ref3 = _i5.value;
                        }
                        var c = _ref3;
                        switch (c.command) {
                        case 'moveTo':
                        case 'lineTo':
                            var _c$args = c.args, x = _c$args[0], y = _c$args[1];
                            bbox.addPoint(x, y);
                            cx = x;
                            cy = y;
                            break;
                        case 'quadraticCurveTo':
                        case 'bezierCurveTo':
                            if (c.command === 'quadraticCurveTo') {
                                var _c$args2 = c.args, qp1x = _c$args2[0], qp1y = _c$args2[1], p3x = _c$args2[2], p3y = _c$args2[3];
                                var cp1x = cx + 2 / 3 * (qp1x - cx);
                                var cp1y = cy + 2 / 3 * (qp1y - cy);
                                var cp2x = p3x + 2 / 3 * (qp1x - p3x);
                                var cp2y = p3y + 2 / 3 * (qp1y - p3y);
                            } else {
                                var _c$args3 = c.args, cp1x = _c$args3[0], cp1y = _c$args3[1], cp2x = _c$args3[2], cp2y = _c$args3[3], p3x = _c$args3[4], p3y = _c$args3[5];
                            }
                            bbox.addPoint(p3x, p3y);
                            var p0 = [
                                    cx,
                                    cy
                                ];
                            var p1 = [
                                    cp1x,
                                    cp1y
                                ];
                            var p2 = [
                                    cp2x,
                                    cp2y
                                ];
                            var p3 = [
                                    p3x,
                                    p3y
                                ];
                            for (var i = 0; i <= 1; i++) {
                                var b = 6 * p0[i] - 12 * p1[i] + 6 * p2[i];
                                var a = -3 * p0[i] + 9 * p1[i] - 9 * p2[i] + 3 * p3[i];
                                c = 3 * p1[i] - 3 * p0[i];
                                if (a === 0) {
                                    if (b === 0) {
                                        continue;
                                    }
                                    var t = -c / b;
                                    if (0 < t && t < 1) {
                                        if (i === 0) {
                                            bbox.addPoint(f(t), bbox.maxY);
                                        } else if (i === 1) {
                                            bbox.addPoint(bbox.maxX, f(t));
                                        }
                                    }
                                    continue;
                                }
                                var b2ac = Math.pow(b, 2) - 4 * c * a;
                                if (b2ac < 0) {
                                    continue;
                                }
                                var t1 = (-b + Math.sqrt(b2ac)) / (2 * a);
                                if (0 < t1 && t1 < 1) {
                                    if (i === 0) {
                                        bbox.addPoint(f(t1), bbox.maxY);
                                    } else if (i === 1) {
                                        bbox.addPoint(bbox.maxX, f(t1));
                                    }
                                }
                                var t2 = (-b - Math.sqrt(b2ac)) / (2 * a);
                                if (0 < t2 && t2 < 1) {
                                    if (i === 0) {
                                        bbox.addPoint(f(t2), bbox.maxY);
                                    } else if (i === 1) {
                                        bbox.addPoint(bbox.maxX, f(t2));
                                    }
                                }
                            }
                            cx = p3x;
                            cy = p3y;
                            break;
                        }
                    }
                    return this._bbox = _Object$freeze(bbox);
                }
            }
        ]);
        return Path;
    }();
var _arr = [
        'moveTo',
        'lineTo',
        'quadraticCurveTo',
        'bezierCurveTo',
        'closePath'
    ];
var _loop = function _loop() {
    var command = _arr[_i6];
    Path.prototype[command] = function () {
        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
        }
        this._bbox = this._cbox = null;
        this.commands.push({
            command: command,
            args: args
        });
        return this;
    };
};
for (var _i6 = 0; _i6 < _arr.length; _i6++) {
    _loop();
}
var StandardNames = [
        '.notdef',
        '.null',
        'nonmarkingreturn',
        'space',
        'exclam',
        'quotedbl',
        'numbersign',
        'dollar',
        'percent',
        'ampersand',
        'quotesingle',
        'parenleft',
        'parenright',
        'asterisk',
        'plus',
        'comma',
        'hyphen',
        'period',
        'slash',
        'zero',
        'one',
        'two',
        'three',
        'four',
        'five',
        'six',
        'seven',
        'eight',
        'nine',
        'colon',
        'semicolon',
        'less',
        'equal',
        'greater',
        'question',
        'at',
        'A',
        'B',
        'C',
        'D',
        'E',
        'F',
        'G',
        'H',
        'I',
        'J',
        'K',
        'L',
        'M',
        'N',
        'O',
        'P',
        'Q',
        'R',
        'S',
        'T',
        'U',
        'V',
        'W',
        'X',
        'Y',
        'Z',
        'bracketleft',
        'backslash',
        'bracketright',
        'asciicircum',
        'underscore',
        'grave',
        'a',
        'b',
        'c',
        'd',
        'e',
        'f',
        'g',
        'h',
        'i',
        'j',
        'k',
        'l',
        'm',
        'n',
        'o',
        'p',
        'q',
        'r',
        's',
        't',
        'u',
        'v',
        'w',
        'x',
        'y',
        'z',
        'braceleft',
        'bar',
        'braceright',
        'asciitilde',
        'Adieresis',
        'Aring',
        'Ccedilla',
        'Eacute',
        'Ntilde',
        'Odieresis',
        'Udieresis',
        'aacute',
        'agrave',
        'acircumflex',
        'adieresis',
        'atilde',
        'aring',
        'ccedilla',
        'eacute',
        'egrave',
        'ecircumflex',
        'edieresis',
        'iacute',
        'igrave',
        'icircumflex',
        'idieresis',
        'ntilde',
        'oacute',
        'ograve',
        'ocircumflex',
        'odieresis',
        'otilde',
        'uacute',
        'ugrave',
        'ucircumflex',
        'udieresis',
        'dagger',
        'degree',
        'cent',
        'sterling',
        'section',
        'bullet',
        'paragraph',
        'germandbls',
        'registered',
        'copyright',
        'trademark',
        'acute',
        'dieresis',
        'notequal',
        'AE',
        'Oslash',
        'infinity',
        'plusminus',
        'lessequal',
        'greaterequal',
        'yen',
        'mu',
        'partialdiff',
        'summation',
        'product',
        'pi',
        'integral',
        'ordfeminine',
        'ordmasculine',
        'Omega',
        'ae',
        'oslash',
        'questiondown',
        'exclamdown',
        'logicalnot',
        'radical',
        'florin',
        'approxequal',
        'Delta',
        'guillemotleft',
        'guillemotright',
        'ellipsis',
        'nonbreakingspace',
        'Agrave',
        'Atilde',
        'Otilde',
        'OE',
        'oe',
        'endash',
        'emdash',
        'quotedblleft',
        'quotedblright',
        'quoteleft',
        'quoteright',
        'divide',
        'lozenge',
        'ydieresis',
        'Ydieresis',
        'fraction',
        'currency',
        'guilsinglleft',
        'guilsinglright',
        'fi',
        'fl',
        'daggerdbl',
        'periodcentered',
        'quotesinglbase',
        'quotedblbase',
        'perthousand',
        'Acircumflex',
        'Ecircumflex',
        'Aacute',
        'Edieresis',
        'Egrave',
        'Iacute',
        'Icircumflex',
        'Idieresis',
        'Igrave',
        'Oacute',
        'Ocircumflex',
        'apple',
        'Ograve',
        'Uacute',
        'Ucircumflex',
        'Ugrave',
        'dotlessi',
        'circumflex',
        'tilde',
        'macron',
        'breve',
        'dotaccent',
        'ring',
        'cedilla',
        'hungarumlaut',
        'ogonek',
        'caron',
        'Lslash',
        'lslash',
        'Scaron',
        'scaron',
        'Zcaron',
        'zcaron',
        'brokenbar',
        'Eth',
        'eth',
        'Yacute',
        'yacute',
        'Thorn',
        'thorn',
        'minus',
        'multiply',
        'onesuperior',
        'twosuperior',
        'threesuperior',
        'onehalf',
        'onequarter',
        'threequarters',
        'franc',
        'Gbreve',
        'gbreve',
        'Idotaccent',
        'Scedilla',
        'scedilla',
        'Cacute',
        'cacute',
        'Ccaron',
        'ccaron',
        'dcroat'
    ];
var _class$8;
function _applyDecoratedDescriptor$4(target, property, decorators, descriptor, context) {
    var desc = {};
    Object['ke' + 'ys'](descriptor).forEach(function (key) {
        desc[key] = descriptor[key];
    });
    desc.enumerable = !!desc.enumerable;
    desc.configurable = !!desc.configurable;
    if ('value' in desc || desc.initializer) {
        desc.writable = true;
    }
    desc = decorators.slice().reverse().reduce(function (desc, decorator) {
        return decorator(target, property, desc) || desc;
    }, desc);
    if (context && desc.initializer !== void 0) {
        desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
        desc.initializer = undefined;
    }
    if (desc.initializer === void 0) {
        Object['define' + 'Property'](target, property, desc);
        desc = null;
    }
    return desc;
}
var Glyph = (_class$8 = function () {
        function Glyph(id, codePoints, font) {
            _classCallCheck(this, Glyph);
            this.id = id;
            this.codePoints = codePoints;
            this._font = font;
            this.isMark = this.codePoints.length > 0 && this.codePoints.every(unicode.isMark);
            this.isLigature = this.codePoints.length > 1;
        }
        Glyph.prototype._getPath = function _getPath() {
            return new Path();
        };
        Glyph.prototype._getCBox = function _getCBox() {
            return this.path.cbox;
        };
        Glyph.prototype._getBBox = function _getBBox() {
            return this.path.bbox;
        };
        Glyph.prototype._getTableMetrics = function _getTableMetrics(table) {
            if (this.id < table.metrics.length) {
                return table.metrics.get(this.id);
            }
            var metric = table.metrics.get(table.metrics.length - 1);
            var res = {
                    advance: metric ? metric.advance : 0,
                    bearing: table.bearings.get(this.id - table.metrics.length) || 0
                };
            return res;
        };
        Glyph.prototype._getMetrics = function _getMetrics(cbox) {
            if (this._metrics) {
                return this._metrics;
            }
            var _getTableMetrics2 = this._getTableMetrics(this._font.hmtx), advanceWidth = _getTableMetrics2.advance, leftBearing = _getTableMetrics2.bearing;
            if (this._font.vmtx) {
                var _getTableMetrics3 = this._getTableMetrics(this._font.vmtx), advanceHeight = _getTableMetrics3.advance, topBearing = _getTableMetrics3.bearing;
            } else {
                var os2 = void 0;
                if (typeof cbox === 'undefined' || cbox === null) {
                    cbox = this.cbox;
                }
                if ((os2 = this._font['OS/2']) && os2.version > 0) {
                    var advanceHeight = Math.abs(os2.typoAscender - os2.typoDescender);
                    var topBearing = os2.typoAscender - cbox.maxY;
                } else {
                    var hhea = this._font.hhea;
                    var advanceHeight = Math.abs(hhea.ascent - hhea.descent);
                    var topBearing = hhea.ascent - cbox.maxY;
                }
            }
            if (this._font._variationProcessor && this._font.HVAR) {
                advanceWidth += this._font._variationProcessor.getAdvanceAdjustment(this.id, this._font.HVAR);
            }
            return this._metrics = {
                advanceWidth: advanceWidth,
                advanceHeight: advanceHeight,
                leftBearing: leftBearing,
                topBearing: topBearing
            };
        };
        Glyph.prototype.getScaledPath = function getScaledPath(size) {
            var scale = 1 / this._font.unitsPerEm * size;
            return this.path.scale(scale);
        };
        Glyph.prototype._getName = function _getName() {
            var post = this._font.post;
            if (!post) {
                return null;
            }
            switch (post.version) {
            case 1:
                return StandardNames[this.id];
            case 2:
                var id = post.glyphNameIndex[this.id];
                if (id < StandardNames.length) {
                    return StandardNames[id];
                }
                return post.names[id - StandardNames.length];
            case 2.5:
                return StandardNames[this.id + post.offsets[this.id]];
            case 4:
                return String.fromCharCode(post.map[this.id]);
            }
        };
        Glyph.prototype.render = function render(ctx, size) {
            ctx.save();
            var scale = 1 / this._font.head.unitsPerEm * size;
            ctx.scale(scale, scale);
            var fn = this.path.toFunction();
            fn(ctx);
            ctx.fill();
            ctx.restore();
        };
        _createClass(Glyph, [
            {
                key: 'cbox',
                get: function get() {
                    return this._getCBox();
                }
            },
            {
                key: 'bbox',
                get: function get() {
                    return this._getBBox();
                }
            },
            {
                key: 'path',
                get: function get() {
                    return this._getPath();
                }
            },
            {
                key: 'advanceWidth',
                get: function get() {
                    return this._getMetrics().advanceWidth;
                }
            },
            {
                key: 'advanceHeight',
                get: function get() {
                    return this._getMetrics().advanceHeight;
                }
            },
            {
                key: 'ligatureCaretPositions',
                get: function get() {
                }
            },
            {
                key: 'name',
                get: function get() {
                    return this._getName();
                }
            }
        ]);
        return Glyph;
    }(), (_applyDecoratedDescriptor$4(_class$8.prototype, 'cbox', [cache], _Object$getOwnPropertyDescriptor(_class$8.prototype, 'cbox'), _class$8.prototype), _applyDecoratedDescriptor$4(_class$8.prototype, 'bbox', [cache], _Object$getOwnPropertyDescriptor(_class$8.prototype, 'bbox'), _class$8.prototype), _applyDecoratedDescriptor$4(_class$8.prototype, 'path', [cache], _Object$getOwnPropertyDescriptor(_class$8.prototype, 'path'), _class$8.prototype), _applyDecoratedDescriptor$4(_class$8.prototype, 'advanceWidth', [cache], _Object$getOwnPropertyDescriptor(_class$8.prototype, 'advanceWidth'), _class$8.prototype), _applyDecoratedDescriptor$4(_class$8.prototype, 'advanceHeight', [cache], _Object$getOwnPropertyDescriptor(_class$8.prototype, 'advanceHeight'), _class$8.prototype), _applyDecoratedDescriptor$4(_class$8.prototype, 'name', [cache], _Object$getOwnPropertyDescriptor(_class$8.prototype, 'name'), _class$8.prototype)), _class$8);
var GlyfHeader = new r.Struct({
        numberOfContours: r.int16,
        xMin: r.int16,
        yMin: r.int16,
        xMax: r.int16,
        yMax: r.int16
    });
var ON_CURVE = 1 << 0;
var X_SHORT_VECTOR = 1 << 1;
var Y_SHORT_VECTOR = 1 << 2;
var REPEAT = 1 << 3;
var SAME_X = 1 << 4;
var SAME_Y = 1 << 5;
var ARG_1_AND_2_ARE_WORDS = 1 << 0;
var WE_HAVE_A_SCALE = 1 << 3;
var MORE_COMPONENTS = 1 << 5;
var WE_HAVE_AN_X_AND_Y_SCALE = 1 << 6;
var WE_HAVE_A_TWO_BY_TWO = 1 << 7;
var WE_HAVE_INSTRUCTIONS = 1 << 8;
var Point = function () {
        function Point(onCurve, endContour) {
            var x = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
            var y = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
            _classCallCheck(this, Point);
            this.onCurve = onCurve;
            this.endContour = endContour;
            this.x = x;
            this.y = y;
        }
        Point.prototype.copy = function copy() {
            return new Point(this.onCurve, this.endContour, this.x, this.y);
        };
        return Point;
    }();
var Component = function Component(glyphID, dx, dy) {
    _classCallCheck(this, Component);
    this.glyphID = glyphID;
    this.dx = dx;
    this.dy = dy;
    this.pos = 0;
    this.scaleX = this.scaleY = 1;
    this.scale01 = this.scale10 = 0;
};
var TTFGlyph = function (_Glyph) {
        _inherits(TTFGlyph, _Glyph);
        function TTFGlyph() {
            _classCallCheck(this, TTFGlyph);
            return _possibleConstructorReturn(this, _Glyph.apply(this, arguments));
        }
        TTFGlyph.prototype._getCBox = function _getCBox(internal) {
            if (this._font._variationProcessor && !internal) {
                return this.path.cbox;
            }
            var stream = this._font._getTableStream('glyf');
            stream.pos += this._font.loca.offsets[this.id];
            var glyph = GlyfHeader.decode(stream);
            var cbox = new BBox(glyph.xMin, glyph.yMin, glyph.xMax, glyph.yMax);
            return _Object$freeze(cbox);
        };
        TTFGlyph.prototype._parseGlyphCoord = function _parseGlyphCoord(stream, prev, short, same) {
            if (short) {
                var val = stream.readUInt8();
                if (!same) {
                    val = -val;
                }
                val += prev;
            } else {
                if (same) {
                    var val = prev;
                } else {
                    var val = prev + stream.readInt16BE();
                }
            }
            return val;
        };
        TTFGlyph.prototype._decode = function _decode() {
            var glyfPos = this._font.loca.offsets[this.id];
            var nextPos = this._font.loca.offsets[this.id + 1];
            if (glyfPos === nextPos) {
                return null;
            }
            var stream = this._font._getTableStream('glyf');
            stream.pos += glyfPos;
            var startPos = stream.pos;
            var glyph = GlyfHeader.decode(stream);
            if (glyph.numberOfContours > 0) {
                this._decodeSimple(glyph, stream);
            } else if (glyph.numberOfContours < 0) {
                this._decodeComposite(glyph, stream, startPos);
            }
            return glyph;
        };
        TTFGlyph.prototype._decodeSimple = function _decodeSimple(glyph, stream) {
            glyph.points = [];
            var endPtsOfContours = new r.Array(r.uint16, glyph.numberOfContours).decode(stream);
            glyph.instructions = new r.Array(r.uint8, r.uint16).decode(stream);
            var flags = [];
            var numCoords = endPtsOfContours[endPtsOfContours.length - 1] + 1;
            while (flags.length < numCoords) {
                var flag = stream.readUInt8();
                flags.push(flag);
                if (flag & REPEAT) {
                    var count = stream.readUInt8();
                    for (var j = 0; j < count; j++) {
                        flags.push(flag);
                    }
                }
            }
            for (var i = 0; i < flags.length; i++) {
                var flag = flags[i];
                var point = new Point(!!(flag & ON_CURVE), endPtsOfContours.indexOf(i) >= 0, 0, 0);
                glyph.points.push(point);
            }
            var px = 0;
            for (var i = 0; i < flags.length; i++) {
                var flag = flags[i];
                glyph.points[i].x = px = this._parseGlyphCoord(stream, px, flag & X_SHORT_VECTOR, flag & SAME_X);
            }
            var py = 0;
            for (var i = 0; i < flags.length; i++) {
                var flag = flags[i];
                glyph.points[i].y = py = this._parseGlyphCoord(stream, py, flag & Y_SHORT_VECTOR, flag & SAME_Y);
            }
            if (this._font._variationProcessor) {
                var points = glyph.points.slice();
                points.push.apply(points, this._getPhantomPoints(glyph));
                this._font._variationProcessor.transformPoints(this.id, points);
                glyph.phantomPoints = points.slice(-4);
            }
            return;
        };
        TTFGlyph.prototype._decodeComposite = function _decodeComposite(glyph, stream) {
            var offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
            glyph.components = [];
            var haveInstructions = false;
            var flags = MORE_COMPONENTS;
            while (flags & MORE_COMPONENTS) {
                flags = stream.readUInt16BE();
                var gPos = stream.pos - offset;
                var glyphID = stream.readUInt16BE();
                if (!haveInstructions) {
                    haveInstructions = (flags & WE_HAVE_INSTRUCTIONS) !== 0;
                }
                if (flags & ARG_1_AND_2_ARE_WORDS) {
                    var dx = stream.readInt16BE();
                    var dy = stream.readInt16BE();
                } else {
                    var dx = stream.readInt8();
                    var dy = stream.readInt8();
                }
                var component = new Component(glyphID, dx, dy);
                component.pos = gPos;
                if (flags & WE_HAVE_A_SCALE) {
                    component.scaleX = component.scaleY = (stream.readUInt8() << 24 | stream.readUInt8() << 16) / 1073741824;
                } else if (flags & WE_HAVE_AN_X_AND_Y_SCALE) {
                    component.scaleX = (stream.readUInt8() << 24 | stream.readUInt8() << 16) / 1073741824;
                    component.scaleY = (stream.readUInt8() << 24 | stream.readUInt8() << 16) / 1073741824;
                } else if (flags & WE_HAVE_A_TWO_BY_TWO) {
                    component.scaleX = (stream.readUInt8() << 24 | stream.readUInt8() << 16) / 1073741824;
                    component.scale01 = (stream.readUInt8() << 24 | stream.readUInt8() << 16) / 1073741824;
                    component.scale10 = (stream.readUInt8() << 24 | stream.readUInt8() << 16) / 1073741824;
                    component.scaleY = (stream.readUInt8() << 24 | stream.readUInt8() << 16) / 1073741824;
                }
                glyph.components.push(component);
            }
            if (this._font._variationProcessor) {
                var points = [];
                for (var j = 0; j < glyph.components.length; j++) {
                    var component = glyph.components[j];
                    points.push(new Point(true, true, component.dx, component.dy));
                }
                points.push.apply(points, this._getPhantomPoints(glyph));
                this._font._variationProcessor.transformPoints(this.id, points);
                glyph.phantomPoints = points.splice(-4, 4);
                for (var i = 0; i < points.length; i++) {
                    var point = points[i];
                    glyph.components[i].dx = point.x;
                    glyph.components[i].dy = point.y;
                }
            }
            return haveInstructions;
        };
        TTFGlyph.prototype._getPhantomPoints = function _getPhantomPoints(glyph) {
            var cbox = this._getCBox(true);
            if (this._metrics == null) {
                this._metrics = Glyph.prototype._getMetrics.call(this, cbox);
            }
            var _metrics = this._metrics, advanceWidth = _metrics.advanceWidth, advanceHeight = _metrics.advanceHeight, leftBearing = _metrics.leftBearing, topBearing = _metrics.topBearing;
            return [
                new Point(false, true, glyph.xMin - leftBearing, 0),
                new Point(false, true, glyph.xMin - leftBearing + advanceWidth, 0),
                new Point(false, true, 0, glyph.yMax + topBearing),
                new Point(false, true, 0, glyph.yMax + topBearing + advanceHeight)
            ];
        };
        TTFGlyph.prototype._getContours = function _getContours() {
            var glyph = this._decode();
            if (!glyph) {
                return [];
            }
            var points = [];
            if (glyph.numberOfContours < 0) {
                for (var _iterator = glyph.components, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _getIterator(_iterator);;) {
                    var _ref;
                    if (_isArray) {
                        if (_i >= _iterator.length)
                            break;
                        _ref = _iterator[_i++];
                    } else {
                        _i = _iterator.next();
                        if (_i.done)
                            break;
                        _ref = _i.value;
                    }
                    var component = _ref;
                    var _contours = this._font.getGlyph(component.glyphID)._getContours();
                    for (var i = 0; i < _contours.length; i++) {
                        var contour = _contours[i];
                        for (var j = 0; j < contour.length; j++) {
                            var _point = contour[j];
                            var x = _point.x * component.scaleX + _point.y * component.scale01 + component.dx;
                            var y = _point.y * component.scaleY + _point.x * component.scale10 + component.dy;
                            points.push(new Point(_point.onCurve, _point.endContour, x, y));
                        }
                    }
                }
            } else {
                points = glyph.points || [];
            }
            if (glyph.phantomPoints && !this._font.directory.tables.HVAR) {
                this._metrics.advanceWidth = glyph.phantomPoints[1].x - glyph.phantomPoints[0].x;
                this._metrics.advanceHeight = glyph.phantomPoints[3].y - glyph.phantomPoints[2].y;
                this._metrics.leftBearing = glyph.xMin - glyph.phantomPoints[0].x;
                this._metrics.topBearing = glyph.phantomPoints[2].y - glyph.yMax;
            }
            var contours = [];
            var cur = [];
            for (var k = 0; k < points.length; k++) {
                var point = points[k];
                cur.push(point);
                if (point.endContour) {
                    contours.push(cur);
                    cur = [];
                }
            }
            return contours;
        };
        TTFGlyph.prototype._getMetrics = function _getMetrics() {
            if (this._metrics) {
                return this._metrics;
            }
            var cbox = this._getCBox(true);
            _Glyph.prototype._getMetrics.call(this, cbox);
            if (this._font._variationProcessor && !this._font.HVAR) {
                this.path;
            }
            return this._metrics;
        };
        TTFGlyph.prototype._getPath = function _getPath() {
            var contours = this._getContours();
            var path = new Path();
            for (var i = 0; i < contours.length; i++) {
                var contour = contours[i];
                var firstPt = contour[0];
                var lastPt = contour[contour.length - 1];
                var start = 0;
                if (firstPt.onCurve) {
                    var curvePt = null;
                    start = 1;
                } else {
                    if (lastPt.onCurve) {
                        firstPt = lastPt;
                    } else {
                        firstPt = new Point(false, false, (firstPt.x + lastPt.x) / 2, (firstPt.y + lastPt.y) / 2);
                    }
                    var curvePt = firstPt;
                }
                path.moveTo(firstPt.x, firstPt.y);
                for (var j = start; j < contour.length; j++) {
                    var pt = contour[j];
                    var prevPt = j === 0 ? firstPt : contour[j - 1];
                    if (prevPt.onCurve && pt.onCurve) {
                        path.lineTo(pt.x, pt.y);
                    } else if (prevPt.onCurve && !pt.onCurve) {
                        var curvePt = pt;
                    } else if (!prevPt.onCurve && !pt.onCurve) {
                        var midX = (prevPt.x + pt.x) / 2;
                        var midY = (prevPt.y + pt.y) / 2;
                        path.quadraticCurveTo(prevPt.x, prevPt.y, midX, midY);
                        var curvePt = pt;
                    } else if (!prevPt.onCurve && pt.onCurve) {
                        path.quadraticCurveTo(curvePt.x, curvePt.y, pt.x, pt.y);
                        var curvePt = null;
                    } else {
                        throw new Error('Unknown TTF path state');
                    }
                }
                if (curvePt) {
                    path.quadraticCurveTo(curvePt.x, curvePt.y, firstPt.x, firstPt.y);
                }
                path.closePath();
            }
            return path;
        };
        return TTFGlyph;
    }(Glyph);
var CFFGlyph = function (_Glyph) {
        _inherits(CFFGlyph, _Glyph);
        function CFFGlyph() {
            _classCallCheck(this, CFFGlyph);
            return _possibleConstructorReturn(this, _Glyph.apply(this, arguments));
        }
        CFFGlyph.prototype._getName = function _getName() {
            if (this._font.CFF2) {
                return _Glyph.prototype._getName.call(this);
            }
            return this._font['CFF '].getGlyphName(this.id);
        };
        CFFGlyph.prototype.bias = function bias(s) {
            if (s.length < 1240) {
                return 107;
            } else if (s.length < 33900) {
                return 1131;
            } else {
                return 32768;
            }
        };
        CFFGlyph.prototype._getPath = function _getPath() {
            var stream = this._font.stream;
            var pos = stream.pos;
            var cff = this._font.CFF2 || this._font['CFF '];
            var str = cff.topDict.CharStrings[this.id];
            var end = str.offset + str.length;
            stream.pos = str.offset;
            var path = new Path();
            var stack = [];
            var trans = [];
            var width = null;
            var nStems = 0;
            var x = 0, y = 0;
            var usedGsubrs = void 0;
            var usedSubrs = void 0;
            var open = false;
            this._usedGsubrs = usedGsubrs = {};
            this._usedSubrs = usedSubrs = {};
            var gsubrs = cff.globalSubrIndex || [];
            var gsubrsBias = this.bias(gsubrs);
            var privateDict = cff.privateDictForGlyph(this.id) || {};
            var subrs = privateDict.Subrs || [];
            var subrsBias = this.bias(subrs);
            var vstore = cff.topDict.vstore && cff.topDict.vstore.itemVariationStore;
            var vsindex = privateDict.vsindex;
            var variationProcessor = this._font._variationProcessor;
            function checkWidth() {
                if (width == null) {
                    width = stack.shift() + privateDict.nominalWidthX;
                }
            }
            function parseStems() {
                if (stack.length % 2 !== 0) {
                    checkWidth();
                }
                nStems += stack.length >> 1;
                return stack.length = 0;
            }
            function moveTo(x, y) {
                if (open) {
                    path.closePath();
                }
                path.moveTo(x, y);
                open = true;
            }
            var parse = function parse() {
                while (stream.pos < end) {
                    var op = stream.readUInt8();
                    if (op < 32) {
                        switch (op) {
                        case 1:
                        case 3:
                        case 18:
                        case 23:
                            parseStems();
                            break;
                        case 4:
                            if (stack.length > 1) {
                                checkWidth();
                            }
                            y += stack.shift();
                            moveTo(x, y);
                            break;
                        case 5:
                            while (stack.length >= 2) {
                                x += stack.shift();
                                y += stack.shift();
                                path.lineTo(x, y);
                            }
                            break;
                        case 6:
                        case 7:
                            var phase = op === 6;
                            while (stack.length >= 1) {
                                if (phase) {
                                    x += stack.shift();
                                } else {
                                    y += stack.shift();
                                }
                                path.lineTo(x, y);
                                phase = !phase;
                            }
                            break;
                        case 8:
                            while (stack.length > 0) {
                                var c1x = x + stack.shift();
                                var c1y = y + stack.shift();
                                var c2x = c1x + stack.shift();
                                var c2y = c1y + stack.shift();
                                x = c2x + stack.shift();
                                y = c2y + stack.shift();
                                path.bezierCurveTo(c1x, c1y, c2x, c2y, x, y);
                            }
                            break;
                        case 10:
                            var index = stack.pop() + subrsBias;
                            var subr = subrs[index];
                            if (subr) {
                                usedSubrs[index] = true;
                                var p = stream.pos;
                                var e = end;
                                stream.pos = subr.offset;
                                end = subr.offset + subr.length;
                                parse();
                                stream.pos = p;
                                end = e;
                            }
                            break;
                        case 11:
                            if (cff.version >= 2) {
                                break;
                            }
                            return;
                        case 14:
                            if (cff.version >= 2) {
                                break;
                            }
                            if (stack.length > 0) {
                                checkWidth();
                            }
                            if (open) {
                                path.closePath();
                                open = false;
                            }
                            break;
                        case 15: {
                                if (cff.version < 2) {
                                    throw new Error('vsindex operator not supported in CFF v1');
                                }
                                vsindex = stack.pop();
                                break;
                            }
                        case 16: {
                                if (cff.version < 2) {
                                    throw new Error('blend operator not supported in CFF v1');
                                }
                                if (!variationProcessor) {
                                    throw new Error('blend operator in non-variation font');
                                }
                                var blendVector = variationProcessor.getBlendVector(vstore, vsindex);
                                var numBlends = stack.pop();
                                var numOperands = numBlends * blendVector.length;
                                var delta = stack.length - numOperands;
                                var base = delta - numBlends;
                                for (var i = 0; i < numBlends; i++) {
                                    var sum = stack[base + i];
                                    for (var j = 0; j < blendVector.length; j++) {
                                        sum += blendVector[j] * stack[delta++];
                                    }
                                    stack[base + i] = sum;
                                }
                                while (numOperands--) {
                                    stack.pop();
                                }
                                break;
                            }
                        case 19:
                        case 20:
                            parseStems();
                            stream.pos += nStems + 7 >> 3;
                            break;
                        case 21:
                            if (stack.length > 2) {
                                checkWidth();
                            }
                            x += stack.shift();
                            y += stack.shift();
                            moveTo(x, y);
                            break;
                        case 22:
                            if (stack.length > 1) {
                                checkWidth();
                            }
                            x += stack.shift();
                            moveTo(x, y);
                            break;
                        case 24:
                            while (stack.length >= 8) {
                                var c1x = x + stack.shift();
                                var c1y = y + stack.shift();
                                var c2x = c1x + stack.shift();
                                var c2y = c1y + stack.shift();
                                x = c2x + stack.shift();
                                y = c2y + stack.shift();
                                path.bezierCurveTo(c1x, c1y, c2x, c2y, x, y);
                            }
                            x += stack.shift();
                            y += stack.shift();
                            path.lineTo(x, y);
                            break;
                        case 25:
                            while (stack.length >= 8) {
                                x += stack.shift();
                                y += stack.shift();
                                path.lineTo(x, y);
                            }
                            var c1x = x + stack.shift();
                            var c1y = y + stack.shift();
                            var c2x = c1x + stack.shift();
                            var c2y = c1y + stack.shift();
                            x = c2x + stack.shift();
                            y = c2y + stack.shift();
                            path.bezierCurveTo(c1x, c1y, c2x, c2y, x, y);
                            break;
                        case 26:
                            if (stack.length % 2) {
                                x += stack.shift();
                            }
                            while (stack.length >= 4) {
                                c1x = x;
                                c1y = y + stack.shift();
                                c2x = c1x + stack.shift();
                                c2y = c1y + stack.shift();
                                x = c2x;
                                y = c2y + stack.shift();
                                path.bezierCurveTo(c1x, c1y, c2x, c2y, x, y);
                            }
                            break;
                        case 27:
                            if (stack.length % 2) {
                                y += stack.shift();
                            }
                            while (stack.length >= 4) {
                                c1x = x + stack.shift();
                                c1y = y;
                                c2x = c1x + stack.shift();
                                c2y = c1y + stack.shift();
                                x = c2x + stack.shift();
                                y = c2y;
                                path.bezierCurveTo(c1x, c1y, c2x, c2y, x, y);
                            }
                            break;
                        case 28:
                            stack.push(stream.readInt16BE());
                            break;
                        case 29:
                            index = stack.pop() + gsubrsBias;
                            subr = gsubrs[index];
                            if (subr) {
                                usedGsubrs[index] = true;
                                var p = stream.pos;
                                var e = end;
                                stream.pos = subr.offset;
                                end = subr.offset + subr.length;
                                parse();
                                stream.pos = p;
                                end = e;
                            }
                            break;
                        case 30:
                        case 31:
                            phase = op === 31;
                            while (stack.length >= 4) {
                                if (phase) {
                                    c1x = x + stack.shift();
                                    c1y = y;
                                    c2x = c1x + stack.shift();
                                    c2y = c1y + stack.shift();
                                    y = c2y + stack.shift();
                                    x = c2x + (stack.length === 1 ? stack.shift() : 0);
                                } else {
                                    c1x = x;
                                    c1y = y + stack.shift();
                                    c2x = c1x + stack.shift();
                                    c2y = c1y + stack.shift();
                                    x = c2x + stack.shift();
                                    y = c2y + (stack.length === 1 ? stack.shift() : 0);
                                }
                                path.bezierCurveTo(c1x, c1y, c2x, c2y, x, y);
                                phase = !phase;
                            }
                            break;
                        case 12:
                            op = stream.readUInt8();
                            switch (op) {
                            case 3:
                                var a = stack.pop();
                                var b = stack.pop();
                                stack.push(a && b ? 1 : 0);
                                break;
                            case 4:
                                a = stack.pop();
                                b = stack.pop();
                                stack.push(a || b ? 1 : 0);
                                break;
                            case 5:
                                a = stack.pop();
                                stack.push(a ? 0 : 1);
                                break;
                            case 9:
                                a = stack.pop();
                                stack.push(Math.abs(a));
                                break;
                            case 10:
                                a = stack.pop();
                                b = stack.pop();
                                stack.push(a + b);
                                break;
                            case 11:
                                a = stack.pop();
                                b = stack.pop();
                                stack.push(a - b);
                                break;
                            case 12:
                                a = stack.pop();
                                b = stack.pop();
                                stack.push(a / b);
                                break;
                            case 14:
                                a = stack.pop();
                                stack.push(-a);
                                break;
                            case 15:
                                a = stack.pop();
                                b = stack.pop();
                                stack.push(a === b ? 1 : 0);
                                break;
                            case 18:
                                stack.pop();
                                break;
                            case 20:
                                var val = stack.pop();
                                var idx = stack.pop();
                                trans[idx] = val;
                                break;
                            case 21:
                                idx = stack.pop();
                                stack.push(trans[idx] || 0);
                                break;
                            case 22:
                                var s1 = stack.pop();
                                var s2 = stack.pop();
                                var v1 = stack.pop();
                                var v2 = stack.pop();
                                stack.push(v1 <= v2 ? s1 : s2);
                                break;
                            case 23:
                                stack.push(Math.random());
                                break;
                            case 24:
                                a = stack.pop();
                                b = stack.pop();
                                stack.push(a * b);
                                break;
                            case 26:
                                a = stack.pop();
                                stack.push(Math.sqrt(a));
                                break;
                            case 27:
                                a = stack.pop();
                                stack.push(a, a);
                                break;
                            case 28:
                                a = stack.pop();
                                b = stack.pop();
                                stack.push(b, a);
                                break;
                            case 29:
                                idx = stack.pop();
                                if (idx < 0) {
                                    idx = 0;
                                } else if (idx > stack.length - 1) {
                                    idx = stack.length - 1;
                                }
                                stack.push(stack[idx]);
                                break;
                            case 30:
                                var n = stack.pop();
                                var _j = stack.pop();
                                if (_j >= 0) {
                                    while (_j > 0) {
                                        var t = stack[n - 1];
                                        for (var _i = n - 2; _i >= 0; _i--) {
                                            stack[_i + 1] = stack[_i];
                                        }
                                        stack[0] = t;
                                        _j--;
                                    }
                                } else {
                                    while (_j < 0) {
                                        var t = stack[0];
                                        for (var _i2 = 0; _i2 <= n; _i2++) {
                                            stack[_i2] = stack[_i2 + 1];
                                        }
                                        stack[n - 1] = t;
                                        _j++;
                                    }
                                }
                                break;
                            case 34:
                                c1x = x + stack.shift();
                                c1y = y;
                                c2x = c1x + stack.shift();
                                c2y = c1y + stack.shift();
                                var c3x = c2x + stack.shift();
                                var c3y = c2y;
                                var c4x = c3x + stack.shift();
                                var c4y = c3y;
                                var c5x = c4x + stack.shift();
                                var c5y = c4y;
                                var c6x = c5x + stack.shift();
                                var c6y = c5y;
                                x = c6x;
                                y = c6y;
                                path.bezierCurveTo(c1x, c1y, c2x, c2y, c3x, c3y);
                                path.bezierCurveTo(c4x, c4y, c5x, c5y, c6x, c6y);
                                break;
                            case 35:
                                var pts = [];
                                for (var _i3 = 0; _i3 <= 5; _i3++) {
                                    x += stack.shift();
                                    y += stack.shift();
                                    pts.push(x, y);
                                }
                                path.bezierCurveTo.apply(path, pts.slice(0, 6));
                                path.bezierCurveTo.apply(path, pts.slice(6));
                                stack.shift();
                                break;
                            case 36:
                                c1x = x + stack.shift();
                                c1y = y + stack.shift();
                                c2x = c1x + stack.shift();
                                c2y = c1y + stack.shift();
                                c3x = c2x + stack.shift();
                                c3y = c2y;
                                c4x = c3x + stack.shift();
                                c4y = c3y;
                                c5x = c4x + stack.shift();
                                c5y = c4y + stack.shift();
                                c6x = c5x + stack.shift();
                                c6y = c5y;
                                x = c6x;
                                y = c6y;
                                path.bezierCurveTo(c1x, c1y, c2x, c2y, c3x, c3y);
                                path.bezierCurveTo(c4x, c4y, c5x, c5y, c6x, c6y);
                                break;
                            case 37:
                                var startx = x;
                                var starty = y;
                                pts = [];
                                for (var _i4 = 0; _i4 <= 4; _i4++) {
                                    x += stack.shift();
                                    y += stack.shift();
                                    pts.push(x, y);
                                }
                                if (Math.abs(x - startx) > Math.abs(y - starty)) {
                                    x += stack.shift();
                                    y = starty;
                                } else {
                                    x = startx;
                                    y += stack.shift();
                                }
                                pts.push(x, y);
                                path.bezierCurveTo.apply(path, pts.slice(0, 6));
                                path.bezierCurveTo.apply(path, pts.slice(6));
                                break;
                            default:
                                throw new Error('Unknown op: 12 ' + op);
                            }
                            break;
                        default:
                            throw new Error('Unknown op: ' + op);
                        }
                    } else if (op < 247) {
                        stack.push(op - 139);
                    } else if (op < 251) {
                        var b1 = stream.readUInt8();
                        stack.push((op - 247) * 256 + b1 + 108);
                    } else if (op < 255) {
                        var b1 = stream.readUInt8();
                        stack.push(-(op - 251) * 256 - b1 - 108);
                    } else {
                        stack.push(stream.readInt32BE() / 65536);
                    }
                }
            };
            parse();
            if (open) {
                path.closePath();
            }
            return path;
        };
        return CFFGlyph;
    }(Glyph);
var SBIXImage = new r.Struct({
        originX: r.uint16,
        originY: r.uint16,
        type: new r.String(4),
        data: new r.Buffer(function (t) {
            return t.parent.buflen - t._currentOffset;
        })
    });
var SBIXGlyph = function (_TTFGlyph) {
        _inherits(SBIXGlyph, _TTFGlyph);
        function SBIXGlyph() {
            _classCallCheck(this, SBIXGlyph);
            return _possibleConstructorReturn(this, _TTFGlyph.apply(this, arguments));
        }
        SBIXGlyph.prototype.getImageForSize = function getImageForSize(size) {
            for (var i = 0; i < this._font.sbix.imageTables.length; i++) {
                var table = this._font.sbix.imageTables[i];
                if (table.ppem >= size) {
                    break;
                }
            }
            var offsets = table.imageOffsets;
            var start = offsets[this.id];
            var end = offsets[this.id + 1];
            if (start === end) {
                return null;
            }
            this._font.stream.pos = start;
            return SBIXImage.decode(this._font.stream, { buflen: end - start });
        };
        SBIXGlyph.prototype.render = function render(ctx, size) {
            var img = this.getImageForSize(size);
            if (img != null) {
                var scale = size / this._font.unitsPerEm;
                ctx.image(img.data, {
                    height: size,
                    x: img.originX,
                    y: (this.bbox.minY - img.originY) * scale
                });
            }
            if (this._font.sbix.flags.renderOutlines) {
                _TTFGlyph.prototype.render.call(this, ctx, size);
            }
        };
        return SBIXGlyph;
    }(TTFGlyph);
var COLRLayer = function COLRLayer(glyph, color) {
    _classCallCheck(this, COLRLayer);
    this.glyph = glyph;
    this.color = color;
};
var COLRGlyph = function (_Glyph) {
        _inherits(COLRGlyph, _Glyph);
        function COLRGlyph() {
            _classCallCheck(this, COLRGlyph);
            return _possibleConstructorReturn(this, _Glyph.apply(this, arguments));
        }
        COLRGlyph.prototype._getBBox = function _getBBox() {
            var bbox = new BBox();
            for (var i = 0; i < this.layers.length; i++) {
                var layer = this.layers[i];
                var b = layer.glyph.bbox;
                bbox.addPoint(b.minX, b.minY);
                bbox.addPoint(b.maxX, b.maxY);
            }
            return bbox;
        };
        COLRGlyph.prototype.render = function render(ctx, size) {
            for (var _iterator = this.layers, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _getIterator(_iterator);;) {
                var _ref;
                if (_isArray) {
                    if (_i >= _iterator.length)
                        break;
                    _ref = _iterator[_i++];
                } else {
                    _i = _iterator.next();
                    if (_i.done)
                        break;
                    _ref = _i.value;
                }
                var _ref2 = _ref, glyph = _ref2.glyph, color = _ref2.color;
                ctx.fillColor([
                    color.red,
                    color.green,
                    color.blue
                ], color.alpha / 255 * 100);
                glyph.render(ctx, size);
            }
            return;
        };
        _createClass(COLRGlyph, [{
                key: 'layers',
                get: function get() {
                    var cpal = this._font.CPAL;
                    var colr = this._font.COLR;
                    var low = 0;
                    var high = colr.baseGlyphRecord.length - 1;
                    while (low <= high) {
                        var mid = low + high >> 1;
                        var rec = colr.baseGlyphRecord[mid];
                        if (this.id < rec.gid) {
                            high = mid - 1;
                        } else if (this.id > rec.gid) {
                            low = mid + 1;
                        } else {
                            var baseLayer = rec;
                            break;
                        }
                    }
                    if (baseLayer == null) {
                        var g = this._font._getBaseGlyph(this.id);
                        var color = {
                                red: 0,
                                green: 0,
                                blue: 0,
                                alpha: 255
                            };
                        return [new COLRLayer(g, color)];
                    }
                    var layers = [];
                    for (var i = baseLayer.firstLayerIndex; i < baseLayer.firstLayerIndex + baseLayer.numLayers; i++) {
                        var rec = colr.layerRecords[i];
                        var color = cpal.colorRecords[rec.paletteIndex];
                        var g = this._font._getBaseGlyph(rec.gid);
                        layers.push(new COLRLayer(g, color));
                    }
                    return layers;
                }
            }]);
        return COLRGlyph;
    }(Glyph);
var TUPLES_SHARE_POINT_NUMBERS = 32768;
var TUPLE_COUNT_MASK = 4095;
var EMBEDDED_TUPLE_COORD = 32768;
var INTERMEDIATE_TUPLE = 16384;
var PRIVATE_POINT_NUMBERS = 8192;
var TUPLE_INDEX_MASK = 4095;
var POINTS_ARE_WORDS = 128;
var POINT_RUN_COUNT_MASK = 127;
var DELTAS_ARE_ZERO = 128;
var DELTAS_ARE_WORDS = 64;
var DELTA_RUN_COUNT_MASK = 63;
var GlyphVariationProcessor = function () {
        function GlyphVariationProcessor(font, coords) {
            _classCallCheck(this, GlyphVariationProcessor);
            this.font = font;
            this.normalizedCoords = this.normalizeCoords(coords);
            this.blendVectors = new _Map();
        }
        GlyphVariationProcessor.prototype.normalizeCoords = function normalizeCoords(coords) {
            var normalized = [];
            for (var i = 0; i < this.font.fvar.axis.length; i++) {
                var axis = this.font.fvar.axis[i];
                if (coords[i] < axis.defaultValue) {
                    normalized.push((coords[i] - axis.defaultValue + _Number$EPSILON) / (axis.defaultValue - axis.minValue + _Number$EPSILON));
                } else {
                    normalized.push((coords[i] - axis.defaultValue + _Number$EPSILON) / (axis.maxValue - axis.defaultValue + _Number$EPSILON));
                }
            }
            if (this.font.avar) {
                for (var i = 0; i < this.font.avar.segment.length; i++) {
                    var segment = this.font.avar.segment[i];
                    for (var j = 0; j < segment.correspondence.length; j++) {
                        var pair = segment.correspondence[j];
                        if (j >= 1 && normalized[i] < pair.fromCoord) {
                            var prev = segment.correspondence[j - 1];
                            normalized[i] = ((normalized[i] - prev.fromCoord) * (pair.toCoord - prev.toCoord) + _Number$EPSILON) / (pair.fromCoord - prev.fromCoord + _Number$EPSILON) + prev.toCoord;
                            break;
                        }
                    }
                }
            }
            return normalized;
        };
        GlyphVariationProcessor.prototype.transformPoints = function transformPoints(gid, glyphPoints) {
            if (!this.font.fvar || !this.font.gvar) {
                return;
            }
            var gvar = this.font.gvar;
            if (gid >= gvar.glyphCount) {
                return;
            }
            var offset = gvar.offsets[gid];
            if (offset === gvar.offsets[gid + 1]) {
                return;
            }
            var stream = this.font.stream;
            stream.pos = offset;
            if (stream.pos >= stream.length) {
                return;
            }
            var tupleCount = stream.readUInt16BE();
            var offsetToData = offset + stream.readUInt16BE();
            if (tupleCount & TUPLES_SHARE_POINT_NUMBERS) {
                var here = stream.pos;
                stream.pos = offsetToData;
                var sharedPoints = this.decodePoints();
                offsetToData = stream.pos;
                stream.pos = here;
            }
            var origPoints = glyphPoints.map(function (pt) {
                    return pt.copy();
                });
            tupleCount &= TUPLE_COUNT_MASK;
            for (var i = 0; i < tupleCount; i++) {
                var tupleDataSize = stream.readUInt16BE();
                var tupleIndex = stream.readUInt16BE();
                if (tupleIndex & EMBEDDED_TUPLE_COORD) {
                    var tupleCoords = [];
                    for (var a = 0; a < gvar.axisCount; a++) {
                        tupleCoords.push(stream.readInt16BE() / 16384);
                    }
                } else {
                    if ((tupleIndex & TUPLE_INDEX_MASK) >= gvar.globalCoordCount) {
                        throw new Error('Invalid gvar table');
                    }
                    var tupleCoords = gvar.globalCoords[tupleIndex & TUPLE_INDEX_MASK];
                }
                if (tupleIndex & INTERMEDIATE_TUPLE) {
                    var startCoords = [];
                    for (var _a = 0; _a < gvar.axisCount; _a++) {
                        startCoords.push(stream.readInt16BE() / 16384);
                    }
                    var endCoords = [];
                    for (var _a2 = 0; _a2 < gvar.axisCount; _a2++) {
                        endCoords.push(stream.readInt16BE() / 16384);
                    }
                }
                var factor = this.tupleFactor(tupleIndex, tupleCoords, startCoords, endCoords);
                if (factor === 0) {
                    offsetToData += tupleDataSize;
                    continue;
                }
                var here = stream.pos;
                stream.pos = offsetToData;
                if (tupleIndex & PRIVATE_POINT_NUMBERS) {
                    var points = this.decodePoints();
                } else {
                    var points = sharedPoints;
                }
                var nPoints = points.length === 0 ? glyphPoints.length : points.length;
                var xDeltas = this.decodeDeltas(nPoints);
                var yDeltas = this.decodeDeltas(nPoints);
                if (points.length === 0) {
                    for (var _i = 0; _i < glyphPoints.length; _i++) {
                        var point = glyphPoints[_i];
                        point.x += Math.round(xDeltas[_i] * factor);
                        point.y += Math.round(yDeltas[_i] * factor);
                    }
                } else {
                    var outPoints = origPoints.map(function (pt) {
                            return pt.copy();
                        });
                    var hasDelta = glyphPoints.map(function () {
                            return false;
                        });
                    for (var _i2 = 0; _i2 < points.length; _i2++) {
                        var idx = points[_i2];
                        if (idx < glyphPoints.length) {
                            var _point = outPoints[idx];
                            hasDelta[idx] = true;
                            _point.x += Math.round(xDeltas[_i2] * factor);
                            _point.y += Math.round(yDeltas[_i2] * factor);
                        }
                    }
                    this.interpolateMissingDeltas(outPoints, origPoints, hasDelta);
                    for (var _i3 = 0; _i3 < glyphPoints.length; _i3++) {
                        var deltaX = outPoints[_i3].x - origPoints[_i3].x;
                        var deltaY = outPoints[_i3].y - origPoints[_i3].y;
                        glyphPoints[_i3].x += deltaX;
                        glyphPoints[_i3].y += deltaY;
                    }
                }
                offsetToData += tupleDataSize;
                stream.pos = here;
            }
        };
        GlyphVariationProcessor.prototype.decodePoints = function decodePoints() {
            var stream = this.font.stream;
            var count = stream.readUInt8();
            if (count & POINTS_ARE_WORDS) {
                count = (count & POINT_RUN_COUNT_MASK) << 8 | stream.readUInt8();
            }
            var points = new Uint16Array(count);
            var i = 0;
            var point = 0;
            while (i < count) {
                var run = stream.readUInt8();
                var runCount = (run & POINT_RUN_COUNT_MASK) + 1;
                var fn = run & POINTS_ARE_WORDS ? stream.readUInt16 : stream.readUInt8;
                for (var j = 0; j < runCount && i < count; j++) {
                    point += fn.call(stream);
                    points[i++] = point;
                }
            }
            return points;
        };
        GlyphVariationProcessor.prototype.decodeDeltas = function decodeDeltas(count) {
            var stream = this.font.stream;
            var i = 0;
            var deltas = new Int16Array(count);
            while (i < count) {
                var run = stream.readUInt8();
                var runCount = (run & DELTA_RUN_COUNT_MASK) + 1;
                if (run & DELTAS_ARE_ZERO) {
                    i += runCount;
                } else {
                    var fn = run & DELTAS_ARE_WORDS ? stream.readInt16BE : stream.readInt8;
                    for (var j = 0; j < runCount && i < count; j++) {
                        deltas[i++] = fn.call(stream);
                    }
                }
            }
            return deltas;
        };
        GlyphVariationProcessor.prototype.tupleFactor = function tupleFactor(tupleIndex, tupleCoords, startCoords, endCoords) {
            var normalized = this.normalizedCoords;
            var gvar = this.font.gvar;
            var factor = 1;
            for (var i = 0; i < gvar.axisCount; i++) {
                if (tupleCoords[i] === 0) {
                    continue;
                }
                if (normalized[i] === 0) {
                    return 0;
                }
                if ((tupleIndex & INTERMEDIATE_TUPLE) === 0) {
                    if (normalized[i] < Math.min(0, tupleCoords[i]) || normalized[i] > Math.max(0, tupleCoords[i])) {
                        return 0;
                    }
                    factor = (factor * normalized[i] + _Number$EPSILON) / (tupleCoords[i] + _Number$EPSILON);
                } else {
                    if (normalized[i] < startCoords[i] || normalized[i] > endCoords[i]) {
                        return 0;
                    } else if (normalized[i] < tupleCoords[i]) {
                        factor = factor * (normalized[i] - startCoords[i] + _Number$EPSILON) / (tupleCoords[i] - startCoords[i] + _Number$EPSILON);
                    } else {
                        factor = factor * (endCoords[i] - normalized[i] + _Number$EPSILON) / (endCoords[i] - tupleCoords[i] + _Number$EPSILON);
                    }
                }
            }
            return factor;
        };
        GlyphVariationProcessor.prototype.interpolateMissingDeltas = function interpolateMissingDeltas(points, inPoints, hasDelta) {
            if (points.length === 0) {
                return;
            }
            var point = 0;
            while (point < points.length) {
                var firstPoint = point;
                var endPoint = point;
                var pt = points[endPoint];
                while (!pt.endContour) {
                    pt = points[++endPoint];
                }
                while (point <= endPoint && !hasDelta[point]) {
                    point++;
                }
                if (point > endPoint) {
                    continue;
                }
                var firstDelta = point;
                var curDelta = point;
                point++;
                while (point <= endPoint) {
                    if (hasDelta[point]) {
                        this.deltaInterpolate(curDelta + 1, point - 1, curDelta, point, inPoints, points);
                        curDelta = point;
                    }
                    point++;
                }
                if (curDelta === firstDelta) {
                    this.deltaShift(firstPoint, endPoint, curDelta, inPoints, points);
                } else {
                    this.deltaInterpolate(curDelta + 1, endPoint, curDelta, firstDelta, inPoints, points);
                    if (firstDelta > 0) {
                        this.deltaInterpolate(firstPoint, firstDelta - 1, curDelta, firstDelta, inPoints, points);
                    }
                }
                point = endPoint + 1;
            }
        };
        GlyphVariationProcessor.prototype.deltaInterpolate = function deltaInterpolate(p1, p2, ref1, ref2, inPoints, outPoints) {
            if (p1 > p2) {
                return;
            }
            var iterable = [
                    'x',
                    'y'
                ];
            for (var i = 0; i < iterable.length; i++) {
                var k = iterable[i];
                if (inPoints[ref1][k] > inPoints[ref2][k]) {
                    var p = ref1;
                    ref1 = ref2;
                    ref2 = p;
                }
                var in1 = inPoints[ref1][k];
                var in2 = inPoints[ref2][k];
                var out1 = outPoints[ref1][k];
                var out2 = outPoints[ref2][k];
                if (in1 !== in2 || out1 === out2) {
                    var scale = in1 === in2 ? 0 : (out2 - out1) / (in2 - in1);
                    for (var _p = p1; _p <= p2; _p++) {
                        var out = inPoints[_p][k];
                        if (out <= in1) {
                            out += out1 - in1;
                        } else if (out >= in2) {
                            out += out2 - in2;
                        } else {
                            out = out1 + (out - in1) * scale;
                        }
                        outPoints[_p][k] = out;
                    }
                }
            }
        };
        GlyphVariationProcessor.prototype.deltaShift = function deltaShift(p1, p2, ref, inPoints, outPoints) {
            var deltaX = outPoints[ref].x - inPoints[ref].x;
            var deltaY = outPoints[ref].y - inPoints[ref].y;
            if (deltaX === 0 && deltaY === 0) {
                return;
            }
            for (var p = p1; p <= p2; p++) {
                if (p !== ref) {
                    outPoints[p].x += deltaX;
                    outPoints[p].y += deltaY;
                }
            }
        };
        GlyphVariationProcessor.prototype.getAdvanceAdjustment = function getAdvanceAdjustment(gid, table) {
            var outerIndex = void 0, innerIndex = void 0;
            if (table.advanceWidthMapping) {
                var idx = gid;
                if (idx >= table.advanceWidthMapping.mapCount) {
                    idx = table.advanceWidthMapping.mapCount - 1;
                }
                var entryFormat = table.advanceWidthMapping.entryFormat;
                var _table$advanceWidthMa = table.advanceWidthMapping.mapData[idx];
                outerIndex = _table$advanceWidthMa.outerIndex;
                innerIndex = _table$advanceWidthMa.innerIndex;
            } else {
                outerIndex = 0;
                innerIndex = gid;
            }
            return this.getDelta(table.itemVariationStore, outerIndex, innerIndex);
        };
        GlyphVariationProcessor.prototype.getDelta = function getDelta(itemStore, outerIndex, innerIndex) {
            if (outerIndex >= itemStore.itemVariationData.length) {
                return 0;
            }
            var varData = itemStore.itemVariationData[outerIndex];
            if (innerIndex >= varData.deltaSets.length) {
                return 0;
            }
            var deltaSet = varData.deltaSets[innerIndex];
            var blendVector = this.getBlendVector(itemStore, outerIndex);
            var netAdjustment = 0;
            for (var master = 0; master < varData.regionIndexCount; master++) {
                netAdjustment += deltaSet.deltas[master] * blendVector[master];
            }
            return netAdjustment;
        };
        GlyphVariationProcessor.prototype.getBlendVector = function getBlendVector(itemStore, outerIndex) {
            var varData = itemStore.itemVariationData[outerIndex];
            if (this.blendVectors.has(varData)) {
                return this.blendVectors.get(varData);
            }
            var normalizedCoords = this.normalizedCoords;
            var blendVector = [];
            for (var master = 0; master < varData.regionIndexCount; master++) {
                var scalar = 1;
                var regionIndex = varData.regionIndexes[master];
                var axes = itemStore.variationRegionList.variationRegions[regionIndex];
                for (var j = 0; j < axes.length; j++) {
                    var axis = axes[j];
                    var axisScalar = void 0;
                    if (axis.startCoord > axis.peakCoord || axis.peakCoord > axis.endCoord) {
                        axisScalar = 1;
                    } else if (axis.startCoord < 0 && axis.endCoord > 0 && axis.peakCoord !== 0) {
                        axisScalar = 1;
                    } else if (axis.peakCoord === 0) {
                        axisScalar = 1;
                    } else if (normalizedCoords[j] < axis.startCoord || normalizedCoords[j] > axis.endCoord) {
                        axisScalar = 0;
                    } else {
                        if (normalizedCoords[j] === axis.peakCoord) {
                            axisScalar = 1;
                        } else if (normalizedCoords[j] < axis.peakCoord) {
                            axisScalar = (normalizedCoords[j] - axis.startCoord + _Number$EPSILON) / (axis.peakCoord - axis.startCoord + _Number$EPSILON);
                        } else {
                            axisScalar = (axis.endCoord - normalizedCoords[j] + _Number$EPSILON) / (axis.endCoord - axis.peakCoord + _Number$EPSILON);
                        }
                    }
                    scalar *= axisScalar;
                }
                blendVector[master] = scalar;
            }
            this.blendVectors.set(varData, blendVector);
            return blendVector;
        };
        return GlyphVariationProcessor;
    }();
var Subset = function () {
        function Subset(font) {
            _classCallCheck(this, Subset);
            this.font = font;
            this.glyphs = [];
            this.mapping = {};
            this.includeGlyph(0);
        }
        Subset.prototype.includeGlyph = function includeGlyph(glyph) {
            if ((typeof glyph === 'undefined' ? 'undefined' : _typeof(glyph)) === 'object') {
                glyph = glyph.id;
            }
            if (this.mapping[glyph] == null) {
                this.glyphs.push(glyph);
                this.mapping[glyph] = this.glyphs.length - 1;
            }
            return this.mapping[glyph];
        };
        Subset.prototype.encodeStream = function encodeStream() {
            var _this = this;
            var s = new r.EncodeStream();
            process.nextTick(function () {
                _this.encode(s);
                return s.end();
            });
            return s;
        };
        return Subset;
    }();
var ON_CURVE$1 = 1 << 0;
var X_SHORT_VECTOR$1 = 1 << 1;
var Y_SHORT_VECTOR$1 = 1 << 2;
var REPEAT$1 = 1 << 3;
var SAME_X$1 = 1 << 4;
var SAME_Y$1 = 1 << 5;
var Point$1 = function () {
        function Point() {
            _classCallCheck(this, Point);
        }
        Point.size = function size(val) {
            return val >= 0 && val <= 255 ? 1 : 2;
        };
        Point.encode = function encode(stream, value) {
            if (value >= 0 && value <= 255) {
                stream.writeUInt8(value);
            } else {
                stream.writeInt16BE(value);
            }
        };
        return Point;
    }();
var Glyf = new r.Struct({
        numberOfContours: r.int16,
        xMin: r.int16,
        yMin: r.int16,
        xMax: r.int16,
        yMax: r.int16,
        endPtsOfContours: new r.Array(r.uint16, 'numberOfContours'),
        instructions: new r.Array(r.uint8, r.uint16),
        flags: new r.Array(r.uint8, 0),
        xPoints: new r.Array(Point$1, 0),
        yPoints: new r.Array(Point$1, 0)
    });
var TTFGlyphEncoder = function () {
        function TTFGlyphEncoder() {
            _classCallCheck(this, TTFGlyphEncoder);
        }
        TTFGlyphEncoder.prototype.encodeSimple = function encodeSimple(path) {
            var instructions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
            var endPtsOfContours = [];
            var xPoints = [];
            var yPoints = [];
            var flags = [];
            var same = 0;
            var lastX = 0, lastY = 0, lastFlag = 0;
            var pointCount = 0;
            for (var i = 0; i < path.commands.length; i++) {
                var c = path.commands[i];
                for (var j = 0; j < c.args.length; j += 2) {
                    var x = c.args[j];
                    var y = c.args[j + 1];
                    var flag = 0;
                    if (c.command === 'quadraticCurveTo' && j === 2) {
                        var next = path.commands[i + 1];
                        if (next && next.command === 'quadraticCurveTo') {
                            var midX = (lastX + next.args[0]) / 2;
                            var midY = (lastY + next.args[1]) / 2;
                            if (x === midX && y === midY) {
                                continue;
                            }
                        }
                    }
                    if (!(c.command === 'quadraticCurveTo' && j === 0)) {
                        flag |= ON_CURVE$1;
                    }
                    flag = this._encodePoint(x, lastX, xPoints, flag, X_SHORT_VECTOR$1, SAME_X$1);
                    flag = this._encodePoint(y, lastY, yPoints, flag, Y_SHORT_VECTOR$1, SAME_Y$1);
                    if (flag === lastFlag && same < 255) {
                        flags[flags.length - 1] |= REPEAT$1;
                        same++;
                    } else {
                        if (same > 0) {
                            flags.push(same);
                            same = 0;
                        }
                        flags.push(flag);
                        lastFlag = flag;
                    }
                    lastX = x;
                    lastY = y;
                    pointCount++;
                }
                if (c.command === 'closePath') {
                    endPtsOfContours.push(pointCount - 1);
                }
            }
            if (path.commands.length > 1 && path.commands[path.commands.length - 1].command !== 'closePath') {
                endPtsOfContours.push(pointCount - 1);
            }
            var bbox = path.bbox;
            var glyf = {
                    numberOfContours: endPtsOfContours.length,
                    xMin: bbox.minX,
                    yMin: bbox.minY,
                    xMax: bbox.maxX,
                    yMax: bbox.maxY,
                    endPtsOfContours: endPtsOfContours,
                    instructions: instructions,
                    flags: flags,
                    xPoints: xPoints,
                    yPoints: yPoints
                };
            var size = Glyf.size(glyf);
            var tail = 4 - size % 4;
            var stream = new r.EncodeStream(size + tail);
            Glyf.encode(stream, glyf);
            if (tail !== 0) {
                stream.fill(0, tail);
            }
            return stream.buffer;
        };
        TTFGlyphEncoder.prototype._encodePoint = function _encodePoint(value, last, points, flag, shortFlag, sameFlag) {
            var diff = value - last;
            if (value === last) {
                flag |= sameFlag;
            } else {
                if (-255 <= diff && diff <= 255) {
                    flag |= shortFlag;
                    if (diff < 0) {
                        diff = -diff;
                    } else {
                        flag |= sameFlag;
                    }
                }
                points.push(diff);
            }
            return flag;
        };
        return TTFGlyphEncoder;
    }();
var TTFSubset = function (_Subset) {
        _inherits(TTFSubset, _Subset);
        function TTFSubset(font) {
            _classCallCheck(this, TTFSubset);
            var _this = _possibleConstructorReturn(this, _Subset.call(this, font));
            _this.glyphEncoder = new TTFGlyphEncoder();
            return _this;
        }
        TTFSubset.prototype._addGlyph = function _addGlyph(gid) {
            var glyph = this.font.getGlyph(gid);
            var glyf = glyph._decode();
            var curOffset = this.font.loca.offsets[gid];
            var nextOffset = this.font.loca.offsets[gid + 1];
            var stream = this.font._getTableStream('glyf');
            stream.pos += curOffset;
            var buffer = stream.readBuffer(nextOffset - curOffset);
            if (glyf && glyf.numberOfContours < 0) {
                buffer = new Buffer(buffer);
                for (var _iterator = glyf.components, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _getIterator(_iterator);;) {
                    var _ref;
                    if (_isArray) {
                        if (_i >= _iterator.length)
                            break;
                        _ref = _iterator[_i++];
                    } else {
                        _i = _iterator.next();
                        if (_i.done)
                            break;
                        _ref = _i.value;
                    }
                    var component = _ref;
                    gid = this.includeGlyph(component.glyphID);
                    buffer.writeUInt16BE(gid, component.pos);
                }
            } else if (glyf && this.font._variationProcessor) {
                buffer = this.glyphEncoder.encodeSimple(glyph.path, glyf.instructions);
            }
            this.glyf.push(buffer);
            this.loca.offsets.push(this.offset);
            this.hmtx.metrics.push({
                advance: glyph.advanceWidth,
                bearing: glyph._getMetrics().leftBearing
            });
            this.offset += buffer.length;
            return this.glyf.length - 1;
        };
        TTFSubset.prototype.encode = function encode(stream) {
            this.glyf = [];
            this.offset = 0;
            this.loca = {
                offsets: [],
                version: this.font.loca.version
            };
            this.hmtx = {
                metrics: [],
                bearings: []
            };
            var i = 0;
            while (i < this.glyphs.length) {
                this._addGlyph(this.glyphs[i++]);
            }
            var maxp = cloneDeep(this.font.maxp);
            maxp.numGlyphs = this.glyf.length;
            this.loca.offsets.push(this.offset);
            var head = cloneDeep(this.font.head);
            head.indexToLocFormat = this.loca.version;
            var hhea = cloneDeep(this.font.hhea);
            hhea.numberOfMetrics = this.hmtx.metrics.length;
            Directory.encode(stream, {
                tables: {
                    head: head,
                    hhea: hhea,
                    loca: this.loca,
                    maxp: maxp,
                    'cvt ': this.font['cvt '],
                    prep: this.font.prep,
                    glyf: this.glyf,
                    hmtx: this.hmtx,
                    fpgm: this.font.fpgm
                }
            });
        };
        return TTFSubset;
    }(Subset);
var CFFSubset = function (_Subset) {
        _inherits(CFFSubset, _Subset);
        function CFFSubset(font) {
            _classCallCheck(this, CFFSubset);
            var _this = _possibleConstructorReturn(this, _Subset.call(this, font));
            _this.cff = _this.font['CFF '];
            if (!_this.cff) {
                throw new Error('Not a CFF Font');
            }
            return _this;
        }
        CFFSubset.prototype.subsetCharstrings = function subsetCharstrings() {
            this.charstrings = [];
            var gsubrs = {};
            for (var _iterator = this.glyphs, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _getIterator(_iterator);;) {
                var _ref;
                if (_isArray) {
                    if (_i >= _iterator.length)
                        break;
                    _ref = _iterator[_i++];
                } else {
                    _i = _iterator.next();
                    if (_i.done)
                        break;
                    _ref = _i.value;
                }
                var gid = _ref;
                this.charstrings.push(this.cff.getCharString(gid));
                var glyph = this.font.getGlyph(gid);
                var path = glyph.path;
                for (var subr in glyph._usedGsubrs) {
                    gsubrs[subr] = true;
                }
            }
            this.gsubrs = this.subsetSubrs(this.cff.globalSubrIndex, gsubrs);
        };
        CFFSubset.prototype.subsetSubrs = function subsetSubrs(subrs, used) {
            var res = [];
            for (var i = 0; i < subrs.length; i++) {
                var subr = subrs[i];
                if (used[i]) {
                    this.cff.stream.pos = subr.offset;
                    res.push(this.cff.stream.readBuffer(subr.length));
                } else {
                    res.push(new Buffer([11]));
                }
            }
            return res;
        };
        CFFSubset.prototype.subsetFontdict = function subsetFontdict(topDict) {
            topDict.FDArray = [];
            topDict.FDSelect = {
                version: 0,
                fds: []
            };
            var used_fds = {};
            var used_subrs = [];
            for (var _iterator2 = this.glyphs, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _getIterator(_iterator2);;) {
                var _ref2;
                if (_isArray2) {
                    if (_i2 >= _iterator2.length)
                        break;
                    _ref2 = _iterator2[_i2++];
                } else {
                    _i2 = _iterator2.next();
                    if (_i2.done)
                        break;
                    _ref2 = _i2.value;
                }
                var gid = _ref2;
                var fd = this.cff.fdForGlyph(gid);
                if (fd == null) {
                    continue;
                }
                if (!used_fds[fd]) {
                    topDict.FDArray.push(_Object$assign({}, this.cff.topDict.FDArray[fd]));
                    used_subrs.push({});
                }
                used_fds[fd] = true;
                topDict.FDSelect.fds.push(topDict.FDArray.length - 1);
                var glyph = this.font.getGlyph(gid);
                var path = glyph.path;
                for (var subr in glyph._usedSubrs) {
                    used_subrs[used_subrs.length - 1][subr] = true;
                }
            }
            for (var i = 0; i < topDict.FDArray.length; i++) {
                var dict = topDict.FDArray[i];
                delete dict.FontName;
                if (dict.Private && dict.Private.Subrs) {
                    dict.Private = _Object$assign({}, dict.Private);
                    dict.Private.Subrs = this.subsetSubrs(dict.Private.Subrs, used_subrs[i]);
                }
            }
            return;
        };
        CFFSubset.prototype.createCIDFontdict = function createCIDFontdict(topDict) {
            var used_subrs = {};
            for (var _iterator3 = this.glyphs, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _getIterator(_iterator3);;) {
                var _ref3;
                if (_isArray3) {
                    if (_i3 >= _iterator3.length)
                        break;
                    _ref3 = _iterator3[_i3++];
                } else {
                    _i3 = _iterator3.next();
                    if (_i3.done)
                        break;
                    _ref3 = _i3.value;
                }
                var gid = _ref3;
                var glyph = this.font.getGlyph(gid);
                var path = glyph.path;
                for (var subr in glyph._usedSubrs) {
                    used_subrs[subr] = true;
                }
            }
            var privateDict = _Object$assign({}, this.cff.topDict.Private);
            if (this.cff.topDict.Private && this.cff.topDict.Private.Subrs) {
                privateDict.Subrs = this.subsetSubrs(this.cff.topDict.Private.Subrs, used_subrs);
            }
            topDict.FDArray = [{ Private: privateDict }];
            return topDict.FDSelect = {
                version: 3,
                nRanges: 1,
                ranges: [{
                        first: 0,
                        fd: 0
                    }],
                sentinel: this.charstrings.length
            };
        };
        CFFSubset.prototype.addString = function addString(string) {
            if (!string) {
                return null;
            }
            if (!this.strings) {
                this.strings = [];
            }
            this.strings.push(string);
            return standardStrings.length + this.strings.length - 1;
        };
        CFFSubset.prototype.encode = function encode(stream) {
            this.subsetCharstrings();
            var charset = {
                    version: this.charstrings.length > 255 ? 2 : 1,
                    ranges: [{
                            first: 1,
                            nLeft: this.charstrings.length - 2
                        }]
                };
            var topDict = _Object$assign({}, this.cff.topDict);
            topDict.Private = null;
            topDict.charset = charset;
            topDict.Encoding = null;
            topDict.CharStrings = this.charstrings;
            var _arr = [
                    'version',
                    'Notice',
                    'Copyright',
                    'FullName',
                    'FamilyName',
                    'Weight',
                    'PostScript',
                    'BaseFontName',
                    'FontName'
                ];
            for (var _i4 = 0; _i4 < _arr.length; _i4++) {
                var key = _arr[_i4];
                topDict[key] = this.addString(this.cff.string(topDict[key]));
            }
            topDict.ROS = [
                this.addString('Adobe'),
                this.addString('Identity'),
                0
            ];
            topDict.CIDCount = this.charstrings.length;
            if (this.cff.isCIDFont) {
                this.subsetFontdict(topDict);
            } else {
                this.createCIDFontdict(topDict);
            }
            var top = {
                    version: 1,
                    hdrSize: this.cff.hdrSize,
                    offSize: 4,
                    header: this.cff.header,
                    nameIndex: [this.cff.postscriptName],
                    topDictIndex: [topDict],
                    stringIndex: this.strings,
                    globalSubrIndex: this.gsubrs
                };
            CFFTop.encode(stream, top);
        };
        return CFFSubset;
    }(Subset);
var _class;
function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
    var desc = {};
    Object['ke' + 'ys'](descriptor).forEach(function (key) {
        desc[key] = descriptor[key];
    });
    desc.enumerable = !!desc.enumerable;
    desc.configurable = !!desc.configurable;
    if ('value' in desc || desc.initializer) {
        desc.writable = true;
    }
    desc = decorators.slice().reverse().reduce(function (desc, decorator) {
        return decorator(target, property, desc) || desc;
    }, desc);
    if (context && desc.initializer !== void 0) {
        desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
        desc.initializer = undefined;
    }
    if (desc.initializer === void 0) {
        Object['define' + 'Property'](target, property, desc);
        desc = null;
    }
    return desc;
}
var TTFFont = (_class = function () {
        TTFFont.probe = function probe(buffer) {
            var format = buffer.toString('ascii', 0, 4);
            return format === 'true' || format === 'OTTO' || format === String.fromCharCode(0, 1, 0, 0);
        };
        function TTFFont(stream) {
            var variationCoords = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
            _classCallCheck(this, TTFFont);
            this.defaultLanguage = null;
            this.stream = stream;
            this.variationCoords = variationCoords;
            this._directoryPos = this.stream.pos;
            this._tables = {};
            this._glyphs = {};
            this._decodeDirectory();
            for (var tag in this.directory.tables) {
                var table = this.directory.tables[tag];
                if (tables[tag] && table.length > 0) {
                    _Object$defineProperty(this, tag, { get: this._getTable.bind(this, table) });
                }
            }
        }
        TTFFont.prototype.setDefaultLanguage = function setDefaultLanguage() {
            var lang = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
            this.defaultLanguage = lang;
        };
        TTFFont.prototype._getTable = function _getTable(table) {
            if (!(table.tag in this._tables)) {
                try {
                    this._tables[table.tag] = this._decodeTable(table);
                } catch (e) {
                    if (fontkit.logErrors) {
                        console.error('Error decoding table ' + table.tag);
                        console.error(e.stack);
                    }
                }
            }
            return this._tables[table.tag];
        };
        TTFFont.prototype._getTableStream = function _getTableStream(tag) {
            var table = this.directory.tables[tag];
            if (table) {
                this.stream.pos = table.offset;
                return this.stream;
            }
            return null;
        };
        TTFFont.prototype._decodeDirectory = function _decodeDirectory() {
            return this.directory = Directory.decode(this.stream, { _startOffset: 0 });
        };
        TTFFont.prototype._decodeTable = function _decodeTable(table) {
            var pos = this.stream.pos;
            var stream = this._getTableStream(table.tag);
            var result = tables[table.tag].decode(stream, this, table.length);
            this.stream.pos = pos;
            return result;
        };
        TTFFont.prototype.getName = function getName(key) {
            var lang = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.defaultLanguage || fontkit.defaultLanguage;
            var record = this.name && this.name.records[key];
            if (record) {
                return record[lang] || record[this.defaultLanguage] || record[fontkit.defaultLanguage] || record['en'] || record[_Object$keys(record)[0]] || null;
            }
            return null;
        };
        TTFFont.prototype.hasGlyphForCodePoint = function hasGlyphForCodePoint(codePoint) {
            return !!this._cmapProcessor.lookup(codePoint);
        };
        TTFFont.prototype.glyphForCodePoint = function glyphForCodePoint(codePoint) {
            return this.getGlyph(this._cmapProcessor.lookup(codePoint), [codePoint]);
        };
        TTFFont.prototype.glyphsForString = function glyphsForString(string) {
            var glyphs = [];
            var len = string.length;
            var idx = 0;
            var last = -1;
            var state = -1;
            while (idx <= len) {
                var code = 0;
                var nextState = 0;
                if (idx < len) {
                    code = string.charCodeAt(idx++);
                    if (55296 <= code && code <= 56319 && idx < len) {
                        var next = string.charCodeAt(idx);
                        if (56320 <= next && next <= 57343) {
                            idx++;
                            code = ((code & 1023) << 10) + (next & 1023) + 65536;
                        }
                    }
                    nextState = 65024 <= code && code <= 65039 || 917760 <= code && code <= 917999 ? 1 : 0;
                } else {
                    idx++;
                }
                if (state === 0 && nextState === 1) {
                    glyphs.push(this.getGlyph(this._cmapProcessor.lookup(last, code), [
                        last,
                        code
                    ]));
                } else if (state === 0 && nextState === 0) {
                    glyphs.push(this.glyphForCodePoint(last));
                }
                last = code;
                state = nextState;
            }
            return glyphs;
        };
        TTFFont.prototype.layout = function layout(string, userFeatures, script, language, direction) {
            return this._layoutEngine.layout(string, userFeatures, script, language, direction);
        };
        TTFFont.prototype.stringsForGlyph = function stringsForGlyph(gid) {
            return this._layoutEngine.stringsForGlyph(gid);
        };
        TTFFont.prototype.getAvailableFeatures = function getAvailableFeatures(script, language) {
            return this._layoutEngine.getAvailableFeatures(script, language);
        };
        TTFFont.prototype._getBaseGlyph = function _getBaseGlyph(glyph) {
            var characters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
            if (!this._glyphs[glyph]) {
                if (this.directory.tables.glyf) {
                    this._glyphs[glyph] = new TTFGlyph(glyph, characters, this);
                } else if (this.directory.tables['CFF '] || this.directory.tables.CFF2) {
                    this._glyphs[glyph] = new CFFGlyph(glyph, characters, this);
                }
            }
            return this._glyphs[glyph] || null;
        };
        TTFFont.prototype.getGlyph = function getGlyph(glyph) {
            var characters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
            if (!this._glyphs[glyph]) {
                if (this.directory.tables.sbix) {
                    this._glyphs[glyph] = new SBIXGlyph(glyph, characters, this);
                } else if (this.directory.tables.COLR && this.directory.tables.CPAL) {
                    this._glyphs[glyph] = new COLRGlyph(glyph, characters, this);
                } else {
                    this._getBaseGlyph(glyph, characters);
                }
            }
            return this._glyphs[glyph] || null;
        };
        TTFFont.prototype.createSubset = function createSubset() {
            if (this.directory.tables['CFF ']) {
                return new CFFSubset(this);
            }
            return new TTFSubset(this);
        };
        TTFFont.prototype.getVariation = function getVariation(settings) {
            if (!(this.directory.tables.fvar && (this.directory.tables.gvar && this.directory.tables.glyf || this.directory.tables.CFF2))) {
                throw new Error('Variations require a font with the fvar, gvar and glyf, or CFF2 tables.');
            }
            if (typeof settings === 'string') {
                settings = this.namedVariations[settings];
            }
            if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) !== 'object') {
                throw new Error('Variation settings must be either a variation name or settings object.');
            }
            var coords = this.fvar.axis.map(function (axis, i) {
                    var axisTag = axis.axisTag.trim();
                    if (axisTag in settings) {
                        return Math.max(axis.minValue, Math.min(axis.maxValue, settings[axisTag]));
                    } else {
                        return axis.defaultValue;
                    }
                });
            var stream = new r.DecodeStream(this.stream.buffer);
            stream.pos = this._directoryPos;
            var font = new TTFFont(stream, coords);
            font._tables = this._tables;
            return font;
        };
        TTFFont.prototype.getFont = function getFont(name) {
            return this.getVariation(name);
        };
        _createClass(TTFFont, [
            {
                key: 'postscriptName',
                get: function get() {
                    return this.getName('postscriptName');
                }
            },
            {
                key: 'fullName',
                get: function get() {
                    return this.getName('fullName');
                }
            },
            {
                key: 'familyName',
                get: function get() {
                    return this.getName('fontFamily');
                }
            },
            {
                key: 'subfamilyName',
                get: function get() {
                    return this.getName('fontSubfamily');
                }
            },
            {
                key: 'copyright',
                get: function get() {
                    return this.getName('copyright');
                }
            },
            {
                key: 'version',
                get: function get() {
                    return this.getName('version');
                }
            },
            {
                key: 'ascent',
                get: function get() {
                    return this.hhea.ascent;
                }
            },
            {
                key: 'descent',
                get: function get() {
                    return this.hhea.descent;
                }
            },
            {
                key: 'lineGap',
                get: function get() {
                    return this.hhea.lineGap;
                }
            },
            {
                key: 'underlinePosition',
                get: function get() {
                    return this.post.underlinePosition;
                }
            },
            {
                key: 'underlineThickness',
                get: function get() {
                    return this.post.underlineThickness;
                }
            },
            {
                key: 'italicAngle',
                get: function get() {
                    return this.post.italicAngle;
                }
            },
            {
                key: 'capHeight',
                get: function get() {
                    var os2 = this['OS/2'];
                    return os2 ? os2.capHeight : this.ascent;
                }
            },
            {
                key: 'xHeight',
                get: function get() {
                    var os2 = this['OS/2'];
                    return os2 ? os2.xHeight : 0;
                }
            },
            {
                key: 'numGlyphs',
                get: function get() {
                    return this.maxp.numGlyphs;
                }
            },
            {
                key: 'unitsPerEm',
                get: function get() {
                    return this.head.unitsPerEm;
                }
            },
            {
                key: 'bbox',
                get: function get() {
                    return _Object$freeze(new BBox(this.head.xMin, this.head.yMin, this.head.xMax, this.head.yMax));
                }
            },
            {
                key: '_cmapProcessor',
                get: function get() {
                    return new CmapProcessor(this.cmap);
                }
            },
            {
                key: 'characterSet',
                get: function get() {
                    return this._cmapProcessor.getCharacterSet();
                }
            },
            {
                key: '_layoutEngine',
                get: function get() {
                    return new LayoutEngine(this);
                }
            },
            {
                key: 'availableFeatures',
                get: function get() {
                    return this._layoutEngine.getAvailableFeatures();
                }
            },
            {
                key: 'variationAxes',
                get: function get() {
                    var res = {};
                    if (!this.fvar) {
                        return res;
                    }
                    for (var _iterator = this.fvar.axis, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _getIterator(_iterator);;) {
                        var _ref;
                        if (_isArray) {
                            if (_i >= _iterator.length)
                                break;
                            _ref = _iterator[_i++];
                        } else {
                            _i = _iterator.next();
                            if (_i.done)
                                break;
                            _ref = _i.value;
                        }
                        var axis = _ref;
                        res[axis.axisTag.trim()] = {
                            name: axis.name.en,
                            min: axis.minValue,
                            default: axis.defaultValue,
                            max: axis.maxValue
                        };
                    }
                    return res;
                }
            },
            {
                key: 'namedVariations',
                get: function get() {
                    var res = {};
                    if (!this.fvar) {
                        return res;
                    }
                    for (var _iterator2 = this.fvar.instance, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _getIterator(_iterator2);;) {
                        var _ref2;
                        if (_isArray2) {
                            if (_i2 >= _iterator2.length)
                                break;
                            _ref2 = _iterator2[_i2++];
                        } else {
                            _i2 = _iterator2.next();
                            if (_i2.done)
                                break;
                            _ref2 = _i2.value;
                        }
                        var instance = _ref2;
                        var settings = {};
                        for (var i = 0; i < this.fvar.axis.length; i++) {
                            var axis = this.fvar.axis[i];
                            settings[axis.axisTag.trim()] = instance.coord[i];
                        }
                        res[instance.name.en] = settings;
                    }
                    return res;
                }
            },
            {
                key: '_variationProcessor',
                get: function get() {
                    if (!this.fvar) {
                        return null;
                    }
                    var variationCoords = this.variationCoords;
                    if (!variationCoords && !this.CFF2) {
                        return null;
                    }
                    if (!variationCoords) {
                        variationCoords = this.fvar.axis.map(function (axis) {
                            return axis.defaultValue;
                        });
                    }
                    return new GlyphVariationProcessor(this, variationCoords);
                }
            }
        ]);
        return TTFFont;
    }(), (_applyDecoratedDescriptor(_class.prototype, 'bbox', [cache], _Object$getOwnPropertyDescriptor(_class.prototype, 'bbox'), _class.prototype), _applyDecoratedDescriptor(_class.prototype, '_cmapProcessor', [cache], _Object$getOwnPropertyDescriptor(_class.prototype, '_cmapProcessor'), _class.prototype), _applyDecoratedDescriptor(_class.prototype, 'characterSet', [cache], _Object$getOwnPropertyDescriptor(_class.prototype, 'characterSet'), _class.prototype), _applyDecoratedDescriptor(_class.prototype, '_layoutEngine', [cache], _Object$getOwnPropertyDescriptor(_class.prototype, '_layoutEngine'), _class.prototype), _applyDecoratedDescriptor(_class.prototype, 'variationAxes', [cache], _Object$getOwnPropertyDescriptor(_class.prototype, 'variationAxes'), _class.prototype), _applyDecoratedDescriptor(_class.prototype, 'namedVariations', [cache], _Object$getOwnPropertyDescriptor(_class.prototype, 'namedVariations'), _class.prototype), _applyDecoratedDescriptor(_class.prototype, '_variationProcessor', [cache], _Object$getOwnPropertyDescriptor(_class.prototype, '_variationProcessor'), _class.prototype)), _class);
var WOFFDirectoryEntry = new r.Struct({
        tag: new r.String(4),
        offset: new r.Pointer(r.uint32, 'void', { type: 'global' }),
        compLength: r.uint32,
        length: r.uint32,
        origChecksum: r.uint32
    });
var WOFFDirectory = new r.Struct({
        tag: new r.String(4),
        flavor: r.uint32,
        length: r.uint32,
        numTables: r.uint16,
        reserved: new r.Reserved(r.uint16),
        totalSfntSize: r.uint32,
        majorVersion: r.uint16,
        minorVersion: r.uint16,
        metaOffset: r.uint32,
        metaLength: r.uint32,
        metaOrigLength: r.uint32,
        privOffset: r.uint32,
        privLength: r.uint32,
        tables: new r.Array(WOFFDirectoryEntry, 'numTables')
    });
WOFFDirectory.process = function () {
    var tables = {};
    for (var _iterator = this.tables, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _getIterator(_iterator);;) {
        var _ref;
        if (_isArray) {
            if (_i >= _iterator.length)
                break;
            _ref = _iterator[_i++];
        } else {
            _i = _iterator.next();
            if (_i.done)
                break;
            _ref = _i.value;
        }
        var table = _ref;
        tables[table.tag] = table;
    }
    this.tables = tables;
};
var WOFFFont = function (_TTFFont) {
        _inherits(WOFFFont, _TTFFont);
        function WOFFFont() {
            _classCallCheck(this, WOFFFont);
            return _possibleConstructorReturn(this, _TTFFont.apply(this, arguments));
        }
        WOFFFont.probe = function probe(buffer) {
            return buffer.toString('ascii', 0, 4) === 'wOFF';
        };
        WOFFFont.prototype._decodeDirectory = function _decodeDirectory() {
            this.directory = WOFFDirectory.decode(this.stream, { _startOffset: 0 });
        };
        WOFFFont.prototype._getTableStream = function _getTableStream(tag) {
            var table = this.directory.tables[tag];
            if (table) {
                this.stream.pos = table.offset;
                if (table.compLength < table.length) {
                    this.stream.pos += 2;
                    var outBuffer = new Buffer(table.length);
                    var buf = inflate(this.stream.readBuffer(table.compLength - 2), outBuffer);
                    return new r.DecodeStream(buf);
                } else {
                    return this.stream;
                }
            }
            return null;
        };
        return WOFFFont;
    }(TTFFont);
var WOFF2Glyph = function (_TTFGlyph) {
        _inherits(WOFF2Glyph, _TTFGlyph);
        function WOFF2Glyph() {
            _classCallCheck(this, WOFF2Glyph);
            return _possibleConstructorReturn(this, _TTFGlyph.apply(this, arguments));
        }
        WOFF2Glyph.prototype._decode = function _decode() {
            return this._font._transformedGlyphs[this.id];
        };
        WOFF2Glyph.prototype._getCBox = function _getCBox() {
            return this.path.bbox;
        };
        return WOFF2Glyph;
    }(TTFGlyph);
var Base128 = {
        decode: function decode(stream) {
            var result = 0;
            var iterable = [
                    0,
                    1,
                    2,
                    3,
                    4
                ];
            for (var j = 0; j < iterable.length; j++) {
                var i = iterable[j];
                var code = stream.readUInt8();
                if (result & 3758096384) {
                    throw new Error('Overflow');
                }
                result = result << 7 | code & 127;
                if ((code & 128) === 0) {
                    return result;
                }
            }
            throw new Error('Bad base 128 number');
        }
    };
var knownTags = [
        'cmap',
        'head',
        'hhea',
        'hmtx',
        'maxp',
        'name',
        'OS/2',
        'post',
        'cvt ',
        'fpgm',
        'glyf',
        'loca',
        'prep',
        'CFF ',
        'VORG',
        'EBDT',
        'EBLC',
        'gasp',
        'hdmx',
        'kern',
        'LTSH',
        'PCLT',
        'VDMX',
        'vhea',
        'vmtx',
        'BASE',
        'GDEF',
        'GPOS',
        'GSUB',
        'EBSC',
        'JSTF',
        'MATH',
        'CBDT',
        'CBLC',
        'COLR',
        'CPAL',
        'SVG ',
        'sbix',
        'acnt',
        'avar',
        'bdat',
        'bloc',
        'bsln',
        'cvar',
        'fdsc',
        'feat',
        'fmtx',
        'fvar',
        'gvar',
        'hsty',
        'just',
        'lcar',
        'mort',
        'morx',
        'opbd',
        'prop',
        'trak',
        'Zapf',
        'Silf',
        'Glat',
        'Gloc',
        'Feat',
        'Sill'
    ];
var WOFF2DirectoryEntry = new r.Struct({
        flags: r.uint8,
        customTag: new r.Optional(new r.String(4), function (t) {
            return (t.flags & 63) === 63;
        }),
        tag: function tag(t) {
            return t.customTag || knownTags[t.flags & 63];
        },
        length: Base128,
        transformVersion: function transformVersion(t) {
            return t.flags >>> 6 & 3;
        },
        transformed: function transformed(t) {
            return t.tag === 'glyf' || t.tag === 'loca' ? t.transformVersion === 0 : t.transformVersion !== 0;
        },
        transformLength: new r.Optional(Base128, function (t) {
            return t.transformed;
        })
    });
var WOFF2Directory = new r.Struct({
        tag: new r.String(4),
        flavor: r.uint32,
        length: r.uint32,
        numTables: r.uint16,
        reserved: new r.Reserved(r.uint16),
        totalSfntSize: r.uint32,
        totalCompressedSize: r.uint32,
        majorVersion: r.uint16,
        minorVersion: r.uint16,
        metaOffset: r.uint32,
        metaLength: r.uint32,
        metaOrigLength: r.uint32,
        privOffset: r.uint32,
        privLength: r.uint32,
        tables: new r.Array(WOFF2DirectoryEntry, 'numTables')
    });
WOFF2Directory.process = function () {
    var tables = {};
    for (var i = 0; i < this.tables.length; i++) {
        var table = this.tables[i];
        tables[table.tag] = table;
    }
    return this.tables = tables;
};
var WOFF2Font = function (_TTFFont) {
        _inherits(WOFF2Font, _TTFFont);
        function WOFF2Font() {
            _classCallCheck(this, WOFF2Font);
            return _possibleConstructorReturn(this, _TTFFont.apply(this, arguments));
        }
        WOFF2Font.probe = function probe(buffer) {
            return buffer.toString('ascii', 0, 4) === 'wOF2';
        };
        WOFF2Font.prototype._decodeDirectory = function _decodeDirectory() {
            this.directory = WOFF2Directory.decode(this.stream);
            this._dataPos = this.stream.pos;
        };
        WOFF2Font.prototype._decompress = function _decompress() {
            if (!this._decompressed) {
                this.stream.pos = this._dataPos;
                var buffer = this.stream.readBuffer(this.directory.totalCompressedSize);
                var decompressedSize = 0;
                for (var tag in this.directory.tables) {
                    var entry = this.directory.tables[tag];
                    entry.offset = decompressedSize;
                    decompressedSize += entry.transformLength != null ? entry.transformLength : entry.length;
                }
                var decompressed = brotli(buffer, decompressedSize);
                if (!decompressed) {
                    throw new Error('Error decoding compressed data in WOFF2');
                }
                this.stream = new r.DecodeStream(new Buffer(decompressed));
                this._decompressed = true;
            }
        };
        WOFF2Font.prototype._decodeTable = function _decodeTable(table) {
            this._decompress();
            return _TTFFont.prototype._decodeTable.call(this, table);
        };
        WOFF2Font.prototype._getBaseGlyph = function _getBaseGlyph(glyph) {
            var characters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
            if (!this._glyphs[glyph]) {
                if (this.directory.tables.glyf && this.directory.tables.glyf.transformed) {
                    if (!this._transformedGlyphs) {
                        this._transformGlyfTable();
                    }
                    return this._glyphs[glyph] = new WOFF2Glyph(glyph, characters, this);
                } else {
                    return _TTFFont.prototype._getBaseGlyph.call(this, glyph, characters);
                }
            }
        };
        WOFF2Font.prototype._transformGlyfTable = function _transformGlyfTable() {
            this._decompress();
            this.stream.pos = this.directory.tables.glyf.offset;
            var table = GlyfTable.decode(this.stream);
            var glyphs = [];
            for (var index = 0; index < table.numGlyphs; index++) {
                var glyph = {};
                var nContours = table.nContours.readInt16BE();
                glyph.numberOfContours = nContours;
                if (nContours > 0) {
                    var nPoints = [];
                    var totalPoints = 0;
                    for (var i = 0; i < nContours; i++) {
                        var _r = read255UInt16(table.nPoints);
                        totalPoints += _r;
                        nPoints.push(totalPoints);
                    }
                    glyph.points = decodeTriplet(table.flags, table.glyphs, totalPoints);
                    for (var _i = 0; _i < nContours; _i++) {
                        glyph.points[nPoints[_i] - 1].endContour = true;
                    }
                    var instructionSize = read255UInt16(table.glyphs);
                } else if (nContours < 0) {
                    var haveInstructions = TTFGlyph.prototype._decodeComposite.call({ _font: this }, glyph, table.composites);
                    if (haveInstructions) {
                        var instructionSize = read255UInt16(table.glyphs);
                    }
                }
                glyphs.push(glyph);
            }
            this._transformedGlyphs = glyphs;
        };
        return WOFF2Font;
    }(TTFFont);
var Substream = function () {
        function Substream(length) {
            _classCallCheck(this, Substream);
            this.length = length;
            this._buf = new r.Buffer(length);
        }
        Substream.prototype.decode = function decode(stream, parent) {
            return new r.DecodeStream(this._buf.decode(stream, parent));
        };
        return Substream;
    }();
var GlyfTable = new r.Struct({
        version: r.uint32,
        numGlyphs: r.uint16,
        indexFormat: r.uint16,
        nContourStreamSize: r.uint32,
        nPointsStreamSize: r.uint32,
        flagStreamSize: r.uint32,
        glyphStreamSize: r.uint32,
        compositeStreamSize: r.uint32,
        bboxStreamSize: r.uint32,
        instructionStreamSize: r.uint32,
        nContours: new Substream('nContourStreamSize'),
        nPoints: new Substream('nPointsStreamSize'),
        flags: new Substream('flagStreamSize'),
        glyphs: new Substream('glyphStreamSize'),
        composites: new Substream('compositeStreamSize'),
        bboxes: new Substream('bboxStreamSize'),
        instructions: new Substream('instructionStreamSize')
    });
var WORD_CODE = 253;
var ONE_MORE_BYTE_CODE2 = 254;
var ONE_MORE_BYTE_CODE1 = 255;
var LOWEST_U_CODE = 253;
function read255UInt16(stream) {
    var code = stream.readUInt8();
    if (code === WORD_CODE) {
        return stream.readUInt16BE();
    }
    if (code === ONE_MORE_BYTE_CODE1) {
        return stream.readUInt8() + LOWEST_U_CODE;
    }
    if (code === ONE_MORE_BYTE_CODE2) {
        return stream.readUInt8() + LOWEST_U_CODE * 2;
    }
    return code;
}
function withSign(flag, baseval) {
    return flag & 1 ? baseval : -baseval;
}
function decodeTriplet(flags, glyphs, nPoints) {
    var y = void 0;
    var x = y = 0;
    var res = [];
    for (var i = 0; i < nPoints; i++) {
        var dx = 0, dy = 0;
        var flag = flags.readUInt8();
        var onCurve = !(flag >> 7);
        flag &= 127;
        if (flag < 10) {
            dx = 0;
            dy = withSign(flag, ((flag & 14) << 7) + glyphs.readUInt8());
        } else if (flag < 20) {
            dx = withSign(flag, ((flag - 10 & 14) << 7) + glyphs.readUInt8());
            dy = 0;
        } else if (flag < 84) {
            var b0 = flag - 20;
            var b1 = glyphs.readUInt8();
            dx = withSign(flag, 1 + (b0 & 48) + (b1 >> 4));
            dy = withSign(flag >> 1, 1 + ((b0 & 12) << 2) + (b1 & 15));
        } else if (flag < 120) {
            var b0 = flag - 84;
            dx = withSign(flag, 1 + (b0 / 12 << 8) + glyphs.readUInt8());
            dy = withSign(flag >> 1, 1 + (b0 % 12 >> 2 << 8) + glyphs.readUInt8());
        } else if (flag < 124) {
            var b1 = glyphs.readUInt8();
            var b2 = glyphs.readUInt8();
            dx = withSign(flag, (b1 << 4) + (b2 >> 4));
            dy = withSign(flag >> 1, ((b2 & 15) << 8) + glyphs.readUInt8());
        } else {
            dx = withSign(flag, glyphs.readUInt16BE());
            dy = withSign(flag >> 1, glyphs.readUInt16BE());
        }
        x += dx;
        y += dy;
        res.push(new Point(onCurve, false, x, y));
    }
    return res;
}
var TTCHeader = new r.VersionedStruct(r.uint32, {
        65536: {
            numFonts: r.uint32,
            offsets: new r.Array(r.uint32, 'numFonts')
        },
        131072: {
            numFonts: r.uint32,
            offsets: new r.Array(r.uint32, 'numFonts'),
            dsigTag: r.uint32,
            dsigLength: r.uint32,
            dsigOffset: r.uint32
        }
    });
var TrueTypeCollection = function () {
        TrueTypeCollection.probe = function probe(buffer) {
            return buffer.toString('ascii', 0, 4) === 'ttcf';
        };
        function TrueTypeCollection(stream) {
            _classCallCheck(this, TrueTypeCollection);
            this.stream = stream;
            if (stream.readString(4) !== 'ttcf') {
                throw new Error('Not a TrueType collection');
            }
            this.header = TTCHeader.decode(stream);
        }
        TrueTypeCollection.prototype.getFont = function getFont(name) {
            for (var _iterator = this.header.offsets, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _getIterator(_iterator);;) {
                var _ref;
                if (_isArray) {
                    if (_i >= _iterator.length)
                        break;
                    _ref = _iterator[_i++];
                } else {
                    _i = _iterator.next();
                    if (_i.done)
                        break;
                    _ref = _i.value;
                }
                var offset = _ref;
                var stream = new r.DecodeStream(this.stream.buffer);
                stream.pos = offset;
                var font = new TTFFont(stream);
                if (font.postscriptName === name) {
                    return font;
                }
            }
            return null;
        };
        _createClass(TrueTypeCollection, [{
                key: 'fonts',
                get: function get() {
                    var fonts = [];
                    for (var _iterator2 = this.header.offsets, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _getIterator(_iterator2);;) {
                        var _ref2;
                        if (_isArray2) {
                            if (_i2 >= _iterator2.length)
                                break;
                            _ref2 = _iterator2[_i2++];
                        } else {
                            _i2 = _iterator2.next();
                            if (_i2.done)
                                break;
                            _ref2 = _i2.value;
                        }
                        var offset = _ref2;
                        var stream = new r.DecodeStream(this.stream.buffer);
                        stream.pos = offset;
                        fonts.push(new TTFFont(stream));
                    }
                    return fonts;
                }
            }]);
        return TrueTypeCollection;
    }();
var DFontName = new r.String(r.uint8);
var DFontData = new r.Struct({
        len: r.uint32,
        buf: new r.Buffer('len')
    });
var Ref = new r.Struct({
        id: r.uint16,
        nameOffset: r.int16,
        attr: r.uint8,
        dataOffset: r.uint24,
        handle: r.uint32
    });
var Type = new r.Struct({
        name: new r.String(4),
        maxTypeIndex: r.uint16,
        refList: new r.Pointer(r.uint16, new r.Array(Ref, function (t) {
            return t.maxTypeIndex + 1;
        }), { type: 'parent' })
    });
var TypeList = new r.Struct({
        length: r.uint16,
        types: new r.Array(Type, function (t) {
            return t.length + 1;
        })
    });
var DFontMap = new r.Struct({
        reserved: new r.Reserved(r.uint8, 24),
        typeList: new r.Pointer(r.uint16, TypeList),
        nameListOffset: new r.Pointer(r.uint16, 'void')
    });
var DFontHeader = new r.Struct({
        dataOffset: r.uint32,
        map: new r.Pointer(r.uint32, DFontMap),
        dataLength: r.uint32,
        mapLength: r.uint32
    });
var DFont = function () {
        DFont.probe = function probe(buffer) {
            var stream = new r.DecodeStream(buffer);
            try {
                var header = DFontHeader.decode(stream);
            } catch (e) {
                return false;
            }
            for (var _iterator = header.map.typeList.types, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _getIterator(_iterator);;) {
                var _ref;
                if (_isArray) {
                    if (_i >= _iterator.length)
                        break;
                    _ref = _iterator[_i++];
                } else {
                    _i = _iterator.next();
                    if (_i.done)
                        break;
                    _ref = _i.value;
                }
                var type = _ref;
                if (type.name === 'sfnt') {
                    return true;
                }
            }
            return false;
        };
        function DFont(stream) {
            _classCallCheck(this, DFont);
            this.stream = stream;
            this.header = DFontHeader.decode(this.stream);
            for (var _iterator2 = this.header.map.typeList.types, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _getIterator(_iterator2);;) {
                var _ref2;
                if (_isArray2) {
                    if (_i2 >= _iterator2.length)
                        break;
                    _ref2 = _iterator2[_i2++];
                } else {
                    _i2 = _iterator2.next();
                    if (_i2.done)
                        break;
                    _ref2 = _i2.value;
                }
                var type = _ref2;
                for (var _iterator3 = type.refList, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _getIterator(_iterator3);;) {
                    var _ref3;
                    if (_isArray3) {
                        if (_i3 >= _iterator3.length)
                            break;
                        _ref3 = _iterator3[_i3++];
                    } else {
                        _i3 = _iterator3.next();
                        if (_i3.done)
                            break;
                        _ref3 = _i3.value;
                    }
                    var ref = _ref3;
                    if (ref.nameOffset >= 0) {
                        this.stream.pos = ref.nameOffset + this.header.map.nameListOffset;
                        ref.name = DFontName.decode(this.stream);
                    } else {
                        ref.name = null;
                    }
                }
                if (type.name === 'sfnt') {
                    this.sfnt = type;
                }
            }
        }
        DFont.prototype.getFont = function getFont(name) {
            if (!this.sfnt) {
                return null;
            }
            for (var _iterator4 = this.sfnt.refList, _isArray4 = Array.isArray(_iterator4), _i4 = 0, _iterator4 = _isArray4 ? _iterator4 : _getIterator(_iterator4);;) {
                var _ref4;
                if (_isArray4) {
                    if (_i4 >= _iterator4.length)
                        break;
                    _ref4 = _iterator4[_i4++];
                } else {
                    _i4 = _iterator4.next();
                    if (_i4.done)
                        break;
                    _ref4 = _i4.value;
                }
                var ref = _ref4;
                var pos = this.header.dataOffset + ref.dataOffset + 4;
                var stream = new r.DecodeStream(this.stream.buffer.slice(pos));
                var font = new TTFFont(stream);
                if (font.postscriptName === name) {
                    return font;
                }
            }
            return null;
        };
        _createClass(DFont, [{
                key: 'fonts',
                get: function get() {
                    var fonts = [];
                    for (var _iterator5 = this.sfnt.refList, _isArray5 = Array.isArray(_iterator5), _i5 = 0, _iterator5 = _isArray5 ? _iterator5 : _getIterator(_iterator5);;) {
                        var _ref5;
                        if (_isArray5) {
                            if (_i5 >= _iterator5.length)
                                break;
                            _ref5 = _iterator5[_i5++];
                        } else {
                            _i5 = _iterator5.next();
                            if (_i5.done)
                                break;
                            _ref5 = _i5.value;
                        }
                        var ref = _ref5;
                        var pos = this.header.dataOffset + ref.dataOffset + 4;
                        var stream = new r.DecodeStream(this.stream.buffer.slice(pos));
                        fonts.push(new TTFFont(stream));
                    }
                    return fonts;
                }
            }]);
        return DFont;
    }();
fontkit.registerFormat(TTFFont);
fontkit.registerFormat(WOFFFont);
fontkit.registerFormat(WOFF2Font);
fontkit.registerFormat(TrueTypeCollection);
fontkit.registerFormat(DFont);
module.exports = fontkit;
}).call(this,require('_process'),require("buffer").Buffer)
},{"_process":181,"babel-runtime/core-js/array/from":1,"babel-runtime/core-js/get-iterator":2,"babel-runtime/core-js/map":3,"babel-runtime/core-js/number/epsilon":4,"babel-runtime/core-js/object/assign":5,"babel-runtime/core-js/object/define-properties":7,"babel-runtime/core-js/object/define-property":8,"babel-runtime/core-js/object/freeze":9,"babel-runtime/core-js/object/get-own-property-descriptor":10,"babel-runtime/core-js/object/keys":11,"babel-runtime/core-js/set":13,"babel-runtime/core-js/string/from-code-point":14,"babel-runtime/helpers/classCallCheck":17,"babel-runtime/helpers/createClass":18,"babel-runtime/helpers/inherits":19,"babel-runtime/helpers/possibleConstructorReturn":20,"babel-runtime/helpers/typeof":21,"brotli/decompress":34,"buffer":37,"clone":38,"deep-equal":161,"dfa":163,"restructure":201,"restructure/src/utils":217,"tiny-inflate":220,"unicode-properties":222,"unicode-trie":223}],166:[function(require,module,exports){
'use strict';

/* eslint no-invalid-this: 1 */

var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';
var slice = Array.prototype.slice;
var toStr = Object.prototype.toString;
var funcType = '[object Function]';

module.exports = function bind(that) {
    var target = this;
    if (typeof target !== 'function' || toStr.call(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
    }
    var args = slice.call(arguments, 1);

    var bound;
    var binder = function () {
        if (this instanceof bound) {
            var result = target.apply(
                this,
                args.concat(slice.call(arguments))
            );
            if (Object(result) === result) {
                return result;
            }
            return this;
        } else {
            return target.apply(
                that,
                args.concat(slice.call(arguments))
            );
        }
    };

    var boundLength = Math.max(0, target.length - args.length);
    var boundArgs = [];
    for (var i = 0; i < boundLength; i++) {
        boundArgs.push('$' + i);
    }

    bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this,arguments); }')(binder);

    if (target.prototype) {
        var Empty = function Empty() {};
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
    }

    return bound;
};

},{}],167:[function(require,module,exports){
'use strict';

var implementation = require('./implementation');

module.exports = Function.prototype.bind || implementation;

},{"./implementation":166}],168:[function(require,module,exports){
'use strict';

var bind = require('function-bind');

module.exports = bind.call(Function.call, Object.prototype.hasOwnProperty);

},{"function-bind":167}],169:[function(require,module,exports){
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],170:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      })
    }
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      var TempCtor = function () {}
      TempCtor.prototype = superCtor.prototype
      ctor.prototype = new TempCtor()
      ctor.prototype.constructor = ctor
    }
  }
}

},{}],171:[function(require,module,exports){
'use strict';

var hasToStringTag = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';
var toStr = Object.prototype.toString;

var isStandardArguments = function isArguments(value) {
	if (hasToStringTag && value && typeof value === 'object' && Symbol.toStringTag in value) {
		return false;
	}
	return toStr.call(value) === '[object Arguments]';
};

var isLegacyArguments = function isArguments(value) {
	if (isStandardArguments(value)) {
		return true;
	}
	return value !== null &&
		typeof value === 'object' &&
		typeof value.length === 'number' &&
		value.length >= 0 &&
		toStr.call(value) !== '[object Array]' &&
		toStr.call(value.callee) === '[object Function]';
};

var supportsStandardArguments = (function () {
	return isStandardArguments(arguments);
}());

isStandardArguments.isLegacyArguments = isLegacyArguments; // for tests

module.exports = supportsStandardArguments ? isStandardArguments : isLegacyArguments;

},{}],172:[function(require,module,exports){
/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */

// The _isBuffer check is for Safari 5-7 support, because it's missing
// Object.prototype.constructor. Remove this eventually
module.exports = function (obj) {
  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer)
}

function isBuffer (obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
}

// For Node v0.10 support. Remove this eventually.
function isSlowBuffer (obj) {
  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0))
}

},{}],173:[function(require,module,exports){
'use strict';

var getDay = Date.prototype.getDay;
var tryDateObject = function tryDateObject(value) {
	try {
		getDay.call(value);
		return true;
	} catch (e) {
		return false;
	}
};

var toStr = Object.prototype.toString;
var dateClass = '[object Date]';
var hasToStringTag = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';

module.exports = function isDateObject(value) {
	if (typeof value !== 'object' || value === null) { return false; }
	return hasToStringTag ? tryDateObject(value) : toStr.call(value) === dateClass;
};

},{}],174:[function(require,module,exports){
'use strict';

var has = require('has');
var regexExec = RegExp.prototype.exec;
var gOPD = Object.getOwnPropertyDescriptor;

var tryRegexExecCall = function tryRegexExec(value) {
	try {
		var lastIndex = value.lastIndex;
		value.lastIndex = 0;

		regexExec.call(value);
		return true;
	} catch (e) {
		return false;
	} finally {
		value.lastIndex = lastIndex;
	}
};
var toStr = Object.prototype.toString;
var regexClass = '[object RegExp]';
var hasToStringTag = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';

module.exports = function isRegex(value) {
	if (!value || typeof value !== 'object') {
		return false;
	}
	if (!hasToStringTag) {
		return toStr.call(value) === regexClass;
	}

	var descriptor = gOPD(value, 'lastIndex');
	var hasLastIndexDataProperty = descriptor && has(descriptor, 'value');
	if (!hasLastIndexDataProperty) {
		return false;
	}

	return tryRegexExecCall(value);
};

},{"has":168}],175:[function(require,module,exports){
var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

},{}],176:[function(require,module,exports){
"use strict";

/* https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.is */

var NumberIsNaN = function (value) {
	return value !== value;
};

module.exports = function is(a, b) {
	if (a === 0 && b === 0) {
		return 1 / a === 1 / b;
	} else if (a === b) {
		return true;
	} else if (NumberIsNaN(a) && NumberIsNaN(b)) {
		return true;
	}
	return false;
};


},{}],177:[function(require,module,exports){
'use strict';

var keysShim;
if (!Object.keys) {
	// modified from https://github.com/es-shims/es5-shim
	var has = Object.prototype.hasOwnProperty;
	var toStr = Object.prototype.toString;
	var isArgs = require('./isArguments'); // eslint-disable-line global-require
	var isEnumerable = Object.prototype.propertyIsEnumerable;
	var hasDontEnumBug = !isEnumerable.call({ toString: null }, 'toString');
	var hasProtoEnumBug = isEnumerable.call(function () {}, 'prototype');
	var dontEnums = [
		'toString',
		'toLocaleString',
		'valueOf',
		'hasOwnProperty',
		'isPrototypeOf',
		'propertyIsEnumerable',
		'constructor'
	];
	var equalsConstructorPrototype = function (o) {
		var ctor = o.constructor;
		return ctor && ctor.prototype === o;
	};
	var excludedKeys = {
		$applicationCache: true,
		$console: true,
		$external: true,
		$frame: true,
		$frameElement: true,
		$frames: true,
		$innerHeight: true,
		$innerWidth: true,
		$onmozfullscreenchange: true,
		$onmozfullscreenerror: true,
		$outerHeight: true,
		$outerWidth: true,
		$pageXOffset: true,
		$pageYOffset: true,
		$parent: true,
		$scrollLeft: true,
		$scrollTop: true,
		$scrollX: true,
		$scrollY: true,
		$self: true,
		$webkitIndexedDB: true,
		$webkitStorageInfo: true,
		$window: true
	};
	var hasAutomationEqualityBug = (function () {
		/* global window */
		if (typeof window === 'undefined') { return false; }
		for (var k in window) {
			try {
				if (!excludedKeys['$' + k] && has.call(window, k) && window[k] !== null && typeof window[k] === 'object') {
					try {
						equalsConstructorPrototype(window[k]);
					} catch (e) {
						return true;
					}
				}
			} catch (e) {
				return true;
			}
		}
		return false;
	}());
	var equalsConstructorPrototypeIfNotBuggy = function (o) {
		/* global window */
		if (typeof window === 'undefined' || !hasAutomationEqualityBug) {
			return equalsConstructorPrototype(o);
		}
		try {
			return equalsConstructorPrototype(o);
		} catch (e) {
			return false;
		}
	};

	keysShim = function keys(object) {
		var isObject = object !== null && typeof object === 'object';
		var isFunction = toStr.call(object) === '[object Function]';
		var isArguments = isArgs(object);
		var isString = isObject && toStr.call(object) === '[object String]';
		var theKeys = [];

		if (!isObject && !isFunction && !isArguments) {
			throw new TypeError('Object.keys called on a non-object');
		}

		var skipProto = hasProtoEnumBug && isFunction;
		if (isString && object.length > 0 && !has.call(object, 0)) {
			for (var i = 0; i < object.length; ++i) {
				theKeys.push(String(i));
			}
		}

		if (isArguments && object.length > 0) {
			for (var j = 0; j < object.length; ++j) {
				theKeys.push(String(j));
			}
		} else {
			for (var name in object) {
				if (!(skipProto && name === 'prototype') && has.call(object, name)) {
					theKeys.push(String(name));
				}
			}
		}

		if (hasDontEnumBug) {
			var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);

			for (var k = 0; k < dontEnums.length; ++k) {
				if (!(skipConstructor && dontEnums[k] === 'constructor') && has.call(object, dontEnums[k])) {
					theKeys.push(dontEnums[k]);
				}
			}
		}
		return theKeys;
	};
}
module.exports = keysShim;

},{"./isArguments":179}],178:[function(require,module,exports){
'use strict';

var slice = Array.prototype.slice;
var isArgs = require('./isArguments');

var origKeys = Object.keys;
var keysShim = origKeys ? function keys(o) { return origKeys(o); } : require('./implementation');

var originalKeys = Object.keys;

keysShim.shim = function shimObjectKeys() {
	if (Object.keys) {
		var keysWorksWithArguments = (function () {
			// Safari 5.0 bug
			var args = Object.keys(arguments);
			return args && args.length === arguments.length;
		}(1, 2));
		if (!keysWorksWithArguments) {
			Object.keys = function keys(object) { // eslint-disable-line func-name-matching
				if (isArgs(object)) {
					return originalKeys(slice.call(object));
				}
				return originalKeys(object);
			};
		}
	} else {
		Object.keys = keysShim;
	}
	return Object.keys || keysShim;
};

module.exports = keysShim;

},{"./implementation":177,"./isArguments":179}],179:[function(require,module,exports){
'use strict';

var toStr = Object.prototype.toString;

module.exports = function isArguments(value) {
	var str = toStr.call(value);
	var isArgs = str === '[object Arguments]';
	if (!isArgs) {
		isArgs = str !== '[object Array]' &&
			value !== null &&
			typeof value === 'object' &&
			typeof value.length === 'number' &&
			value.length >= 0 &&
			toStr.call(value.callee) === '[object Function]';
	}
	return isArgs;
};

},{}],180:[function(require,module,exports){
(function (process){
'use strict';

if (typeof process === 'undefined' ||
    !process.version ||
    process.version.indexOf('v0.') === 0 ||
    process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {
  module.exports = { nextTick: nextTick };
} else {
  module.exports = process
}

function nextTick(fn, arg1, arg2, arg3) {
  if (typeof fn !== 'function') {
    throw new TypeError('"callback" argument must be a function');
  }
  var len = arguments.length;
  var args, i;
  switch (len) {
  case 0:
  case 1:
    return process.nextTick(fn);
  case 2:
    return process.nextTick(function afterTickOne() {
      fn.call(null, arg1);
    });
  case 3:
    return process.nextTick(function afterTickTwo() {
      fn.call(null, arg1, arg2);
    });
  case 4:
    return process.nextTick(function afterTickThree() {
      fn.call(null, arg1, arg2, arg3);
    });
  default:
    args = new Array(len - 1);
    i = 0;
    while (i < args.length) {
      args[i++] = arguments[i];
    }
    return process.nextTick(function afterTick() {
      fn.apply(null, args);
    });
  }
}


}).call(this,require('_process'))
},{"_process":181}],181:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],182:[function(require,module,exports){
module.exports = require('./lib/_stream_duplex.js');

},{"./lib/_stream_duplex.js":183}],183:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.

'use strict';

/*<replacement>*/

var pna = require('process-nextick-args');
/*</replacement>*/

/*<replacement>*/
var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) {
    keys.push(key);
  }return keys;
};
/*</replacement>*/

module.exports = Duplex;

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

var Readable = require('./_stream_readable');
var Writable = require('./_stream_writable');

util.inherits(Duplex, Readable);

{
  // avoid scope creep, the keys array can then be collected
  var keys = objectKeys(Writable.prototype);
  for (var v = 0; v < keys.length; v++) {
    var method = keys[v];
    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
  }
}

function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);

  Readable.call(this, options);
  Writable.call(this, options);

  if (options && options.readable === false) this.readable = false;

  if (options && options.writable === false) this.writable = false;

  this.allowHalfOpen = true;
  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;

  this.once('end', onend);
}

Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._writableState.highWaterMark;
  }
});

// the no-half-open enforcer
function onend() {
  // if we allow half-open state, or if the writable side ended,
  // then we're ok.
  if (this.allowHalfOpen || this._writableState.ended) return;

  // no more data can be written.
  // But allow more writes to happen in this tick.
  pna.nextTick(onEndNT, this);
}

function onEndNT(self) {
  self.end();
}

Object.defineProperty(Duplex.prototype, 'destroyed', {
  get: function () {
    if (this._readableState === undefined || this._writableState === undefined) {
      return false;
    }
    return this._readableState.destroyed && this._writableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (this._readableState === undefined || this._writableState === undefined) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
    this._writableState.destroyed = value;
  }
});

Duplex.prototype._destroy = function (err, cb) {
  this.push(null);
  this.end();

  pna.nextTick(cb, err);
};
},{"./_stream_readable":185,"./_stream_writable":187,"core-util-is":160,"inherits":170,"process-nextick-args":180}],184:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.

'use strict';

module.exports = PassThrough;

var Transform = require('./_stream_transform');

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

util.inherits(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough)) return new PassThrough(options);

  Transform.call(this, options);
}

PassThrough.prototype._transform = function (chunk, encoding, cb) {
  cb(null, chunk);
};
},{"./_stream_transform":186,"core-util-is":160,"inherits":170}],185:[function(require,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

/*<replacement>*/

var pna = require('process-nextick-args');
/*</replacement>*/

module.exports = Readable;

/*<replacement>*/
var isArray = require('isarray');
/*</replacement>*/

/*<replacement>*/
var Duplex;
/*</replacement>*/

Readable.ReadableState = ReadableState;

/*<replacement>*/
var EE = require('events').EventEmitter;

var EElistenerCount = function (emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

/*<replacement>*/
var Stream = require('./internal/streams/stream');
/*</replacement>*/

/*<replacement>*/

var Buffer = require('safe-buffer').Buffer;
var OurUint8Array = global.Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

/*</replacement>*/

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

/*<replacement>*/
var debugUtil = require('util');
var debug = void 0;
if (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.debuglog('stream');
} else {
  debug = function () {};
}
/*</replacement>*/

var BufferList = require('./internal/streams/BufferList');
var destroyImpl = require('./internal/streams/destroy');
var StringDecoder;

util.inherits(Readable, Stream);

var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];

function prependListener(emitter, event, fn) {
  // Sadly this is not cacheable as some libraries bundle their own
  // event emitter implementation with them.
  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn);

  // This is a hack to make sure that our error handler is attached before any
  // userland ones.  NEVER DO THIS. This is here only because this code needs
  // to continue to work with older versions of Node.js that do not include
  // the prependListener() method. The goal is to eventually remove this hack.
  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
}

function ReadableState(options, stream) {
  Duplex = Duplex || require('./_stream_duplex');

  options = options || {};

  // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.
  var isDuplex = stream instanceof Duplex;

  // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away
  this.objectMode = !!options.objectMode;

  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;

  // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"
  var hwm = options.highWaterMark;
  var readableHwm = options.readableHighWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;

  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (readableHwm || readableHwm === 0)) this.highWaterMark = readableHwm;else this.highWaterMark = defaultHwm;

  // cast to ints.
  this.highWaterMark = Math.floor(this.highWaterMark);

  // A linked list is used to store data chunks instead of an array because the
  // linked list can remove elements from the beginning faster than
  // array.shift()
  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;

  // a flag to be able to tell if the event 'readable'/'data' is emitted
  // immediately, or on a later tick.  We set this to true at first, because
  // any actions that shouldn't happen until "later" should generally also
  // not happen before the first read call.
  this.sync = true;

  // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;

  // has it been destroyed
  this.destroyed = false;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // the number of writers that are awaiting a drain event in .pipe()s
  this.awaitDrain = 0;

  // if true, a maybeReadMore has been scheduled
  this.readingMore = false;

  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  Duplex = Duplex || require('./_stream_duplex');

  if (!(this instanceof Readable)) return new Readable(options);

  this._readableState = new ReadableState(options, this);

  // legacy
  this.readable = true;

  if (options) {
    if (typeof options.read === 'function') this._read = options.read;

    if (typeof options.destroy === 'function') this._destroy = options.destroy;
  }

  Stream.call(this);
}

Object.defineProperty(Readable.prototype, 'destroyed', {
  get: function () {
    if (this._readableState === undefined) {
      return false;
    }
    return this._readableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._readableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
  }
});

Readable.prototype.destroy = destroyImpl.destroy;
Readable.prototype._undestroy = destroyImpl.undestroy;
Readable.prototype._destroy = function (err, cb) {
  this.push(null);
  cb(err);
};

// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;
  var skipChunkCheck;

  if (!state.objectMode) {
    if (typeof chunk === 'string') {
      encoding = encoding || state.defaultEncoding;
      if (encoding !== state.encoding) {
        chunk = Buffer.from(chunk, encoding);
        encoding = '';
      }
      skipChunkCheck = true;
    }
  } else {
    skipChunkCheck = true;
  }

  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
};

// Unshift should *always* be something directly out of read()
Readable.prototype.unshift = function (chunk) {
  return readableAddChunk(this, chunk, null, true, false);
};

function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
  var state = stream._readableState;
  if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else {
    var er;
    if (!skipChunkCheck) er = chunkInvalid(state, chunk);
    if (er) {
      stream.emit('error', er);
    } else if (state.objectMode || chunk && chunk.length > 0) {
      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
        chunk = _uint8ArrayToBuffer(chunk);
      }

      if (addToFront) {
        if (state.endEmitted) stream.emit('error', new Error('stream.unshift() after end event'));else addChunk(stream, state, chunk, true);
      } else if (state.ended) {
        stream.emit('error', new Error('stream.push() after EOF'));
      } else {
        state.reading = false;
        if (state.decoder && !encoding) {
          chunk = state.decoder.write(chunk);
          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
        } else {
          addChunk(stream, state, chunk, false);
        }
      }
    } else if (!addToFront) {
      state.reading = false;
    }
  }

  return needMoreData(state);
}

function addChunk(stream, state, chunk, addToFront) {
  if (state.flowing && state.length === 0 && !state.sync) {
    stream.emit('data', chunk);
    stream.read(0);
  } else {
    // update the buffer info.
    state.length += state.objectMode ? 1 : chunk.length;
    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);

    if (state.needReadable) emitReadable(stream);
  }
  maybeReadMore(stream, state);
}

function chunkInvalid(state, chunk) {
  var er;
  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  return er;
}

// if it's past the high water mark, we can push in some more.
// Also, if we have no data yet, we can stand some
// more bytes.  This is to work around cases where hwm=0,
// such as the repl.  Also, if the push() triggered a
// readable event, and the user called read(largeNumber) such that
// needReadable was set, then we ought to push more, so that another
// 'readable' event will be triggered.
function needMoreData(state) {
  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
}

Readable.prototype.isPaused = function () {
  return this._readableState.flowing === false;
};

// backwards compatibility.
Readable.prototype.setEncoding = function (enc) {
  if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
  this._readableState.decoder = new StringDecoder(enc);
  this._readableState.encoding = enc;
  return this;
};

// Don't raise the hwm > 8MB
var MAX_HWM = 0x800000;
function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2 to prevent increasing hwm excessively in
    // tiny amounts
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }
  return n;
}

// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended) return 0;
  if (state.objectMode) return 1;
  if (n !== n) {
    // Only flow one buffer at a time
    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
  }
  // If we're asking for more than the current hwm, then raise the hwm.
  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length) return n;
  // Don't have enough
  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }
  return state.length;
}

// you can override either this method, or the async _read(n) below.
Readable.prototype.read = function (n) {
  debug('read', n);
  n = parseInt(n, 10);
  var state = this._readableState;
  var nOrig = n;

  if (n !== 0) state.emittedReadable = false;

  // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.
  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state);

  // if we've ended, and we're now clear, then finish it up.
  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  }

  // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.

  // if we need a readable event, then we need to do some reading.
  var doRead = state.needReadable;
  debug('need readable', doRead);

  // if we currently have less than the highWaterMark, then also read some
  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  }

  // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.
  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  } else if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true;
    // if the length is currently zero, then we *need* a readable event.
    if (state.length === 0) state.needReadable = true;
    // call internal read method
    this._read(state.highWaterMark);
    state.sync = false;
    // If _read pushed data synchronously, then `reading` will be false,
    // and we need to re-evaluate how much data we can return to the user.
    if (!state.reading) n = howMuchToRead(nOrig, state);
  }

  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;

  if (ret === null) {
    state.needReadable = true;
    n = 0;
  } else {
    state.length -= n;
  }

  if (state.length === 0) {
    // If we have nothing in the buffer, then we want to know
    // as soon as we *do* get something into the buffer.
    if (!state.ended) state.needReadable = true;

    // If we tried to read() past the EOF, then emit end on the next tick.
    if (nOrig !== n && state.ended) endReadable(this);
  }

  if (ret !== null) this.emit('data', ret);

  return ret;
};

function onEofChunk(stream, state) {
  if (state.ended) return;
  if (state.decoder) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;

  // emit 'readable' now to make sure it gets picked up.
  emitReadable(stream);
}

// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;
  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    if (state.sync) pna.nextTick(emitReadable_, stream);else emitReadable_(stream);
  }
}

function emitReadable_(stream) {
  debug('emit readable');
  stream.emit('readable');
  flow(stream);
}

// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    pna.nextTick(maybeReadMore_, stream, state);
  }
}

function maybeReadMore_(stream, state) {
  var len = state.length;
  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length)
      // didn't get any data, stop spinning.
      break;else len = state.length;
  }
  state.readingMore = false;
}

// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function (n) {
  this.emit('error', new Error('_read() is not implemented'));
};

Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;
    case 1:
      state.pipes = [state.pipes, dest];
      break;
    default:
      state.pipes.push(dest);
      break;
  }
  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);

  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;

  var endFn = doEnd ? onend : unpipe;
  if (state.endEmitted) pna.nextTick(endFn);else src.once('end', endFn);

  dest.on('unpipe', onunpipe);
  function onunpipe(readable, unpipeInfo) {
    debug('onunpipe');
    if (readable === src) {
      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
        unpipeInfo.hasUnpiped = true;
        cleanup();
      }
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  }

  // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.
  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);

  var cleanedUp = false;
  function cleanup() {
    debug('cleanup');
    // cleanup event handlers once the pipe is broken
    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', unpipe);
    src.removeListener('data', ondata);

    cleanedUp = true;

    // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.
    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }

  // If the user pushes more data while we're writing to dest then we'll end up
  // in ondata again. However, we only want to increase awaitDrain once because
  // dest will only emit one 'drain' event for the multiple writes.
  // => Introduce a guard on increasing awaitDrain.
  var increasedAwaitDrain = false;
  src.on('data', ondata);
  function ondata(chunk) {
    debug('ondata');
    increasedAwaitDrain = false;
    var ret = dest.write(chunk);
    if (false === ret && !increasedAwaitDrain) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      // => Check whether `dest` is still a piping destination.
      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
        debug('false write response, pause', src._readableState.awaitDrain);
        src._readableState.awaitDrain++;
        increasedAwaitDrain = true;
      }
      src.pause();
    }
  }

  // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.
  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);
  }

  // Make sure our error handler is attached before userland ones.
  prependListener(dest, 'error', onerror);

  // Both close and finish should trigger unpipe, but only once.
  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }
  dest.once('close', onclose);
  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }
  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  }

  // tell the dest that it's being piped to
  dest.emit('pipe', src);

  // start the flow if it hasn't been started already.
  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function () {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;
    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}

Readable.prototype.unpipe = function (dest) {
  var state = this._readableState;
  var unpipeInfo = { hasUnpiped: false };

  // if we're not piping anywhere, then do nothing.
  if (state.pipesCount === 0) return this;

  // just one destination.  most common case.
  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;

    if (!dest) dest = state.pipes;

    // got a match.
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this, unpipeInfo);
    return this;
  }

  // slow case. multiple pipe destinations.

  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var i = 0; i < len; i++) {
      dests[i].emit('unpipe', this, unpipeInfo);
    }return this;
  }

  // try to find the right one.
  var index = indexOf(state.pipes, dest);
  if (index === -1) return this;

  state.pipes.splice(index, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];

  dest.emit('unpipe', this, unpipeInfo);

  return this;
};

// set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on = function (ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);

  if (ev === 'data') {
    // Start flowing on next tick if stream isn't explicitly paused
    if (this._readableState.flowing !== false) this.resume();
  } else if (ev === 'readable') {
    var state = this._readableState;
    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.emittedReadable = false;
      if (!state.reading) {
        pna.nextTick(nReadingNextTick, this);
      } else if (state.length) {
        emitReadable(this);
      }
    }
  }

  return res;
};
Readable.prototype.addListener = Readable.prototype.on;

function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
}

// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function () {
  var state = this._readableState;
  if (!state.flowing) {
    debug('resume');
    state.flowing = true;
    resume(this, state);
  }
  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    pna.nextTick(resume_, stream, state);
  }
}

function resume_(stream, state) {
  if (!state.reading) {
    debug('resume read 0');
    stream.read(0);
  }

  state.resumeScheduled = false;
  state.awaitDrain = 0;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}

Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);
  if (false !== this._readableState.flowing) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }
  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);
  while (state.flowing && stream.read() !== null) {}
}

// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function (stream) {
  var _this = this;

  var state = this._readableState;
  var paused = false;

  stream.on('end', function () {
    debug('wrapped end');
    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) _this.push(chunk);
    }

    _this.push(null);
  });

  stream.on('data', function (chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk);

    // don't skip over falsy values in objectMode
    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

    var ret = _this.push(chunk);
    if (!ret) {
      paused = true;
      stream.pause();
    }
  });

  // proxy all the other methods.
  // important when wrapping filters and duplexes.
  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function (method) {
        return function () {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  }

  // proxy certain important events.
  for (var n = 0; n < kProxyEvents.length; n++) {
    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
  }

  // when we try to consume some more bytes, simply unpause the
  // underlying stream.
  this._read = function (n) {
    debug('wrapped _read', n);
    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return this;
};

Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._readableState.highWaterMark;
  }
});

// exposed for testing purposes only.
Readable._fromList = fromList;

// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromList(n, state) {
  // nothing buffered
  if (state.length === 0) return null;

  var ret;
  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
    // read it all, truncate the list
    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    // read part of list
    ret = fromListPartial(n, state.buffer, state.decoder);
  }

  return ret;
}

// Extracts only enough buffered data to satisfy the amount requested.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromListPartial(n, list, hasStrings) {
  var ret;
  if (n < list.head.data.length) {
    // slice is the same for buffers and strings
    ret = list.head.data.slice(0, n);
    list.head.data = list.head.data.slice(n);
  } else if (n === list.head.data.length) {
    // first chunk is a perfect match
    ret = list.shift();
  } else {
    // result spans more than one buffer
    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
  }
  return ret;
}

// Copies a specified amount of characters from the list of buffered data
// chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBufferString(n, list) {
  var p = list.head;
  var c = 1;
  var ret = p.data;
  n -= ret.length;
  while (p = p.next) {
    var str = p.data;
    var nb = n > str.length ? str.length : n;
    if (nb === str.length) ret += str;else ret += str.slice(0, n);
    n -= nb;
    if (n === 0) {
      if (nb === str.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = str.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

// Copies a specified amount of bytes from the list of buffered data chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBuffer(n, list) {
  var ret = Buffer.allocUnsafe(n);
  var p = list.head;
  var c = 1;
  p.data.copy(ret);
  n -= p.data.length;
  while (p = p.next) {
    var buf = p.data;
    var nb = n > buf.length ? buf.length : n;
    buf.copy(ret, ret.length - n, 0, nb);
    n -= nb;
    if (n === 0) {
      if (nb === buf.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = buf.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;

  // If we get here before consuming all the bytes, then that is a
  // bug in node.  Should never happen.
  if (state.length > 0) throw new Error('"endReadable()" called on non-empty stream');

  if (!state.endEmitted) {
    state.ended = true;
    pna.nextTick(endReadableNT, state, stream);
  }
}

function endReadableNT(state, stream) {
  // Check that we didn't get one last unshift.
  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');
  }
}

function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }
  return -1;
}
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./_stream_duplex":183,"./internal/streams/BufferList":188,"./internal/streams/destroy":189,"./internal/streams/stream":190,"_process":181,"core-util-is":160,"events":164,"inherits":170,"isarray":175,"process-nextick-args":180,"safe-buffer":191,"string_decoder/":192,"util":35}],186:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.

'use strict';

module.exports = Transform;

var Duplex = require('./_stream_duplex');

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

util.inherits(Transform, Duplex);

function afterTransform(er, data) {
  var ts = this._transformState;
  ts.transforming = false;

  var cb = ts.writecb;

  if (!cb) {
    return this.emit('error', new Error('write callback called multiple times'));
  }

  ts.writechunk = null;
  ts.writecb = null;

  if (data != null) // single equals check for both `null` and `undefined`
    this.push(data);

  cb(er);

  var rs = this._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    this._read(rs.highWaterMark);
  }
}

function Transform(options) {
  if (!(this instanceof Transform)) return new Transform(options);

  Duplex.call(this, options);

  this._transformState = {
    afterTransform: afterTransform.bind(this),
    needTransform: false,
    transforming: false,
    writecb: null,
    writechunk: null,
    writeencoding: null
  };

  // start out asking for a readable event once data is transformed.
  this._readableState.needReadable = true;

  // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false;

  if (options) {
    if (typeof options.transform === 'function') this._transform = options.transform;

    if (typeof options.flush === 'function') this._flush = options.flush;
  }

  // When the writable side finishes, then flush out anything remaining.
  this.on('prefinish', prefinish);
}

function prefinish() {
  var _this = this;

  if (typeof this._flush === 'function') {
    this._flush(function (er, data) {
      done(_this, er, data);
    });
  } else {
    done(this, null, null);
  }
}

Transform.prototype.push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
};

// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform.prototype._transform = function (chunk, encoding, cb) {
  throw new Error('_transform() is not implemented');
};

Transform.prototype._write = function (chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
};

// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform.prototype._read = function (n) {
  var ts = this._transformState;

  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};

Transform.prototype._destroy = function (err, cb) {
  var _this2 = this;

  Duplex.prototype._destroy.call(this, err, function (err2) {
    cb(err2);
    _this2.emit('close');
  });
};

function done(stream, er, data) {
  if (er) return stream.emit('error', er);

  if (data != null) // single equals check for both `null` and `undefined`
    stream.push(data);

  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided
  if (stream._writableState.length) throw new Error('Calling transform done when ws.length != 0');

  if (stream._transformState.transforming) throw new Error('Calling transform done when still transforming');

  return stream.push(null);
}
},{"./_stream_duplex":183,"core-util-is":160,"inherits":170}],187:[function(require,module,exports){
(function (process,global,setImmediate){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.

'use strict';

/*<replacement>*/

var pna = require('process-nextick-args');
/*</replacement>*/

module.exports = Writable;

/* <replacement> */
function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
}

// It seems a linked list but it is not
// there will be only 2 of these for each stream
function CorkedRequest(state) {
  var _this = this;

  this.next = null;
  this.entry = null;
  this.finish = function () {
    onCorkedFinish(_this, state);
  };
}
/* </replacement> */

/*<replacement>*/
var asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;
/*</replacement>*/

/*<replacement>*/
var Duplex;
/*</replacement>*/

Writable.WritableState = WritableState;

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

/*<replacement>*/
var internalUtil = {
  deprecate: require('util-deprecate')
};
/*</replacement>*/

/*<replacement>*/
var Stream = require('./internal/streams/stream');
/*</replacement>*/

/*<replacement>*/

var Buffer = require('safe-buffer').Buffer;
var OurUint8Array = global.Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

/*</replacement>*/

var destroyImpl = require('./internal/streams/destroy');

util.inherits(Writable, Stream);

function nop() {}

function WritableState(options, stream) {
  Duplex = Duplex || require('./_stream_duplex');

  options = options || {};

  // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.
  var isDuplex = stream instanceof Duplex;

  // object stream flag to indicate whether or not this stream
  // contains buffers or objects.
  this.objectMode = !!options.objectMode;

  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;

  // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()
  var hwm = options.highWaterMark;
  var writableHwm = options.writableHighWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;

  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (writableHwm || writableHwm === 0)) this.highWaterMark = writableHwm;else this.highWaterMark = defaultHwm;

  // cast to ints.
  this.highWaterMark = Math.floor(this.highWaterMark);

  // if _final has been called
  this.finalCalled = false;

  // drain event flag.
  this.needDrain = false;
  // at the start of calling end()
  this.ending = false;
  // when end() has been called, and returned
  this.ended = false;
  // when 'finish' is emitted
  this.finished = false;

  // has it been destroyed
  this.destroyed = false;

  // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.
  this.length = 0;

  // a flag to see when we're in the middle of a write.
  this.writing = false;

  // when true all writes will be buffered until .uncork() call
  this.corked = 0;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.
  this.bufferProcessing = false;

  // the callback that's passed to _write(chunk,cb)
  this.onwrite = function (er) {
    onwrite(stream, er);
  };

  // the callback that the user supplies to write(chunk,encoding,cb)
  this.writecb = null;

  // the amount that is being written when _write is called.
  this.writelen = 0;

  this.bufferedRequest = null;
  this.lastBufferedRequest = null;

  // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted
  this.pendingcb = 0;

  // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams
  this.prefinished = false;

  // True if the error was already emitted and should not be thrown again
  this.errorEmitted = false;

  // count buffered requests
  this.bufferedRequestCount = 0;

  // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two
  this.corkedRequestsFree = new CorkedRequest(this);
}

WritableState.prototype.getBuffer = function getBuffer() {
  var current = this.bufferedRequest;
  var out = [];
  while (current) {
    out.push(current);
    current = current.next;
  }
  return out;
};

(function () {
  try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: internalUtil.deprecate(function () {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
    });
  } catch (_) {}
})();

// Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.
var realHasInstance;
if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
  realHasInstance = Function.prototype[Symbol.hasInstance];
  Object.defineProperty(Writable, Symbol.hasInstance, {
    value: function (object) {
      if (realHasInstance.call(this, object)) return true;
      if (this !== Writable) return false;

      return object && object._writableState instanceof WritableState;
    }
  });
} else {
  realHasInstance = function (object) {
    return object instanceof this;
  };
}

function Writable(options) {
  Duplex = Duplex || require('./_stream_duplex');

  // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.

  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.
  if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
    return new Writable(options);
  }

  this._writableState = new WritableState(options, this);

  // legacy.
  this.writable = true;

  if (options) {
    if (typeof options.write === 'function') this._write = options.write;

    if (typeof options.writev === 'function') this._writev = options.writev;

    if (typeof options.destroy === 'function') this._destroy = options.destroy;

    if (typeof options.final === 'function') this._final = options.final;
  }

  Stream.call(this);
}

// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function () {
  this.emit('error', new Error('Cannot pipe, not readable'));
};

function writeAfterEnd(stream, cb) {
  var er = new Error('write after end');
  // TODO: defer error events consistently everywhere, not just the cb
  stream.emit('error', er);
  pna.nextTick(cb, er);
}

// Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.
function validChunk(stream, state, chunk, cb) {
  var valid = true;
  var er = false;

  if (chunk === null) {
    er = new TypeError('May not write null values to stream');
  } else if (typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  if (er) {
    stream.emit('error', er);
    pna.nextTick(cb, er);
    valid = false;
  }
  return valid;
}

Writable.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;
  var isBuf = !state.objectMode && _isUint8Array(chunk);

  if (isBuf && !Buffer.isBuffer(chunk)) {
    chunk = _uint8ArrayToBuffer(chunk);
  }

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;

  if (typeof cb !== 'function') cb = nop;

  if (state.ended) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
  }

  return ret;
};

Writable.prototype.cork = function () {
  var state = this._writableState;

  state.corked++;
};

Writable.prototype.uncork = function () {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;

    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  }
};

Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    chunk = Buffer.from(chunk, encoding);
  }
  return chunk;
}

Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._writableState.highWaterMark;
  }
});

// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
  if (!isBuf) {
    var newChunk = decodeChunk(state, chunk, encoding);
    if (chunk !== newChunk) {
      isBuf = true;
      encoding = 'buffer';
      chunk = newChunk;
    }
  }
  var len = state.objectMode ? 1 : chunk.length;

  state.length += len;

  var ret = state.length < state.highWaterMark;
  // we must ensure that previous needDrain will not be reset to false.
  if (!ret) state.needDrain = true;

  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = {
      chunk: chunk,
      encoding: encoding,
      isBuf: isBuf,
      callback: cb,
      next: null
    };
    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }
    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;

  if (sync) {
    // defer the callback if we are being called synchronously
    // to avoid piling up things on the stack
    pna.nextTick(cb, er);
    // this can emit finish, and it will always happen
    // after error
    pna.nextTick(finishMaybe, stream, state);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er);
  } else {
    // the caller expect this to happen before if
    // it is async
    cb(er);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er);
    // this can emit finish, but finish must
    // always follow error
    finishMaybe(stream, state);
  }
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;

  onwriteStateUpdate(state);

  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state);

    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }

    if (sync) {
      /*<replacement>*/
      asyncWrite(afterWrite, stream, state, finished, cb);
      /*</replacement>*/
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
}

// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
}

// if there's something in the buffer waiting, then process it
function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;

  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;

    var count = 0;
    var allBuffers = true;
    while (entry) {
      buffer[count] = entry;
      if (!entry.isBuf) allBuffers = false;
      entry = entry.next;
      count += 1;
    }
    buffer.allBuffers = allBuffers;

    doWrite(stream, state, true, state.length, buffer, '', holder.finish);

    // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite
    state.pendingcb++;
    state.lastBufferedRequest = null;
    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }
    state.bufferedRequestCount = 0;
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;

      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      state.bufferedRequestCount--;
      // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.
      if (state.writing) {
        break;
      }
    }

    if (entry === null) state.lastBufferedRequest = null;
  }

  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}

Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new Error('_write() is not implemented'));
};

Writable.prototype._writev = null;

Writable.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);

  // .end() fully uncorks
  if (state.corked) {
    state.corked = 1;
    this.uncork();
  }

  // ignore unnecessary end() calls.
  if (!state.ending && !state.finished) endWritable(this, state, cb);
};

function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}
function callFinal(stream, state) {
  stream._final(function (err) {
    state.pendingcb--;
    if (err) {
      stream.emit('error', err);
    }
    state.prefinished = true;
    stream.emit('prefinish');
    finishMaybe(stream, state);
  });
}
function prefinish(stream, state) {
  if (!state.prefinished && !state.finalCalled) {
    if (typeof stream._final === 'function') {
      state.pendingcb++;
      state.finalCalled = true;
      pna.nextTick(callFinal, stream, state);
    } else {
      state.prefinished = true;
      stream.emit('prefinish');
    }
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(state);
  if (need) {
    prefinish(stream, state);
    if (state.pendingcb === 0) {
      state.finished = true;
      stream.emit('finish');
    }
  }
  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);
  if (cb) {
    if (state.finished) pna.nextTick(cb);else stream.once('finish', cb);
  }
  state.ended = true;
  stream.writable = false;
}

function onCorkedFinish(corkReq, state, err) {
  var entry = corkReq.entry;
  corkReq.entry = null;
  while (entry) {
    var cb = entry.callback;
    state.pendingcb--;
    cb(err);
    entry = entry.next;
  }
  if (state.corkedRequestsFree) {
    state.corkedRequestsFree.next = corkReq;
  } else {
    state.corkedRequestsFree = corkReq;
  }
}

Object.defineProperty(Writable.prototype, 'destroyed', {
  get: function () {
    if (this._writableState === undefined) {
      return false;
    }
    return this._writableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._writableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._writableState.destroyed = value;
  }
});

Writable.prototype.destroy = destroyImpl.destroy;
Writable.prototype._undestroy = destroyImpl.undestroy;
Writable.prototype._destroy = function (err, cb) {
  this.end();
  cb(err);
};
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("timers").setImmediate)
},{"./_stream_duplex":183,"./internal/streams/destroy":189,"./internal/streams/stream":190,"_process":181,"core-util-is":160,"inherits":170,"process-nextick-args":180,"safe-buffer":191,"timers":219,"util-deprecate":224}],188:[function(require,module,exports){
'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Buffer = require('safe-buffer').Buffer;
var util = require('util');

function copyBuffer(src, target, offset) {
  src.copy(target, offset);
}

module.exports = function () {
  function BufferList() {
    _classCallCheck(this, BufferList);

    this.head = null;
    this.tail = null;
    this.length = 0;
  }

  BufferList.prototype.push = function push(v) {
    var entry = { data: v, next: null };
    if (this.length > 0) this.tail.next = entry;else this.head = entry;
    this.tail = entry;
    ++this.length;
  };

  BufferList.prototype.unshift = function unshift(v) {
    var entry = { data: v, next: this.head };
    if (this.length === 0) this.tail = entry;
    this.head = entry;
    ++this.length;
  };

  BufferList.prototype.shift = function shift() {
    if (this.length === 0) return;
    var ret = this.head.data;
    if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
    --this.length;
    return ret;
  };

  BufferList.prototype.clear = function clear() {
    this.head = this.tail = null;
    this.length = 0;
  };

  BufferList.prototype.join = function join(s) {
    if (this.length === 0) return '';
    var p = this.head;
    var ret = '' + p.data;
    while (p = p.next) {
      ret += s + p.data;
    }return ret;
  };

  BufferList.prototype.concat = function concat(n) {
    if (this.length === 0) return Buffer.alloc(0);
    if (this.length === 1) return this.head.data;
    var ret = Buffer.allocUnsafe(n >>> 0);
    var p = this.head;
    var i = 0;
    while (p) {
      copyBuffer(p.data, ret, i);
      i += p.data.length;
      p = p.next;
    }
    return ret;
  };

  return BufferList;
}();

if (util && util.inspect && util.inspect.custom) {
  module.exports.prototype[util.inspect.custom] = function () {
    var obj = util.inspect({ length: this.length });
    return this.constructor.name + ' ' + obj;
  };
}
},{"safe-buffer":191,"util":35}],189:[function(require,module,exports){
'use strict';

/*<replacement>*/

var pna = require('process-nextick-args');
/*</replacement>*/

// undocumented cb() API, needed for core, not for public API
function destroy(err, cb) {
  var _this = this;

  var readableDestroyed = this._readableState && this._readableState.destroyed;
  var writableDestroyed = this._writableState && this._writableState.destroyed;

  if (readableDestroyed || writableDestroyed) {
    if (cb) {
      cb(err);
    } else if (err && (!this._writableState || !this._writableState.errorEmitted)) {
      pna.nextTick(emitErrorNT, this, err);
    }
    return this;
  }

  // we set destroyed to true before firing error callbacks in order
  // to make it re-entrance safe in case destroy() is called within callbacks

  if (this._readableState) {
    this._readableState.destroyed = true;
  }

  // if this is a duplex stream mark the writable part as destroyed as well
  if (this._writableState) {
    this._writableState.destroyed = true;
  }

  this._destroy(err || null, function (err) {
    if (!cb && err) {
      pna.nextTick(emitErrorNT, _this, err);
      if (_this._writableState) {
        _this._writableState.errorEmitted = true;
      }
    } else if (cb) {
      cb(err);
    }
  });

  return this;
}

function undestroy() {
  if (this._readableState) {
    this._readableState.destroyed = false;
    this._readableState.reading = false;
    this._readableState.ended = false;
    this._readableState.endEmitted = false;
  }

  if (this._writableState) {
    this._writableState.destroyed = false;
    this._writableState.ended = false;
    this._writableState.ending = false;
    this._writableState.finished = false;
    this._writableState.errorEmitted = false;
  }
}

function emitErrorNT(self, err) {
  self.emit('error', err);
}

module.exports = {
  destroy: destroy,
  undestroy: undestroy
};
},{"process-nextick-args":180}],190:[function(require,module,exports){
module.exports = require('events').EventEmitter;

},{"events":164}],191:[function(require,module,exports){
/* eslint-disable node/no-deprecated-api */
var buffer = require('buffer')
var Buffer = buffer.Buffer

// alternative to using Object.keys for old browsers
function copyProps (src, dst) {
  for (var key in src) {
    dst[key] = src[key]
  }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports)
  exports.Buffer = SafeBuffer
}

function SafeBuffer (arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length)
}

// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer)

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number')
  }
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  var buf = Buffer(size)
  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding)
    } else {
      buf.fill(fill)
    }
  } else {
    buf.fill(0)
  }
  return buf
}

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return Buffer(size)
}

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return buffer.SlowBuffer(size)
}

},{"buffer":37}],192:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

/*<replacement>*/

var Buffer = require('safe-buffer').Buffer;
/*</replacement>*/

var isEncoding = Buffer.isEncoding || function (encoding) {
  encoding = '' + encoding;
  switch (encoding && encoding.toLowerCase()) {
    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':
      return true;
    default:
      return false;
  }
};

function _normalizeEncoding(enc) {
  if (!enc) return 'utf8';
  var retried;
  while (true) {
    switch (enc) {
      case 'utf8':
      case 'utf-8':
        return 'utf8';
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return 'utf16le';
      case 'latin1':
      case 'binary':
        return 'latin1';
      case 'base64':
      case 'ascii':
      case 'hex':
        return enc;
      default:
        if (retried) return; // undefined
        enc = ('' + enc).toLowerCase();
        retried = true;
    }
  }
};

// Do not cache `Buffer.isEncoding` when checking encoding names as some
// modules monkey-patch it to support additional encodings
function normalizeEncoding(enc) {
  var nenc = _normalizeEncoding(enc);
  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
  return nenc || enc;
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters.
exports.StringDecoder = StringDecoder;
function StringDecoder(encoding) {
  this.encoding = normalizeEncoding(encoding);
  var nb;
  switch (this.encoding) {
    case 'utf16le':
      this.text = utf16Text;
      this.end = utf16End;
      nb = 4;
      break;
    case 'utf8':
      this.fillLast = utf8FillLast;
      nb = 4;
      break;
    case 'base64':
      this.text = base64Text;
      this.end = base64End;
      nb = 3;
      break;
    default:
      this.write = simpleWrite;
      this.end = simpleEnd;
      return;
  }
  this.lastNeed = 0;
  this.lastTotal = 0;
  this.lastChar = Buffer.allocUnsafe(nb);
}

StringDecoder.prototype.write = function (buf) {
  if (buf.length === 0) return '';
  var r;
  var i;
  if (this.lastNeed) {
    r = this.fillLast(buf);
    if (r === undefined) return '';
    i = this.lastNeed;
    this.lastNeed = 0;
  } else {
    i = 0;
  }
  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
  return r || '';
};

StringDecoder.prototype.end = utf8End;

// Returns only complete characters in a Buffer
StringDecoder.prototype.text = utf8Text;

// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
StringDecoder.prototype.fillLast = function (buf) {
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
  this.lastNeed -= buf.length;
};

// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
// continuation byte. If an invalid byte is detected, -2 is returned.
function utf8CheckByte(byte) {
  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;
  return byte >> 6 === 0x02 ? -1 : -2;
}

// Checks at most 3 bytes at the end of a Buffer in order to detect an
// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
// needed to complete the UTF-8 character (if applicable) are returned.
function utf8CheckIncomplete(self, buf, i) {
  var j = buf.length - 1;
  if (j < i) return 0;
  var nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 1;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 2;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) {
      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;
    }
    return nb;
  }
  return 0;
}

// Validates as many continuation bytes for a multi-byte UTF-8 character as
// needed or are available. If we see a non-continuation byte where we expect
// one, we "replace" the validated continuation bytes we've seen so far with
// a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
// behavior. The continuation byte check is included three times in the case
// where all of the continuation bytes for a character exist in the same buffer.
// It is also done this way as a slight performance increase instead of using a
// loop.
function utf8CheckExtraBytes(self, buf, p) {
  if ((buf[0] & 0xC0) !== 0x80) {
    self.lastNeed = 0;
    return '\ufffd';
  }
  if (self.lastNeed > 1 && buf.length > 1) {
    if ((buf[1] & 0xC0) !== 0x80) {
      self.lastNeed = 1;
      return '\ufffd';
    }
    if (self.lastNeed > 2 && buf.length > 2) {
      if ((buf[2] & 0xC0) !== 0x80) {
        self.lastNeed = 2;
        return '\ufffd';
      }
    }
  }
}

// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
function utf8FillLast(buf) {
  var p = this.lastTotal - this.lastNeed;
  var r = utf8CheckExtraBytes(this, buf, p);
  if (r !== undefined) return r;
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, p, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, p, 0, buf.length);
  this.lastNeed -= buf.length;
}

// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
// partial character, the character's bytes are buffered until the required
// number of bytes are available.
function utf8Text(buf, i) {
  var total = utf8CheckIncomplete(this, buf, i);
  if (!this.lastNeed) return buf.toString('utf8', i);
  this.lastTotal = total;
  var end = buf.length - (total - this.lastNeed);
  buf.copy(this.lastChar, 0, end);
  return buf.toString('utf8', i, end);
}

// For UTF-8, a replacement character is added when ending on a partial
// character.
function utf8End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + '\ufffd';
  return r;
}

// UTF-16LE typically needs two bytes per character, but even if we have an even
// number of bytes available, we need to check if we end on a leading/high
// surrogate. In that case, we need to wait for the next two bytes in order to
// decode the last character properly.
function utf16Text(buf, i) {
  if ((buf.length - i) % 2 === 0) {
    var r = buf.toString('utf16le', i);
    if (r) {
      var c = r.charCodeAt(r.length - 1);
      if (c >= 0xD800 && c <= 0xDBFF) {
        this.lastNeed = 2;
        this.lastTotal = 4;
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
        return r.slice(0, -1);
      }
    }
    return r;
  }
  this.lastNeed = 1;
  this.lastTotal = 2;
  this.lastChar[0] = buf[buf.length - 1];
  return buf.toString('utf16le', i, buf.length - 1);
}

// For UTF-16LE we do not explicitly append special replacement characters if we
// end on a partial character, we simply let v8 handle that.
function utf16End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) {
    var end = this.lastTotal - this.lastNeed;
    return r + this.lastChar.toString('utf16le', 0, end);
  }
  return r;
}

function base64Text(buf, i) {
  var n = (buf.length - i) % 3;
  if (n === 0) return buf.toString('base64', i);
  this.lastNeed = 3 - n;
  this.lastTotal = 3;
  if (n === 1) {
    this.lastChar[0] = buf[buf.length - 1];
  } else {
    this.lastChar[0] = buf[buf.length - 2];
    this.lastChar[1] = buf[buf.length - 1];
  }
  return buf.toString('base64', i, buf.length - n);
}

function base64End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
  return r;
}

// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
function simpleWrite(buf) {
  return buf.toString(this.encoding);
}

function simpleEnd(buf) {
  return buf && buf.length ? this.write(buf) : '';
}
},{"safe-buffer":191}],193:[function(require,module,exports){
module.exports = require('./readable').PassThrough

},{"./readable":194}],194:[function(require,module,exports){
exports = module.exports = require('./lib/_stream_readable.js');
exports.Stream = exports;
exports.Readable = exports;
exports.Writable = require('./lib/_stream_writable.js');
exports.Duplex = require('./lib/_stream_duplex.js');
exports.Transform = require('./lib/_stream_transform.js');
exports.PassThrough = require('./lib/_stream_passthrough.js');

},{"./lib/_stream_duplex.js":183,"./lib/_stream_passthrough.js":184,"./lib/_stream_readable.js":185,"./lib/_stream_transform.js":186,"./lib/_stream_writable.js":187}],195:[function(require,module,exports){
module.exports = require('./readable').Transform

},{"./readable":194}],196:[function(require,module,exports){
module.exports = require('./lib/_stream_writable.js');

},{"./lib/_stream_writable.js":187}],197:[function(require,module,exports){
'use strict';

var toObject = Object;
var TypeErr = TypeError;

module.exports = function flags() {
	if (this != null && this !== toObject(this)) {
		throw new TypeErr('RegExp.prototype.flags getter called on non-object');
	}
	var result = '';
	if (this.global) {
		result += 'g';
	}
	if (this.ignoreCase) {
		result += 'i';
	}
	if (this.multiline) {
		result += 'm';
	}
	if (this.dotAll) {
		result += 's';
	}
	if (this.unicode) {
		result += 'u';
	}
	if (this.sticky) {
		result += 'y';
	}
	return result;
};

},{}],198:[function(require,module,exports){
'use strict';

var define = require('define-properties');

var implementation = require('./implementation');
var getPolyfill = require('./polyfill');
var shim = require('./shim');

var flagsBound = Function.call.bind(implementation);

define(flagsBound, {
	getPolyfill: getPolyfill,
	implementation: implementation,
	shim: shim
});

module.exports = flagsBound;

},{"./implementation":197,"./polyfill":199,"./shim":200,"define-properties":162}],199:[function(require,module,exports){
'use strict';

var implementation = require('./implementation');

var supportsDescriptors = require('define-properties').supportsDescriptors;
var gOPD = Object.getOwnPropertyDescriptor;
var TypeErr = TypeError;

module.exports = function getPolyfill() {
	if (!supportsDescriptors) {
		throw new TypeErr('RegExp.prototype.flags requires a true ES5 environment that supports property descriptors');
	}
	if (/a/mig.flags === 'gim') {
		var descriptor = gOPD(RegExp.prototype, 'flags');
		if (descriptor && typeof descriptor.get === 'function' && typeof (/a/).dotAll === 'boolean') {
			return descriptor.get;
		}
	}
	return implementation;
};

},{"./implementation":197,"define-properties":162}],200:[function(require,module,exports){
'use strict';

var supportsDescriptors = require('define-properties').supportsDescriptors;
var getPolyfill = require('./polyfill');
var gOPD = Object.getOwnPropertyDescriptor;
var defineProperty = Object.defineProperty;
var TypeErr = TypeError;
var getProto = Object.getPrototypeOf;
var regex = /a/;

module.exports = function shimFlags() {
	if (!supportsDescriptors || !getProto) {
		throw new TypeErr('RegExp.prototype.flags requires a true ES5 environment that supports property descriptors');
	}
	var polyfill = getPolyfill();
	var proto = getProto(regex);
	var descriptor = gOPD(proto, 'flags');
	if (!descriptor || descriptor.get !== polyfill) {
		defineProperty(proto, 'flags', {
			configurable: true,
			enumerable: false,
			get: polyfill
		});
	}
	return polyfill;
};

},{"./polyfill":199,"define-properties":162}],201:[function(require,module,exports){
(function () {
    var key, val, _ref, _ref1;
    exports.EncodeStream = require('./src/EncodeStream');
    exports.DecodeStream = require('./src/DecodeStream');
    exports.Array = require('./src/Array');
    exports.LazyArray = require('./src/LazyArray');
    exports.Bitfield = require('./src/Bitfield');
    exports.Boolean = require('./src/Boolean');
    exports.Buffer = require('./src/Buffer');
    exports.Enum = require('./src/Enum');
    exports.Optional = require('./src/Optional');
    exports.Reserved = require('./src/Reserved');
    exports.String = require('./src/String');
    exports.Struct = require('./src/Struct');
    exports.VersionedStruct = require('./src/VersionedStruct');
    _ref = require('./src/Number');
    for (key in _ref) {
        val = _ref[key];
        exports[key] = val;
    }
    _ref1 = require('./src/Pointer');
    for (key in _ref1) {
        val = _ref1[key];
        exports[key] = val;
    }
}.call(this));
},{"./src/Array":202,"./src/Bitfield":203,"./src/Boolean":204,"./src/Buffer":205,"./src/DecodeStream":206,"./src/EncodeStream":207,"./src/Enum":208,"./src/LazyArray":209,"./src/Number":210,"./src/Optional":211,"./src/Pointer":212,"./src/Reserved":213,"./src/String":214,"./src/Struct":215,"./src/VersionedStruct":216}],202:[function(require,module,exports){
(function () {
    var ArrayT, NumberT, utils;
    NumberT = require('./Number').Number;
    utils = require('./utils');
    ArrayT = function () {
        function ArrayT(type, length, lengthType) {
            this.type = type;
            this.length = length;
            this.lengthType = lengthType != null ? lengthType : 'count';
        }
        ArrayT.prototype.decode = function (stream, parent) {
            var ctx, i, length, pos, res, target, _i;
            pos = stream.pos;
            res = [];
            ctx = parent;
            if (this.length != null) {
                length = utils.resolveLength(this.length, stream, parent);
            }
            if (this.length instanceof NumberT) {
                Object.defineProperties(res, {
                    parent: { value: parent },
                    _startOffset: { value: pos },
                    _currentOffset: {
                        value: 0,
                        writable: true
                    },
                    _length: { value: length }
                });
                ctx = res;
            }
            if (length == null || this.lengthType === 'bytes') {
                target = length != null ? stream.pos + length : (parent != null ? parent._length : void 0) ? parent._startOffset + parent._length : stream.length;
                while (stream.pos < target) {
                    res.push(this.type.decode(stream, ctx));
                }
            } else {
                for (i = _i = 0; _i < length; i = _i += 1) {
                    res.push(this.type.decode(stream, ctx));
                }
            }
            return res;
        };
        ArrayT.prototype.size = function (array, ctx) {
            var item, size, _i, _len;
            if (!array) {
                return this.type.size(null, ctx) * utils.resolveLength(this.length, null, ctx);
            }
            size = 0;
            if (this.length instanceof NumberT) {
                size += this.length.size();
                ctx = { parent: ctx };
            }
            for (_i = 0, _len = array.length; _i < _len; _i++) {
                item = array[_i];
                size += this.type.size(item, ctx);
            }
            return size;
        };
        ArrayT.prototype.encode = function (stream, array, parent) {
            var ctx, i, item, ptr, _i, _len;
            ctx = parent;
            if (this.length instanceof NumberT) {
                ctx = {
                    pointers: [],
                    startOffset: stream.pos,
                    parent: parent
                };
                ctx.pointerOffset = stream.pos + this.size(array, ctx);
                this.length.encode(stream, array.length);
            }
            for (_i = 0, _len = array.length; _i < _len; _i++) {
                item = array[_i];
                this.type.encode(stream, item, ctx);
            }
            if (this.length instanceof NumberT) {
                i = 0;
                while (i < ctx.pointers.length) {
                    ptr = ctx.pointers[i++];
                    ptr.type.encode(stream, ptr.val);
                }
            }
        };
        return ArrayT;
    }();
    module.exports = ArrayT;
}.call(this));
},{"./Number":210,"./utils":217}],203:[function(require,module,exports){
(function () {
    var Bitfield;
    Bitfield = function () {
        function Bitfield(type, flags) {
            this.type = type;
            this.flags = flags != null ? flags : [];
        }
        Bitfield.prototype.decode = function (stream) {
            var flag, i, res, val, _i, _len, _ref;
            val = this.type.decode(stream);
            res = {};
            _ref = this.flags;
            for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
                flag = _ref[i];
                if (flag != null) {
                    res[flag] = !!(val & 1 << i);
                }
            }
            return res;
        };
        Bitfield.prototype.size = function () {
            return this.type.size();
        };
        Bitfield.prototype.encode = function (stream, keys) {
            var flag, i, val, _i, _len, _ref;
            val = 0;
            _ref = this.flags;
            for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
                flag = _ref[i];
                if (flag != null) {
                    if (keys[flag]) {
                        val |= 1 << i;
                    }
                }
            }
            return this.type.encode(stream, val);
        };
        return Bitfield;
    }();
    module.exports = Bitfield;
}.call(this));
},{}],204:[function(require,module,exports){
(function () {
    var BooleanT;
    BooleanT = function () {
        function BooleanT(type) {
            this.type = type;
        }
        BooleanT.prototype.decode = function (stream, parent) {
            return !!this.type.decode(stream, parent);
        };
        BooleanT.prototype.size = function (val, parent) {
            return this.type.size(val, parent);
        };
        BooleanT.prototype.encode = function (stream, val, parent) {
            return this.type.encode(stream, +val, parent);
        };
        return BooleanT;
    }();
    module.exports = BooleanT;
}.call(this));
},{}],205:[function(require,module,exports){
(function () {
    var BufferT, NumberT, utils;
    utils = require('./utils');
    NumberT = require('./Number').Number;
    BufferT = function () {
        function BufferT(length) {
            this.length = length;
        }
        BufferT.prototype.decode = function (stream, parent) {
            var length;
            length = utils.resolveLength(this.length, stream, parent);
            return stream.readBuffer(length);
        };
        BufferT.prototype.size = function (val, parent) {
            if (!val) {
                return utils.resolveLength(this.length, null, parent);
            }
            return val.length;
        };
        BufferT.prototype.encode = function (stream, buf, parent) {
            if (this.length instanceof NumberT) {
                this.length.encode(stream, buf.length);
            }
            return stream.writeBuffer(buf);
        };
        return BufferT;
    }();
    module.exports = BufferT;
}.call(this));
},{"./Number":210,"./utils":217}],206:[function(require,module,exports){
(function (Buffer){
(function () {
    var DecodeStream, iconv;
    try {
        iconv = function () {
            throw new Error('Cannot find module \'iconv-lite\' from \'/Users/roel/work/recursive/extension/node_modules/restructure/src\'');
        }();
    } catch (_error) {
    }
    DecodeStream = function () {
        var key;
        function DecodeStream(buffer) {
            this.buffer = buffer;
            this.pos = 0;
            this.length = this.buffer.length;
        }
        DecodeStream.TYPES = {
            UInt8: 1,
            UInt16: 2,
            UInt24: 3,
            UInt32: 4,
            Int8: 1,
            Int16: 2,
            Int24: 3,
            Int32: 4,
            Float: 4,
            Double: 8
        };
        for (key in Buffer.prototype) {
            if (key.slice(0, 4) === 'read') {
                (function (key) {
                    var bytes;
                    bytes = DecodeStream.TYPES[key.replace(/read|[BL]E/g, '')];
                    return DecodeStream.prototype[key] = function () {
                        var ret;
                        ret = this.buffer[key](this.pos);
                        this.pos += bytes;
                        return ret;
                    };
                }(key));
            }
        }
        DecodeStream.prototype.readString = function (length, encoding) {
            var buf, byte, i, _i, _ref;
            if (encoding == null) {
                encoding = 'ascii';
            }
            switch (encoding) {
            case 'utf16le':
            case 'ucs2':
            case 'utf8':
            case 'ascii':
                return this.buffer.toString(encoding, this.pos, this.pos += length);
            case 'utf16be':
                buf = new Buffer(this.readBuffer(length));
                for (i = _i = 0, _ref = buf.length - 1; _i < _ref; i = _i += 2) {
                    byte = buf[i];
                    buf[i] = buf[i + 1];
                    buf[i + 1] = byte;
                }
                return buf.toString('utf16le');
            default:
                buf = this.readBuffer(length);
                if (iconv) {
                    try {
                        return iconv.decode(buf, encoding);
                    } catch (_error) {
                    }
                }
                return buf;
            }
        };
        DecodeStream.prototype.readBuffer = function (length) {
            return this.buffer.slice(this.pos, this.pos += length);
        };
        DecodeStream.prototype.readUInt24BE = function () {
            return (this.readUInt16BE() << 8) + this.readUInt8();
        };
        DecodeStream.prototype.readUInt24LE = function () {
            return this.readUInt16LE() + (this.readUInt8() << 16);
        };
        DecodeStream.prototype.readInt24BE = function () {
            return (this.readInt16BE() << 8) + this.readUInt8();
        };
        DecodeStream.prototype.readInt24LE = function () {
            return this.readUInt16LE() + (this.readInt8() << 16);
        };
        return DecodeStream;
    }();
    module.exports = DecodeStream;
}.call(this));
}).call(this,require("buffer").Buffer)
},{"buffer":37}],207:[function(require,module,exports){
(function (Buffer){
(function () {
    var DecodeStream, EncodeStream, iconv, stream, __hasProp = {}.hasOwnProperty, __extends = function (child, parent) {
            for (var key in parent) {
                if (__hasProp.call(parent, key))
                    child[key] = parent[key];
            }
            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        };
    stream = require('stream');
    DecodeStream = require('./DecodeStream');
    try {
        iconv = function () {
            throw new Error('Cannot find module \'iconv-lite\' from \'/Users/roel/work/recursive/extension/node_modules/restructure/src\'');
        }();
    } catch (_error) {
    }
    EncodeStream = function (_super) {
        var key;
        __extends(EncodeStream, _super);
        function EncodeStream(bufferSize) {
            if (bufferSize == null) {
                bufferSize = 65536;
            }
            EncodeStream.__super__.constructor.apply(this, arguments);
            this.buffer = new Buffer(bufferSize);
            this.bufferOffset = 0;
            this.pos = 0;
        }
        for (key in Buffer.prototype) {
            if (key.slice(0, 5) === 'write') {
                (function (key) {
                    var bytes;
                    bytes = +DecodeStream.TYPES[key.replace(/write|[BL]E/g, '')];
                    return EncodeStream.prototype[key] = function (value) {
                        this.ensure(bytes);
                        this.buffer[key](value, this.bufferOffset);
                        this.bufferOffset += bytes;
                        return this.pos += bytes;
                    };
                }(key));
            }
        }
        EncodeStream.prototype._read = function () {
        };
        EncodeStream.prototype.ensure = function (bytes) {
            if (this.bufferOffset + bytes > this.buffer.length) {
                return this.flush();
            }
        };
        EncodeStream.prototype.flush = function () {
            if (this.bufferOffset > 0) {
                this.push(new Buffer(this.buffer.slice(0, this.bufferOffset)));
                return this.bufferOffset = 0;
            }
        };
        EncodeStream.prototype.writeBuffer = function (buffer) {
            this.flush();
            this.push(buffer);
            return this.pos += buffer.length;
        };
        EncodeStream.prototype.writeString = function (string, encoding) {
            var buf, byte, i, _i, _ref;
            if (encoding == null) {
                encoding = 'ascii';
            }
            switch (encoding) {
            case 'utf16le':
            case 'ucs2':
            case 'utf8':
            case 'ascii':
                return this.writeBuffer(new Buffer(string, encoding));
            case 'utf16be':
                buf = new Buffer(string, 'utf16le');
                for (i = _i = 0, _ref = buf.length - 1; _i < _ref; i = _i += 2) {
                    byte = buf[i];
                    buf[i] = buf[i + 1];
                    buf[i + 1] = byte;
                }
                return this.writeBuffer(buf);
            default:
                if (iconv) {
                    return this.writeBuffer(iconv.encode(string, encoding));
                } else {
                    throw new Error('Install iconv-lite to enable additional string encodings.');
                }
            }
        };
        EncodeStream.prototype.writeUInt24BE = function (val) {
            this.ensure(3);
            this.buffer[this.bufferOffset++] = val >>> 16 & 255;
            this.buffer[this.bufferOffset++] = val >>> 8 & 255;
            this.buffer[this.bufferOffset++] = val & 255;
            return this.pos += 3;
        };
        EncodeStream.prototype.writeUInt24LE = function (val) {
            this.ensure(3);
            this.buffer[this.bufferOffset++] = val & 255;
            this.buffer[this.bufferOffset++] = val >>> 8 & 255;
            this.buffer[this.bufferOffset++] = val >>> 16 & 255;
            return this.pos += 3;
        };
        EncodeStream.prototype.writeInt24BE = function (val) {
            if (val >= 0) {
                return this.writeUInt24BE(val);
            } else {
                return this.writeUInt24BE(val + 16777215 + 1);
            }
        };
        EncodeStream.prototype.writeInt24LE = function (val) {
            if (val >= 0) {
                return this.writeUInt24LE(val);
            } else {
                return this.writeUInt24LE(val + 16777215 + 1);
            }
        };
        EncodeStream.prototype.fill = function (val, length) {
            var buf;
            if (length < this.buffer.length) {
                this.ensure(length);
                this.buffer.fill(val, this.bufferOffset, this.bufferOffset + length);
                this.bufferOffset += length;
                return this.pos += length;
            } else {
                buf = new Buffer(length);
                buf.fill(val);
                return this.writeBuffer(buf);
            }
        };
        EncodeStream.prototype.end = function () {
            this.flush();
            return this.push(null);
        };
        return EncodeStream;
    }(stream.Readable);
    module.exports = EncodeStream;
}.call(this));
}).call(this,require("buffer").Buffer)
},{"./DecodeStream":206,"buffer":37,"stream":218}],208:[function(require,module,exports){
(function () {
    var Enum;
    Enum = function () {
        function Enum(type, options) {
            this.type = type;
            this.options = options != null ? options : [];
        }
        Enum.prototype.decode = function (stream) {
            var index;
            index = this.type.decode(stream);
            return this.options[index] || index;
        };
        Enum.prototype.size = function () {
            return this.type.size();
        };
        Enum.prototype.encode = function (stream, val) {
            var index;
            index = this.options.indexOf(val);
            if (index === -1) {
                throw new Error('Unknown option in enum: ' + val);
            }
            return this.type.encode(stream, index);
        };
        return Enum;
    }();
    module.exports = Enum;
}.call(this));
},{}],209:[function(require,module,exports){
(function () {
    var ArrayT, LazyArray, LazyArrayT, NumberT, inspect, utils, __hasProp = {}.hasOwnProperty, __extends = function (child, parent) {
            for (var key in parent) {
                if (__hasProp.call(parent, key))
                    child[key] = parent[key];
            }
            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        };
    ArrayT = require('./Array');
    NumberT = require('./Number').Number;
    utils = require('./utils');
    inspect = require('util').inspect;
    LazyArrayT = function (_super) {
        __extends(LazyArrayT, _super);
        function LazyArrayT() {
            return LazyArrayT.__super__.constructor.apply(this, arguments);
        }
        LazyArrayT.prototype.decode = function (stream, parent) {
            var length, pos, res;
            pos = stream.pos;
            length = utils.resolveLength(this.length, stream, parent);
            if (this.length instanceof NumberT) {
                parent = {
                    parent: parent,
                    _startOffset: pos,
                    _currentOffset: 0,
                    _length: length
                };
            }
            res = new LazyArray(this.type, length, stream, parent);
            stream.pos += length * this.type.size(null, parent);
            return res;
        };
        LazyArrayT.prototype.size = function (val, ctx) {
            if (val instanceof LazyArray) {
                val = val.toArray();
            }
            return LazyArrayT.__super__.size.call(this, val, ctx);
        };
        LazyArrayT.prototype.encode = function (stream, val, ctx) {
            if (val instanceof LazyArray) {
                val = val.toArray();
            }
            return LazyArrayT.__super__.encode.call(this, stream, val, ctx);
        };
        return LazyArrayT;
    }(ArrayT);
    LazyArray = function () {
        function LazyArray(type, length, stream, ctx) {
            this.type = type;
            this.length = length;
            this.stream = stream;
            this.ctx = ctx;
            this.base = this.stream.pos;
            this.items = [];
        }
        LazyArray.prototype.get = function (index) {
            var pos;
            if (index < 0 || index >= this.length) {
                return void 0;
            }
            if (this.items[index] == null) {
                pos = this.stream.pos;
                this.stream.pos = this.base + this.type.size(null, this.ctx) * index;
                this.items[index] = this.type.decode(this.stream, this.ctx);
                this.stream.pos = pos;
            }
            return this.items[index];
        };
        LazyArray.prototype.toArray = function () {
            var i, _i, _ref, _results;
            _results = [];
            for (i = _i = 0, _ref = this.length; _i < _ref; i = _i += 1) {
                _results.push(this.get(i));
            }
            return _results;
        };
        LazyArray.prototype.inspect = function () {
            return inspect(this.toArray());
        };
        return LazyArray;
    }();
    module.exports = LazyArrayT;
}.call(this));
},{"./Array":202,"./Number":210,"./utils":217,"util":227}],210:[function(require,module,exports){
(function () {
    var DecodeStream, Fixed, NumberT, __hasProp = {}.hasOwnProperty, __extends = function (child, parent) {
            for (var key in parent) {
                if (__hasProp.call(parent, key))
                    child[key] = parent[key];
            }
            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        };
    DecodeStream = require('./DecodeStream');
    NumberT = function () {
        function NumberT(type, endian) {
            this.type = type;
            this.endian = endian != null ? endian : 'BE';
            this.fn = this.type;
            if (this.type[this.type.length - 1] !== '8') {
                this.fn += this.endian;
            }
        }
        NumberT.prototype.size = function () {
            return DecodeStream.TYPES[this.type];
        };
        NumberT.prototype.decode = function (stream) {
            return stream['read' + this.fn]();
        };
        NumberT.prototype.encode = function (stream, val) {
            return stream['write' + this.fn](val);
        };
        return NumberT;
    }();
    exports.Number = NumberT;
    exports.uint8 = new NumberT('UInt8');
    exports.uint16be = exports.uint16 = new NumberT('UInt16', 'BE');
    exports.uint16le = new NumberT('UInt16', 'LE');
    exports.uint24be = exports.uint24 = new NumberT('UInt24', 'BE');
    exports.uint24le = new NumberT('UInt24', 'LE');
    exports.uint32be = exports.uint32 = new NumberT('UInt32', 'BE');
    exports.uint32le = new NumberT('UInt32', 'LE');
    exports.int8 = new NumberT('Int8');
    exports.int16be = exports.int16 = new NumberT('Int16', 'BE');
    exports.int16le = new NumberT('Int16', 'LE');
    exports.int24be = exports.int24 = new NumberT('Int24', 'BE');
    exports.int24le = new NumberT('Int24', 'LE');
    exports.int32be = exports.int32 = new NumberT('Int32', 'BE');
    exports.int32le = new NumberT('Int32', 'LE');
    exports.floatbe = exports.float = new NumberT('Float', 'BE');
    exports.floatle = new NumberT('Float', 'LE');
    exports.doublebe = exports.double = new NumberT('Double', 'BE');
    exports.doublele = new NumberT('Double', 'LE');
    Fixed = function (_super) {
        __extends(Fixed, _super);
        function Fixed(size, endian, fracBits) {
            if (fracBits == null) {
                fracBits = size >> 1;
            }
            Fixed.__super__.constructor.call(this, 'Int' + size, endian);
            this._point = 1 << fracBits;
        }
        Fixed.prototype.decode = function (stream) {
            return Fixed.__super__.decode.call(this, stream) / this._point;
        };
        Fixed.prototype.encode = function (stream, val) {
            return Fixed.__super__.encode.call(this, stream, val * this._point | 0);
        };
        return Fixed;
    }(NumberT);
    exports.Fixed = Fixed;
    exports.fixed16be = exports.fixed16 = new Fixed(16, 'BE');
    exports.fixed16le = new Fixed(16, 'LE');
    exports.fixed32be = exports.fixed32 = new Fixed(32, 'BE');
    exports.fixed32le = new Fixed(32, 'LE');
}.call(this));
},{"./DecodeStream":206}],211:[function(require,module,exports){
(function () {
    var Optional;
    Optional = function () {
        function Optional(type, condition) {
            this.type = type;
            this.condition = condition != null ? condition : true;
        }
        Optional.prototype.decode = function (stream, parent) {
            var condition;
            condition = this.condition;
            if (typeof condition === 'function') {
                condition = condition.call(parent, parent);
            }
            if (condition) {
                return this.type.decode(stream, parent);
            }
        };
        Optional.prototype.size = function (val, parent) {
            var condition;
            condition = this.condition;
            if (typeof condition === 'function') {
                condition = condition.call(parent, parent);
            }
            if (condition) {
                return this.type.size(val, parent);
            } else {
                return 0;
            }
        };
        Optional.prototype.encode = function (stream, val, parent) {
            var condition;
            condition = this.condition;
            if (typeof condition === 'function') {
                condition = condition.call(parent, parent);
            }
            if (condition) {
                return this.type.encode(stream, val, parent);
            }
        };
        return Optional;
    }();
    module.exports = Optional;
}.call(this));
},{}],212:[function(require,module,exports){
(function () {
    var Pointer, VoidPointer, utils;
    utils = require('./utils');
    Pointer = function () {
        function Pointer(offsetType, type, options) {
            var _base, _base1, _base2, _base3;
            this.offsetType = offsetType;
            this.type = type;
            this.options = options != null ? options : {};
            if (this.type === 'void') {
                this.type = null;
            }
            if ((_base = this.options).type == null) {
                _base.type = 'local';
            }
            if ((_base1 = this.options).allowNull == null) {
                _base1.allowNull = true;
            }
            if ((_base2 = this.options).nullValue == null) {
                _base2.nullValue = 0;
            }
            if ((_base3 = this.options).lazy == null) {
                _base3.lazy = false;
            }
            if (this.options.relativeTo) {
                this.relativeToGetter = new Function('ctx', 'return ctx.' + this.options.relativeTo);
            }
        }
        Pointer.prototype.decode = function (stream, ctx) {
            var c, decodeValue, offset, ptr, relative, val;
            offset = this.offsetType.decode(stream, ctx);
            if (offset === this.options.nullValue && this.options.allowNull) {
                return null;
            }
            relative = function () {
                switch (this.options.type) {
                case 'local':
                    return ctx._startOffset;
                case 'immediate':
                    return stream.pos - this.offsetType.size();
                case 'parent':
                    return ctx.parent._startOffset;
                default:
                    c = ctx;
                    while (c.parent) {
                        c = c.parent;
                    }
                    return c._startOffset || 0;
                }
            }.call(this);
            if (this.options.relativeTo) {
                relative += this.relativeToGetter(ctx);
            }
            ptr = offset + relative;
            if (this.type != null) {
                val = null;
                decodeValue = function (_this) {
                    return function () {
                        var pos;
                        if (val != null) {
                            return val;
                        }
                        pos = stream.pos;
                        stream.pos = ptr;
                        val = _this.type.decode(stream, ctx);
                        stream.pos = pos;
                        return val;
                    };
                }(this);
                if (this.options.lazy) {
                    return new utils.PropertyDescriptor({ get: decodeValue });
                }
                return decodeValue();
            } else {
                return ptr;
            }
        };
        Pointer.prototype.size = function (val, ctx) {
            var parent, type;
            parent = ctx;
            switch (this.options.type) {
            case 'local':
            case 'immediate':
                break;
            case 'parent':
                ctx = ctx.parent;
                break;
            default:
                while (ctx.parent) {
                    ctx = ctx.parent;
                }
            }
            type = this.type;
            if (type == null) {
                if (!(val instanceof VoidPointer)) {
                    throw new Error('Must be a VoidPointer');
                }
                type = val.type;
                val = val.value;
            }
            if (val && ctx) {
                ctx.pointerSize += type.size(val, parent);
            }
            return this.offsetType.size();
        };
        Pointer.prototype.encode = function (stream, val, ctx) {
            var parent, relative, type;
            parent = ctx;
            if (val == null) {
                this.offsetType.encode(stream, this.options.nullValue);
                return;
            }
            switch (this.options.type) {
            case 'local':
                relative = ctx.startOffset;
                break;
            case 'immediate':
                relative = stream.pos + this.offsetType.size(val, parent);
                break;
            case 'parent':
                ctx = ctx.parent;
                relative = ctx.startOffset;
                break;
            default:
                relative = 0;
                while (ctx.parent) {
                    ctx = ctx.parent;
                }
            }
            if (this.options.relativeTo) {
                relative += this.relativeToGetter(parent.val);
            }
            this.offsetType.encode(stream, ctx.pointerOffset - relative);
            type = this.type;
            if (type == null) {
                if (!(val instanceof VoidPointer)) {
                    throw new Error('Must be a VoidPointer');
                }
                type = val.type;
                val = val.value;
            }
            ctx.pointers.push({
                type: type,
                val: val,
                parent: parent
            });
            return ctx.pointerOffset += type.size(val, parent);
        };
        return Pointer;
    }();
    VoidPointer = function () {
        function VoidPointer(type, value) {
            this.type = type;
            this.value = value;
        }
        return VoidPointer;
    }();
    exports.Pointer = Pointer;
    exports.VoidPointer = VoidPointer;
}.call(this));
},{"./utils":217}],213:[function(require,module,exports){
(function () {
    var Reserved, utils;
    utils = require('./utils');
    Reserved = function () {
        function Reserved(type, count) {
            this.type = type;
            this.count = count != null ? count : 1;
        }
        Reserved.prototype.decode = function (stream, parent) {
            stream.pos += this.size(null, parent);
            return void 0;
        };
        Reserved.prototype.size = function (data, parent) {
            var count;
            count = utils.resolveLength(this.count, null, parent);
            return this.type.size() * count;
        };
        Reserved.prototype.encode = function (stream, val, parent) {
            return stream.fill(0, this.size(val, parent));
        };
        return Reserved;
    }();
    module.exports = Reserved;
}.call(this));
},{"./utils":217}],214:[function(require,module,exports){
(function (Buffer){
(function () {
    var NumberT, StringT, utils;
    NumberT = require('./Number').Number;
    utils = require('./utils');
    StringT = function () {
        function StringT(length, encoding) {
            this.length = length;
            this.encoding = encoding != null ? encoding : 'ascii';
        }
        StringT.prototype.decode = function (stream, parent) {
            var buffer, encoding, length, pos, string;
            length = function () {
                if (this.length != null) {
                    return utils.resolveLength(this.length, stream, parent);
                } else {
                    buffer = stream.buffer, length = stream.length, pos = stream.pos;
                    while (pos < length && buffer[pos] !== 0) {
                        ++pos;
                    }
                    return pos - stream.pos;
                }
            }.call(this);
            encoding = this.encoding;
            if (typeof encoding === 'function') {
                encoding = encoding.call(parent, parent) || 'ascii';
            }
            string = stream.readString(length, encoding);
            if (this.length == null && stream.pos < stream.length) {
                stream.pos++;
            }
            return string;
        };
        StringT.prototype.size = function (val, parent) {
            var encoding, size;
            if (!val) {
                return utils.resolveLength(this.length, null, parent);
            }
            encoding = this.encoding;
            if (typeof encoding === 'function') {
                encoding = encoding.call(parent != null ? parent.val : void 0, parent != null ? parent.val : void 0) || 'ascii';
            }
            if (encoding === 'utf16be') {
                encoding = 'utf16le';
            }
            size = Buffer.byteLength(val, encoding);
            if (this.length instanceof NumberT) {
                size += this.length.size();
            }
            if (this.length == null) {
                size++;
            }
            return size;
        };
        StringT.prototype.encode = function (stream, val, parent) {
            var encoding;
            encoding = this.encoding;
            if (typeof encoding === 'function') {
                encoding = encoding.call(parent != null ? parent.val : void 0, parent != null ? parent.val : void 0) || 'ascii';
            }
            if (this.length instanceof NumberT) {
                this.length.encode(stream, Buffer.byteLength(val, encoding));
            }
            stream.writeString(val, encoding);
            if (this.length == null) {
                return stream.writeUInt8(0);
            }
        };
        return StringT;
    }();
    module.exports = StringT;
}.call(this));
}).call(this,require("buffer").Buffer)
},{"./Number":210,"./utils":217,"buffer":37}],215:[function(require,module,exports){
(function () {
    var Struct, utils;
    utils = require('./utils');
    Struct = function () {
        function Struct(fields) {
            this.fields = fields != null ? fields : {};
        }
        Struct.prototype.decode = function (stream, parent, length) {
            var res, _ref;
            if (length == null) {
                length = 0;
            }
            res = this._setup(stream, parent, length);
            this._parseFields(stream, res, this.fields);
            if ((_ref = this.process) != null) {
                _ref.call(res, stream);
            }
            return res;
        };
        Struct.prototype._setup = function (stream, parent, length) {
            var res;
            res = {};
            Object.defineProperties(res, {
                parent: { value: parent },
                _startOffset: { value: stream.pos },
                _currentOffset: {
                    value: 0,
                    writable: true
                },
                _length: { value: length }
            });
            return res;
        };
        Struct.prototype._parseFields = function (stream, res, fields) {
            var key, type, val;
            for (key in fields) {
                type = fields[key];
                if (typeof type === 'function') {
                    val = type.call(res, res);
                } else {
                    val = type.decode(stream, res);
                }
                if (val !== void 0) {
                    if (val instanceof utils.PropertyDescriptor) {
                        Object.defineProperty(res, key, val);
                    } else {
                        res[key] = val;
                    }
                }
                res._currentOffset = stream.pos - res._startOffset;
            }
        };
        Struct.prototype.size = function (val, parent, includePointers) {
            var ctx, key, size, type, _ref;
            if (val == null) {
                val = {};
            }
            if (includePointers == null) {
                includePointers = true;
            }
            ctx = {
                parent: parent,
                val: val,
                pointerSize: 0
            };
            size = 0;
            _ref = this.fields;
            for (key in _ref) {
                type = _ref[key];
                if (type.size != null) {
                    size += type.size(val[key], ctx);
                }
            }
            if (includePointers) {
                size += ctx.pointerSize;
            }
            return size;
        };
        Struct.prototype.encode = function (stream, val, parent) {
            var ctx, i, key, ptr, type, _ref, _ref1;
            if ((_ref = this.preEncode) != null) {
                _ref.call(val, stream);
            }
            ctx = {
                pointers: [],
                startOffset: stream.pos,
                parent: parent,
                val: val,
                pointerSize: 0
            };
            ctx.pointerOffset = stream.pos + this.size(val, ctx, false);
            _ref1 = this.fields;
            for (key in _ref1) {
                type = _ref1[key];
                if (type.encode != null) {
                    type.encode(stream, val[key], ctx);
                }
            }
            i = 0;
            while (i < ctx.pointers.length) {
                ptr = ctx.pointers[i++];
                ptr.type.encode(stream, ptr.val, ptr.parent);
            }
        };
        return Struct;
    }();
    module.exports = Struct;
}.call(this));
},{"./utils":217}],216:[function(require,module,exports){
(function () {
    var Struct, VersionedStruct, __hasProp = {}.hasOwnProperty, __extends = function (child, parent) {
            for (var key in parent) {
                if (__hasProp.call(parent, key))
                    child[key] = parent[key];
            }
            function ctor() {
                this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        };
    Struct = require('./Struct');
    VersionedStruct = function (_super) {
        __extends(VersionedStruct, _super);
        function VersionedStruct(type, versions) {
            this.type = type;
            this.versions = versions != null ? versions : {};
            if (typeof this.type === 'string') {
                this.versionGetter = new Function('parent', 'return parent.' + this.type);
                this.versionSetter = new Function('parent', 'version', 'return parent.' + this.type + ' = version');
            }
        }
        VersionedStruct.prototype.decode = function (stream, parent, length) {
            var fields, res, _ref;
            if (length == null) {
                length = 0;
            }
            res = this._setup(stream, parent, length);
            if (typeof this.type === 'string') {
                res.version = this.versionGetter(parent);
            } else {
                res.version = this.type.decode(stream);
            }
            if (this.versions.header) {
                this._parseFields(stream, res, this.versions.header);
            }
            fields = this.versions[res.version];
            if (fields == null) {
                throw new Error('Unknown version ' + res.version);
            }
            if (fields instanceof VersionedStruct) {
                return fields.decode(stream, parent);
            }
            this._parseFields(stream, res, fields);
            if ((_ref = this.process) != null) {
                _ref.call(res, stream);
            }
            return res;
        };
        VersionedStruct.prototype.size = function (val, parent, includePointers) {
            var ctx, fields, key, size, type, _ref;
            if (includePointers == null) {
                includePointers = true;
            }
            if (!val) {
                throw new Error('Not a fixed size');
            }
            ctx = {
                parent: parent,
                val: val,
                pointerSize: 0
            };
            size = 0;
            if (typeof this.type !== 'string') {
                size += this.type.size(val.version, ctx);
            }
            if (this.versions.header) {
                _ref = this.versions.header;
                for (key in _ref) {
                    type = _ref[key];
                    if (type.size != null) {
                        size += type.size(val[key], ctx);
                    }
                }
            }
            fields = this.versions[val.version];
            if (fields == null) {
                throw new Error('Unknown version ' + val.version);
            }
            for (key in fields) {
                type = fields[key];
                if (type.size != null) {
                    size += type.size(val[key], ctx);
                }
            }
            if (includePointers) {
                size += ctx.pointerSize;
            }
            return size;
        };
        VersionedStruct.prototype.encode = function (stream, val, parent) {
            var ctx, fields, i, key, ptr, type, _ref, _ref1;
            if ((_ref = this.preEncode) != null) {
                _ref.call(val, stream);
            }
            ctx = {
                pointers: [],
                startOffset: stream.pos,
                parent: parent,
                val: val,
                pointerSize: 0
            };
            ctx.pointerOffset = stream.pos + this.size(val, ctx, false);
            if (typeof this.type !== 'string') {
                this.type.encode(stream, val.version);
            }
            if (this.versions.header) {
                _ref1 = this.versions.header;
                for (key in _ref1) {
                    type = _ref1[key];
                    if (type.encode != null) {
                        type.encode(stream, val[key], ctx);
                    }
                }
            }
            fields = this.versions[val.version];
            for (key in fields) {
                type = fields[key];
                if (type.encode != null) {
                    type.encode(stream, val[key], ctx);
                }
            }
            i = 0;
            while (i < ctx.pointers.length) {
                ptr = ctx.pointers[i++];
                ptr.type.encode(stream, ptr.val, ptr.parent);
            }
        };
        return VersionedStruct;
    }(Struct);
    module.exports = VersionedStruct;
}.call(this));
},{"./Struct":215}],217:[function(require,module,exports){
(function () {
    var NumberT, PropertyDescriptor;
    NumberT = require('./Number').Number;
    exports.resolveLength = function (length, stream, parent) {
        var res;
        if (typeof length === 'number') {
            res = length;
        } else if (typeof length === 'function') {
            res = length.call(parent, parent);
        } else if (parent && typeof length === 'string') {
            res = parent[length];
        } else if (stream && length instanceof NumberT) {
            res = length.decode(stream);
        }
        if (isNaN(res)) {
            throw new Error('Not a fixed size');
        }
        return res;
    };
    PropertyDescriptor = function () {
        function PropertyDescriptor(opts) {
            var key, val;
            if (opts == null) {
                opts = {};
            }
            this.enumerable = true;
            this.configurable = true;
            for (key in opts) {
                val = opts[key];
                this[key] = val;
            }
        }
        return PropertyDescriptor;
    }();
    exports.PropertyDescriptor = PropertyDescriptor;
}.call(this));
},{"./Number":210}],218:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

module.exports = Stream;

var EE = require('events').EventEmitter;
var inherits = require('inherits');

inherits(Stream, EE);
Stream.Readable = require('readable-stream/readable.js');
Stream.Writable = require('readable-stream/writable.js');
Stream.Duplex = require('readable-stream/duplex.js');
Stream.Transform = require('readable-stream/transform.js');
Stream.PassThrough = require('readable-stream/passthrough.js');

// Backwards-compat with node 0.4.x
Stream.Stream = Stream;



// old-style streams.  Note that the pipe method (the only relevant
// part of this class) is overridden in the Readable class.

function Stream() {
  EE.call(this);
}

Stream.prototype.pipe = function(dest, options) {
  var source = this;

  function ondata(chunk) {
    if (dest.writable) {
      if (false === dest.write(chunk) && source.pause) {
        source.pause();
      }
    }
  }

  source.on('data', ondata);

  function ondrain() {
    if (source.readable && source.resume) {
      source.resume();
    }
  }

  dest.on('drain', ondrain);

  // If the 'end' option is not supplied, dest.end() will be called when
  // source gets the 'end' or 'close' events.  Only dest.end() once.
  if (!dest._isStdio && (!options || options.end !== false)) {
    source.on('end', onend);
    source.on('close', onclose);
  }

  var didOnEnd = false;
  function onend() {
    if (didOnEnd) return;
    didOnEnd = true;

    dest.end();
  }


  function onclose() {
    if (didOnEnd) return;
    didOnEnd = true;

    if (typeof dest.destroy === 'function') dest.destroy();
  }

  // don't leave dangling pipes when there are errors.
  function onerror(er) {
    cleanup();
    if (EE.listenerCount(this, 'error') === 0) {
      throw er; // Unhandled stream error in pipe.
    }
  }

  source.on('error', onerror);
  dest.on('error', onerror);

  // remove all the event listeners that were added.
  function cleanup() {
    source.removeListener('data', ondata);
    dest.removeListener('drain', ondrain);

    source.removeListener('end', onend);
    source.removeListener('close', onclose);

    source.removeListener('error', onerror);
    dest.removeListener('error', onerror);

    source.removeListener('end', cleanup);
    source.removeListener('close', cleanup);

    dest.removeListener('close', cleanup);
  }

  source.on('end', cleanup);
  source.on('close', cleanup);

  dest.on('close', cleanup);

  dest.emit('pipe', source);

  // Allow for unix-like usage: A.pipe(B).pipe(C)
  return dest;
};

},{"events":164,"inherits":170,"readable-stream/duplex.js":182,"readable-stream/passthrough.js":193,"readable-stream/readable.js":194,"readable-stream/transform.js":195,"readable-stream/writable.js":196}],219:[function(require,module,exports){
(function (setImmediate,clearImmediate){
var nextTick = require('process/browser.js').nextTick;
var apply = Function.prototype.apply;
var slice = Array.prototype.slice;
var immediateIds = {};
var nextImmediateId = 0;

// DOM APIs, for completeness

exports.setTimeout = function() {
  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
};
exports.setInterval = function() {
  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
};
exports.clearTimeout =
exports.clearInterval = function(timeout) { timeout.close(); };

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}
Timeout.prototype.unref = Timeout.prototype.ref = function() {};
Timeout.prototype.close = function() {
  this._clearFn.call(window, this._id);
};

// Does not start the time, just sets up the members needed.
exports.enroll = function(item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function(item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function(item) {
  clearTimeout(item._idleTimeoutId);

  var msecs = item._idleTimeout;
  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout)
        item._onTimeout();
    }, msecs);
  }
};

// That's not how node.js implements it but the exposed api is the same.
exports.setImmediate = typeof setImmediate === "function" ? setImmediate : function(fn) {
  var id = nextImmediateId++;
  var args = arguments.length < 2 ? false : slice.call(arguments, 1);

  immediateIds[id] = true;

  nextTick(function onNextTick() {
    if (immediateIds[id]) {
      // fn.call() is faster so we optimize for the common use-case
      // @see http://jsperf.com/call-apply-segu
      if (args) {
        fn.apply(null, args);
      } else {
        fn.call(null);
      }
      // Prevent ids from leaking
      exports.clearImmediate(id);
    }
  });

  return id;
};

exports.clearImmediate = typeof clearImmediate === "function" ? clearImmediate : function(id) {
  delete immediateIds[id];
};
}).call(this,require("timers").setImmediate,require("timers").clearImmediate)
},{"process/browser.js":181,"timers":219}],220:[function(require,module,exports){
var TINF_OK = 0;
var TINF_DATA_ERROR = -3;

function Tree() {
  this.table = new Uint16Array(16);   /* table of code length counts */
  this.trans = new Uint16Array(288);  /* code -> symbol translation table */
}

function Data(source, dest) {
  this.source = source;
  this.sourceIndex = 0;
  this.tag = 0;
  this.bitcount = 0;
  
  this.dest = dest;
  this.destLen = 0;
  
  this.ltree = new Tree();  /* dynamic length/symbol tree */
  this.dtree = new Tree();  /* dynamic distance tree */
}

/* --------------------------------------------------- *
 * -- uninitialized global data (static structures) -- *
 * --------------------------------------------------- */

var sltree = new Tree();
var sdtree = new Tree();

/* extra bits and base tables for length codes */
var length_bits = new Uint8Array(30);
var length_base = new Uint16Array(30);

/* extra bits and base tables for distance codes */
var dist_bits = new Uint8Array(30);
var dist_base = new Uint16Array(30);

/* special ordering of code length codes */
var clcidx = new Uint8Array([
  16, 17, 18, 0, 8, 7, 9, 6,
  10, 5, 11, 4, 12, 3, 13, 2,
  14, 1, 15
]);

/* used by tinf_decode_trees, avoids allocations every call */
var code_tree = new Tree();
var lengths = new Uint8Array(288 + 32);

/* ----------------------- *
 * -- utility functions -- *
 * ----------------------- */

/* build extra bits and base tables */
function tinf_build_bits_base(bits, base, delta, first) {
  var i, sum;

  /* build bits table */
  for (i = 0; i < delta; ++i) bits[i] = 0;
  for (i = 0; i < 30 - delta; ++i) bits[i + delta] = i / delta | 0;

  /* build base table */
  for (sum = first, i = 0; i < 30; ++i) {
    base[i] = sum;
    sum += 1 << bits[i];
  }
}

/* build the fixed huffman trees */
function tinf_build_fixed_trees(lt, dt) {
  var i;

  /* build fixed length tree */
  for (i = 0; i < 7; ++i) lt.table[i] = 0;

  lt.table[7] = 24;
  lt.table[8] = 152;
  lt.table[9] = 112;

  for (i = 0; i < 24; ++i) lt.trans[i] = 256 + i;
  for (i = 0; i < 144; ++i) lt.trans[24 + i] = i;
  for (i = 0; i < 8; ++i) lt.trans[24 + 144 + i] = 280 + i;
  for (i = 0; i < 112; ++i) lt.trans[24 + 144 + 8 + i] = 144 + i;

  /* build fixed distance tree */
  for (i = 0; i < 5; ++i) dt.table[i] = 0;

  dt.table[5] = 32;

  for (i = 0; i < 32; ++i) dt.trans[i] = i;
}

/* given an array of code lengths, build a tree */
var offs = new Uint16Array(16);

function tinf_build_tree(t, lengths, off, num) {
  var i, sum;

  /* clear code length count table */
  for (i = 0; i < 16; ++i) t.table[i] = 0;

  /* scan symbol lengths, and sum code length counts */
  for (i = 0; i < num; ++i) t.table[lengths[off + i]]++;

  t.table[0] = 0;

  /* compute offset table for distribution sort */
  for (sum = 0, i = 0; i < 16; ++i) {
    offs[i] = sum;
    sum += t.table[i];
  }

  /* create code->symbol translation table (symbols sorted by code) */
  for (i = 0; i < num; ++i) {
    if (lengths[off + i]) t.trans[offs[lengths[off + i]]++] = i;
  }
}

/* ---------------------- *
 * -- decode functions -- *
 * ---------------------- */

/* get one bit from source stream */
function tinf_getbit(d) {
  /* check if tag is empty */
  if (!d.bitcount--) {
    /* load next tag */
    d.tag = d.source[d.sourceIndex++];
    d.bitcount = 7;
  }

  /* shift bit out of tag */
  var bit = d.tag & 1;
  d.tag >>>= 1;

  return bit;
}

/* read a num bit value from a stream and add base */
function tinf_read_bits(d, num, base) {
  if (!num)
    return base;

  while (d.bitcount < 24) {
    d.tag |= d.source[d.sourceIndex++] << d.bitcount;
    d.bitcount += 8;
  }

  var val = d.tag & (0xffff >>> (16 - num));
  d.tag >>>= num;
  d.bitcount -= num;
  return val + base;
}

/* given a data stream and a tree, decode a symbol */
function tinf_decode_symbol(d, t) {
  while (d.bitcount < 24) {
    d.tag |= d.source[d.sourceIndex++] << d.bitcount;
    d.bitcount += 8;
  }
  
  var sum = 0, cur = 0, len = 0;
  var tag = d.tag;

  /* get more bits while code value is above sum */
  do {
    cur = 2 * cur + (tag & 1);
    tag >>>= 1;
    ++len;

    sum += t.table[len];
    cur -= t.table[len];
  } while (cur >= 0);
  
  d.tag = tag;
  d.bitcount -= len;

  return t.trans[sum + cur];
}

/* given a data stream, decode dynamic trees from it */
function tinf_decode_trees(d, lt, dt) {
  var hlit, hdist, hclen;
  var i, num, length;

  /* get 5 bits HLIT (257-286) */
  hlit = tinf_read_bits(d, 5, 257);

  /* get 5 bits HDIST (1-32) */
  hdist = tinf_read_bits(d, 5, 1);

  /* get 4 bits HCLEN (4-19) */
  hclen = tinf_read_bits(d, 4, 4);

  for (i = 0; i < 19; ++i) lengths[i] = 0;

  /* read code lengths for code length alphabet */
  for (i = 0; i < hclen; ++i) {
    /* get 3 bits code length (0-7) */
    var clen = tinf_read_bits(d, 3, 0);
    lengths[clcidx[i]] = clen;
  }

  /* build code length tree */
  tinf_build_tree(code_tree, lengths, 0, 19);

  /* decode code lengths for the dynamic trees */
  for (num = 0; num < hlit + hdist;) {
    var sym = tinf_decode_symbol(d, code_tree);

    switch (sym) {
      case 16:
        /* copy previous code length 3-6 times (read 2 bits) */
        var prev = lengths[num - 1];
        for (length = tinf_read_bits(d, 2, 3); length; --length) {
          lengths[num++] = prev;
        }
        break;
      case 17:
        /* repeat code length 0 for 3-10 times (read 3 bits) */
        for (length = tinf_read_bits(d, 3, 3); length; --length) {
          lengths[num++] = 0;
        }
        break;
      case 18:
        /* repeat code length 0 for 11-138 times (read 7 bits) */
        for (length = tinf_read_bits(d, 7, 11); length; --length) {
          lengths[num++] = 0;
        }
        break;
      default:
        /* values 0-15 represent the actual code lengths */
        lengths[num++] = sym;
        break;
    }
  }

  /* build dynamic trees */
  tinf_build_tree(lt, lengths, 0, hlit);
  tinf_build_tree(dt, lengths, hlit, hdist);
}

/* ----------------------------- *
 * -- block inflate functions -- *
 * ----------------------------- */

/* given a stream and two trees, inflate a block of data */
function tinf_inflate_block_data(d, lt, dt) {
  while (1) {
    var sym = tinf_decode_symbol(d, lt);

    /* check for end of block */
    if (sym === 256) {
      return TINF_OK;
    }

    if (sym < 256) {
      d.dest[d.destLen++] = sym;
    } else {
      var length, dist, offs;
      var i;

      sym -= 257;

      /* possibly get more bits from length code */
      length = tinf_read_bits(d, length_bits[sym], length_base[sym]);

      dist = tinf_decode_symbol(d, dt);

      /* possibly get more bits from distance code */
      offs = d.destLen - tinf_read_bits(d, dist_bits[dist], dist_base[dist]);

      /* copy match */
      for (i = offs; i < offs + length; ++i) {
        d.dest[d.destLen++] = d.dest[i];
      }
    }
  }
}

/* inflate an uncompressed block of data */
function tinf_inflate_uncompressed_block(d) {
  var length, invlength;
  var i;
  
  /* unread from bitbuffer */
  while (d.bitcount > 8) {
    d.sourceIndex--;
    d.bitcount -= 8;
  }

  /* get length */
  length = d.source[d.sourceIndex + 1];
  length = 256 * length + d.source[d.sourceIndex];

  /* get one's complement of length */
  invlength = d.source[d.sourceIndex + 3];
  invlength = 256 * invlength + d.source[d.sourceIndex + 2];

  /* check length */
  if (length !== (~invlength & 0x0000ffff))
    return TINF_DATA_ERROR;

  d.sourceIndex += 4;

  /* copy block */
  for (i = length; i; --i)
    d.dest[d.destLen++] = d.source[d.sourceIndex++];

  /* make sure we start next block on a byte boundary */
  d.bitcount = 0;

  return TINF_OK;
}

/* inflate stream from source to dest */
function tinf_uncompress(source, dest) {
  var d = new Data(source, dest);
  var bfinal, btype, res;

  do {
    /* read final block flag */
    bfinal = tinf_getbit(d);

    /* read block type (2 bits) */
    btype = tinf_read_bits(d, 2, 0);

    /* decompress block */
    switch (btype) {
      case 0:
        /* decompress uncompressed block */
        res = tinf_inflate_uncompressed_block(d);
        break;
      case 1:
        /* decompress block with fixed huffman trees */
        res = tinf_inflate_block_data(d, sltree, sdtree);
        break;
      case 2:
        /* decompress block with dynamic huffman trees */
        tinf_decode_trees(d, d.ltree, d.dtree);
        res = tinf_inflate_block_data(d, d.ltree, d.dtree);
        break;
      default:
        res = TINF_DATA_ERROR;
    }

    if (res !== TINF_OK)
      throw new Error('Data error');

  } while (!bfinal);

  if (d.destLen < d.dest.length) {
    if (typeof d.dest.slice === 'function')
      return d.dest.slice(0, d.destLen);
    else
      return d.dest.subarray(0, d.destLen);
  }
  
  return d.dest;
}

/* -------------------- *
 * -- initialization -- *
 * -------------------- */

/* build fixed huffman trees */
tinf_build_fixed_trees(sltree, sdtree);

/* build extra bits and base tables */
tinf_build_bits_base(length_bits, length_base, 4, 3);
tinf_build_bits_base(dist_bits, dist_base, 2, 1);

/* fix a special case */
length_bits[28] = 0;
length_base[28] = 258;

module.exports = tinf_uncompress;

},{}],221:[function(require,module,exports){
const inflate = require('tiny-inflate');

// Shift size for getting the index-1 table offset.
const SHIFT_1 = 6 + 5;

// Shift size for getting the index-2 table offset.
const SHIFT_2 = 5;

// Difference between the two shift sizes,
// for getting an index-1 offset from an index-2 offset. 6=11-5
const SHIFT_1_2 = SHIFT_1 - SHIFT_2;

// Number of index-1 entries for the BMP. 32=0x20
// This part of the index-1 table is omitted from the serialized form.
const OMITTED_BMP_INDEX_1_LENGTH = 0x10000 >> SHIFT_1;

// Number of entries in an index-2 block. 64=0x40
const INDEX_2_BLOCK_LENGTH = 1 << SHIFT_1_2;

// Mask for getting the lower bits for the in-index-2-block offset. */
const INDEX_2_MASK = INDEX_2_BLOCK_LENGTH - 1;

// Shift size for shifting left the index array values.
// Increases possible data size with 16-bit index values at the cost
// of compactability.
// This requires data blocks to be aligned by DATA_GRANULARITY.
const INDEX_SHIFT = 2;

// Number of entries in a data block. 32=0x20
const DATA_BLOCK_LENGTH = 1 << SHIFT_2;

// Mask for getting the lower bits for the in-data-block offset.
const DATA_MASK = DATA_BLOCK_LENGTH - 1;

// The part of the index-2 table for U+D800..U+DBFF stores values for
// lead surrogate code _units_ not code _points_.
// Values for lead surrogate code _points_ are indexed with this portion of the table.
// Length=32=0x20=0x400>>SHIFT_2. (There are 1024=0x400 lead surrogates.)
const LSCP_INDEX_2_OFFSET = 0x10000 >> SHIFT_2;
const LSCP_INDEX_2_LENGTH = 0x400 >> SHIFT_2;

// Count the lengths of both BMP pieces. 2080=0x820
const INDEX_2_BMP_LENGTH = LSCP_INDEX_2_OFFSET + LSCP_INDEX_2_LENGTH;

// The 2-byte UTF-8 version of the index-2 table follows at offset 2080=0x820.
// Length 32=0x20 for lead bytes C0..DF, regardless of SHIFT_2.
const UTF8_2B_INDEX_2_OFFSET = INDEX_2_BMP_LENGTH;
const UTF8_2B_INDEX_2_LENGTH = 0x800 >> 6;  // U+0800 is the first code point after 2-byte UTF-8

// The index-1 table, only used for supplementary code points, at offset 2112=0x840.
// Variable length, for code points up to highStart, where the last single-value range starts.
// Maximum length 512=0x200=0x100000>>SHIFT_1.
// (For 0x100000 supplementary code points U+10000..U+10ffff.)
//
// The part of the index-2 table for supplementary code points starts
// after this index-1 table.
//
// Both the index-1 table and the following part of the index-2 table
// are omitted completely if there is only BMP data.
const INDEX_1_OFFSET = UTF8_2B_INDEX_2_OFFSET + UTF8_2B_INDEX_2_LENGTH;

// The alignment size of a data block. Also the granularity for compaction.
const DATA_GRANULARITY = 1 << INDEX_SHIFT;

class UnicodeTrie {
  constructor(data) {
    const isBuffer = (typeof data.readUInt32BE === 'function') && (typeof data.slice === 'function');

    if (isBuffer || data instanceof Uint8Array) {
      // read binary format
      let uncompressedLength;
      if (isBuffer) {
        this.highStart = data.readUInt32BE(0);
        this.errorValue = data.readUInt32BE(4);
        uncompressedLength = data.readUInt32BE(8);
        data = data.slice(12);
      } else {
        const view = new DataView(data.buffer);
        this.highStart = view.getUint32(0);
        this.errorValue = view.getUint32(4);
        uncompressedLength = view.getUint32(8);
        data = data.subarray(12);
      }

      // double inflate the actual trie data
      data = inflate(data, new Uint8Array(uncompressedLength));
      data = inflate(data, new Uint8Array(uncompressedLength));
      this.data = new Uint32Array(data.buffer);

    } else {
      // pre-parsed data
      ({ data: this.data, highStart: this.highStart, errorValue: this.errorValue } = data);
    }
  }

  get(codePoint) {
    let index;
    if ((codePoint < 0) || (codePoint > 0x10ffff)) {
      return this.errorValue;
    }

    if ((codePoint < 0xd800) || ((codePoint > 0xdbff) && (codePoint <= 0xffff))) {
      // Ordinary BMP code point, excluding leading surrogates.
      // BMP uses a single level lookup.  BMP index starts at offset 0 in the index.
      // data is stored in the index array itself.
      index = (this.data[codePoint >> SHIFT_2] << INDEX_SHIFT) + (codePoint & DATA_MASK);
      return this.data[index];
    }

    if (codePoint <= 0xffff) {
      // Lead Surrogate Code Point.  A Separate index section is stored for
      // lead surrogate code units and code points.
      //   The main index has the code unit data.
      //   For this function, we need the code point data.
      index = (this.data[LSCP_INDEX_2_OFFSET + ((codePoint - 0xd800) >> SHIFT_2)] << INDEX_SHIFT) + (codePoint & DATA_MASK);
      return this.data[index];
    }

    if (codePoint < this.highStart) {
      // Supplemental code point, use two-level lookup.
      index = this.data[(INDEX_1_OFFSET - OMITTED_BMP_INDEX_1_LENGTH) + (codePoint >> SHIFT_1)];
      index = this.data[index + ((codePoint >> SHIFT_2) & INDEX_2_MASK)];
      index = (index << INDEX_SHIFT) + (codePoint & DATA_MASK);
      return this.data[index];
    }

    return this.data[this.data.length - DATA_GRANULARITY];
  }
}

module.exports = UnicodeTrie;
},{"tiny-inflate":220}],222:[function(require,module,exports){
'use strict';

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var UnicodeTrie = _interopDefault(require('unicode-trie'));
var base64 = _interopDefault(require('base64-js'));

var categories=["Cc","Zs","Po","Sc","Ps","Pe","Sm","Pd","Nd","Lu","Sk","Pc","Ll","So","Lo","Pi","Cf","No","Pf","Lt","Lm","Mn","Me","Mc","Nl","Zl","Zp","Cs","Co"];var combiningClasses=["Not_Reordered","Above","Above_Right","Below","Attached_Above_Right","Attached_Below","Overlay","Iota_Subscript","Double_Below","Double_Above","Below_Right","Above_Left","CCC10","CCC11","CCC12","CCC13","CCC14","CCC15","CCC16","CCC17","CCC18","CCC19","CCC20","CCC21","CCC22","CCC23","CCC24","CCC25","CCC30","CCC31","CCC32","CCC27","CCC28","CCC29","CCC33","CCC34","CCC35","CCC36","Nukta","Virama","CCC84","CCC91","CCC103","CCC107","CCC118","CCC122","CCC129","CCC130","CCC132","Attached_Above","Below_Left","Left","Kana_Voicing","CCC26","Right"];var scripts=["Common","Latin","Bopomofo","Inherited","Greek","Coptic","Cyrillic","Armenian","Hebrew","Arabic","Syriac","Thaana","Nko","Samaritan","Mandaic","Devanagari","Bengali","Gurmukhi","Gujarati","Oriya","Tamil","Telugu","Kannada","Malayalam","Sinhala","Thai","Lao","Tibetan","Myanmar","Georgian","Hangul","Ethiopic","Cherokee","Canadian_Aboriginal","Ogham","Runic","Tagalog","Hanunoo","Buhid","Tagbanwa","Khmer","Mongolian","Limbu","Tai_Le","New_Tai_Lue","Buginese","Tai_Tham","Balinese","Sundanese","Batak","Lepcha","Ol_Chiki","Braille","Glagolitic","Tifinagh","Han","Hiragana","Katakana","Yi","Lisu","Vai","Bamum","Syloti_Nagri","Phags_Pa","Saurashtra","Kayah_Li","Rejang","Javanese","Cham","Tai_Viet","Meetei_Mayek","null","Linear_B","Lycian","Carian","Old_Italic","Gothic","Old_Permic","Ugaritic","Old_Persian","Deseret","Shavian","Osmanya","Elbasan","Caucasian_Albanian","Linear_A","Cypriot","Imperial_Aramaic","Palmyrene","Nabataean","Hatran","Phoenician","Lydian","Meroitic_Hieroglyphs","Meroitic_Cursive","Kharoshthi","Old_South_Arabian","Old_North_Arabian","Manichaean","Avestan","Inscriptional_Parthian","Inscriptional_Pahlavi","Psalter_Pahlavi","Old_Turkic","Old_Hungarian","Brahmi","Kaithi","Sora_Sompeng","Chakma","Mahajani","Sharada","Khojki","Multani","Khudawadi","Grantha","Tirhuta","Siddham","Modi","Takri","Ahom","Warang_Citi","Pau_Cin_Hau","Cuneiform","Egyptian_Hieroglyphs","Anatolian_Hieroglyphs","Mro","Bassa_Vah","Pahawh_Hmong","Miao","Duployan","SignWriting","Mende_Kikakui"];var eaw=["N","Na","A","W","H","F"];var data = {categories:categories,combiningClasses:combiningClasses,scripts:scripts,eaw:eaw};

var data$1="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";var trieData = {data:data$1};

var log2 = Math.log2 || (n => Math.log(n) / Math.LN2);

var bits = n => log2(n) + 1 | 0;

var buildUnicodeProperties = (data, trie) => {
  // compute the number of bits stored for each field
  var CATEGORY_BITS = bits(data.categories.length - 1);
  var COMBINING_BITS = bits(data.combiningClasses.length - 1);
  var SCRIPT_BITS = bits(data.scripts.length - 1);
  var EAW_BITS = bits(data.eaw.length - 1);
  var NUMBER_BITS = 10; // compute shift and mask values for each field

  var CATEGORY_SHIFT = COMBINING_BITS + SCRIPT_BITS + EAW_BITS + NUMBER_BITS;
  var COMBINING_SHIFT = SCRIPT_BITS + EAW_BITS + NUMBER_BITS;
  var SCRIPT_SHIFT = EAW_BITS + NUMBER_BITS;
  var EAW_SHIFT = NUMBER_BITS;
  var CATEGORY_MASK = (1 << CATEGORY_BITS) - 1;
  var COMBINING_MASK = (1 << COMBINING_BITS) - 1;
  var SCRIPT_MASK = (1 << SCRIPT_BITS) - 1;
  var EAW_MASK = (1 << EAW_BITS) - 1;
  var NUMBER_MASK = (1 << NUMBER_BITS) - 1;

  var getCategory = codePoint => {
    var val = trie.get(codePoint);
    return data.categories[val >> CATEGORY_SHIFT & CATEGORY_MASK];
  };

  var getCombiningClass = codePoint => {
    var val = trie.get(codePoint);
    return data.combiningClasses[val >> COMBINING_SHIFT & COMBINING_MASK];
  };

  var getScript = codePoint => {
    var val = trie.get(codePoint);
    return data.scripts[val >> SCRIPT_SHIFT & SCRIPT_MASK];
  };

  var getEastAsianWidth = codePoint => {
    var val = trie.get(codePoint);
    return data.eaw[val >> EAW_SHIFT & EAW_MASK];
  };

  var getNumericValue = codePoint => {
    var val = trie.get(codePoint);
    var num = val & NUMBER_MASK;

    if (num === 0) {
      return null;
    } else if (num <= 50) {
      return num - 1;
    } else if (num < 0x1e0) {
      var numerator = (num >> 4) - 12;
      var denominator = (num & 0xf) + 1;
      return numerator / denominator;
    } else if (num < 0x300) {
      val = (num >> 5) - 14;
      var exp = (num & 0x1f) + 2;

      while (exp > 0) {
        val *= 10;
        exp--;
      }

      return val;
    } else {
      val = (num >> 2) - 0xbf;

      var _exp = (num & 3) + 1;

      while (_exp > 0) {
        val *= 60;
        _exp--;
      }

      return val;
    }
  };

  var isAlphabetic = codePoint => {
    var category = getCategory(codePoint);
    return category === 'Lu' || category === 'Ll' || category === 'Lt' || category === 'Lm' || category === 'Lo' || category === 'Nl';
  };

  var isDigit = codePoint => getCategory(codePoint) === 'Nd';

  var isPunctuation = codePoint => {
    var category = getCategory(codePoint);
    return category === 'Pc' || category === 'Pd' || category === 'Pe' || category === 'Pf' || category === 'Pi' || category === 'Po' || category === 'Ps';
  };

  var isLowerCase = codePoint => {
    return getCategory(codePoint) === 'Ll';
  };

  var isUpperCase = codePoint => getCategory(codePoint) === 'Lu';

  var isTitleCase = codePoint => getCategory(codePoint) === 'Lt';

  var isWhiteSpace = codePoint => {
    var category = getCategory(codePoint);
    return category === 'Zs' || category === 'Zl' || category === 'Zp';
  };

  var isBaseForm = codePoint => {
    var category = getCategory(codePoint);
    return category === 'Nd' || category === 'No' || category === 'Nl' || category === 'Lu' || category === 'Ll' || category === 'Lt' || category === 'Lm' || category === 'Lo' || category === 'Me' || category === 'Mc';
  };

  var isMark = codePoint => {
    var category = getCategory(codePoint);
    return category === 'Mn' || category === 'Me' || category === 'Mc';
  };

  return {
    getCategory,
    getCombiningClass,
    getScript,
    getEastAsianWidth,
    getNumericValue,
    isAlphabetic,
    isDigit,
    isPunctuation,
    isLowerCase,
    isUpperCase,
    isTitleCase,
    isWhiteSpace,
    isBaseForm,
    isMark
  };
};

var trie = new UnicodeTrie(base64.toByteArray(trieData.data));
var unicodeProperties = buildUnicodeProperties(data, trie);

module.exports = unicodeProperties;


},{"base64-js":22,"unicode-trie":221}],223:[function(require,module,exports){
// Generated by CoffeeScript 1.7.1
var UnicodeTrie, inflate;

inflate = require('tiny-inflate');

UnicodeTrie = (function() {
  var DATA_BLOCK_LENGTH, DATA_GRANULARITY, DATA_MASK, INDEX_1_OFFSET, INDEX_2_BLOCK_LENGTH, INDEX_2_BMP_LENGTH, INDEX_2_MASK, INDEX_SHIFT, LSCP_INDEX_2_LENGTH, LSCP_INDEX_2_OFFSET, OMITTED_BMP_INDEX_1_LENGTH, SHIFT_1, SHIFT_1_2, SHIFT_2, UTF8_2B_INDEX_2_LENGTH, UTF8_2B_INDEX_2_OFFSET;

  SHIFT_1 = 6 + 5;

  SHIFT_2 = 5;

  SHIFT_1_2 = SHIFT_1 - SHIFT_2;

  OMITTED_BMP_INDEX_1_LENGTH = 0x10000 >> SHIFT_1;

  INDEX_2_BLOCK_LENGTH = 1 << SHIFT_1_2;

  INDEX_2_MASK = INDEX_2_BLOCK_LENGTH - 1;

  INDEX_SHIFT = 2;

  DATA_BLOCK_LENGTH = 1 << SHIFT_2;

  DATA_MASK = DATA_BLOCK_LENGTH - 1;

  LSCP_INDEX_2_OFFSET = 0x10000 >> SHIFT_2;

  LSCP_INDEX_2_LENGTH = 0x400 >> SHIFT_2;

  INDEX_2_BMP_LENGTH = LSCP_INDEX_2_OFFSET + LSCP_INDEX_2_LENGTH;

  UTF8_2B_INDEX_2_OFFSET = INDEX_2_BMP_LENGTH;

  UTF8_2B_INDEX_2_LENGTH = 0x800 >> 6;

  INDEX_1_OFFSET = UTF8_2B_INDEX_2_OFFSET + UTF8_2B_INDEX_2_LENGTH;

  DATA_GRANULARITY = 1 << INDEX_SHIFT;

  function UnicodeTrie(data) {
    var isBuffer, uncompressedLength, view;
    isBuffer = typeof data.readUInt32BE === 'function' && typeof data.slice === 'function';
    if (isBuffer || data instanceof Uint8Array) {
      if (isBuffer) {
        this.highStart = data.readUInt32BE(0);
        this.errorValue = data.readUInt32BE(4);
        uncompressedLength = data.readUInt32BE(8);
        data = data.slice(12);
      } else {
        view = new DataView(data.buffer);
        this.highStart = view.getUint32(0);
        this.errorValue = view.getUint32(4);
        uncompressedLength = view.getUint32(8);
        data = data.subarray(12);
      }
      data = inflate(data, new Uint8Array(uncompressedLength));
      data = inflate(data, new Uint8Array(uncompressedLength));
      this.data = new Uint32Array(data.buffer);
    } else {
      this.data = data.data, this.highStart = data.highStart, this.errorValue = data.errorValue;
    }
  }

  UnicodeTrie.prototype.get = function(codePoint) {
    var index;
    if (codePoint < 0 || codePoint > 0x10ffff) {
      return this.errorValue;
    }
    if (codePoint < 0xd800 || (codePoint > 0xdbff && codePoint <= 0xffff)) {
      index = (this.data[codePoint >> SHIFT_2] << INDEX_SHIFT) + (codePoint & DATA_MASK);
      return this.data[index];
    }
    if (codePoint <= 0xffff) {
      index = (this.data[LSCP_INDEX_2_OFFSET + ((codePoint - 0xd800) >> SHIFT_2)] << INDEX_SHIFT) + (codePoint & DATA_MASK);
      return this.data[index];
    }
    if (codePoint < this.highStart) {
      index = this.data[(INDEX_1_OFFSET - OMITTED_BMP_INDEX_1_LENGTH) + (codePoint >> SHIFT_1)];
      index = this.data[index + ((codePoint >> SHIFT_2) & INDEX_2_MASK)];
      index = (index << INDEX_SHIFT) + (codePoint & DATA_MASK);
      return this.data[index];
    }
    return this.data[this.data.length - DATA_GRANULARITY];
  };

  return UnicodeTrie;

})();

module.exports = UnicodeTrie;

},{"tiny-inflate":220}],224:[function(require,module,exports){
(function (global){

/**
 * Module exports.
 */

module.exports = deprecate;

/**
 * Mark that a method should not be used.
 * Returns a modified function which warns once by default.
 *
 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
 *
 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
 * will throw an Error when invoked.
 *
 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
 * will invoke `console.trace()` instead of `console.error()`.
 *
 * @param {Function} fn - the function to deprecate
 * @param {String} msg - the string to print to the console when `fn` is invoked
 * @returns {Function} a new "deprecated" version of `fn`
 * @api public
 */

function deprecate (fn, msg) {
  if (config('noDeprecation')) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (config('throwDeprecation')) {
        throw new Error(msg);
      } else if (config('traceDeprecation')) {
        console.trace(msg);
      } else {
        console.warn(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
}

/**
 * Checks `localStorage` for boolean values for the given `name`.
 *
 * @param {String} name
 * @returns {Boolean}
 * @api private
 */

function config (name) {
  // accessing global.localStorage can trigger a DOMException in sandboxed iframes
  try {
    if (!global.localStorage) return false;
  } catch (_) {
    return false;
  }
  var val = global.localStorage[name];
  if (null == val) return false;
  return String(val).toLowerCase() === 'true';
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],225:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],226:[function(require,module,exports){
module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}
},{}],227:[function(require,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(global.process)) {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (process.noDeprecation === true) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = require('./support/isBuffer');

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = require('inherits');

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./support/isBuffer":226,"_process":181,"inherits":225}],228:[function(require,module,exports){
"use strict";

var _fontkit = require("fontkit");

var _fontkit2 = _interopRequireDefault(_fontkit);

var _blobToBuffer = require("blob-to-buffer");

var _blobToBuffer2 = _interopRequireDefault(_blobToBuffer);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Copyright 2019 Google LLC

// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at

//     https://www.apache.org/licenses/LICENSE-2.0

// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var activateFonts = document.querySelector("#activateFonts");
var showFonts = document.querySelector("#showFonts");
var addFont = document.querySelector("#addFont");
var showBlacklist = document.querySelector("#showBlacklist");
var fullReset = document.querySelector(".full-reset");
var localFonts = {};

fullReset.onclick = function () {
	if (window.confirm("Do you really want to reset Type-X?")) {
		chrome.runtime.getBackgroundPage(function (backgroundPage) {
			backgroundPage.updateFonts(false, true);
			setTimeout(function () {
				backgroundPage.initTypeX();
				chrome.runtime.reload();
			}, 100);
		});
	}
};

// Get current fonts from storage and show them in the popup
chrome.fontSettings.getFontList(function (fonts) {
	var _iteratorNormalCompletion = true;
	var _didIteratorError = false;
	var _iteratorError = undefined;

	try {
		for (var _iterator = fonts[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
			var font = _step.value;

			localFonts[font.displayName] = font.fontId;
		}
	} catch (err) {
		_didIteratorError = true;
		_iteratorError = err;
	} finally {
		try {
			if (!_iteratorNormalCompletion && _iterator.return) {
				_iterator.return();
			}
		} finally {
			if (_didIteratorError) {
				throw _iteratorError;
			}
		}
	}

	chrome.storage.local.get(["fonts", "files", "blacklist"], function (_ref) {
		var fonts = _ref.fonts,
		    files = _ref.files,
		    blacklist = _ref.blacklist;

		buildForm(fonts, files, blacklist);
	});
});

// Toggle extension on/off using the button
activateFonts.onclick = function () {
	chrome.storage.local.get("extensionActive", function (_ref2) {
		var extensionActive = _ref2.extensionActive;

		updateStatus(!extensionActive);
	});
};

// Show/hide font form
showFonts.onclick = function () {
	document.querySelector(".main-fonts").classList.toggle("show");
	document.querySelector("footer").classList.toggle("show");
	showFonts.classList.toggle("active");
};

// Show/hide blacklist
showBlacklist.onclick = function () {
	document.querySelector(".blacklist").classList.toggle("show");
};

// Add new font fieldset to form
addFont.onclick = function () {
	var randomId = window.crypto.getRandomValues(new Uint32Array(2)).join("");
	chrome.storage.local.get("files", function (_ref3) {
		var files = _ref3.files;

		var newFont = {
			new: true,
			id: randomId,
			file: Object.keys(files)[0],
			fallback: ["monospace"],
			selectors: ["/* Add CSS selectors here */"],
			css: "/* Additional styles to apply */"
		};

		addFormElement(newFont, files);
		saveForm();
	});
};

// Toggle extension on/off
function updateStatus(status, updatingCurrentTab) {
	chrome.storage.local.set({
		extensionActive: status
	}, function () {
		chrome.runtime.getBackgroundPage(function (backgroundPage) {
			backgroundPage.updateFonts(status, updatingCurrentTab);
		});
		showStatus();
	});
}

// Show status of extension in the popup
var showStatus = function showStatus(firstRun) {
	chrome.storage.local.get("extensionActive", function (_ref4) {
		var extensionActive = _ref4.extensionActive;

		chrome.browserAction.setIcon({
			path: "icons/typex-" + (extensionActive ? "active" : "off") + "@128.png"
		});
		activateFonts.classList.toggle("active", extensionActive);
		!firstRun && activateFonts.classList.remove("first-run");
	});
};

// Throttle updates
// Source: https://gist.github.com/beaucharman/e46b8e4d03ef30480d7f4db5a78498ca
var throttle = function throttle(fn, wait) {
	var previouslyRun = void 0,
	    queuedToRun = void 0;

	return function invokeFn() {
		var now = Date.now();

		queuedToRun = clearTimeout(queuedToRun);

		for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
			args[_key] = arguments[_key];
		}

		if (!previouslyRun || now - previouslyRun >= wait) {
			fn.apply(null, args);
			previouslyRun = now;
		} else {
			queuedToRun = setTimeout(invokeFn.bind.apply(invokeFn, [null].concat(args)), wait - (now - previouslyRun));
		}
	};
};

var throttledSaveForm = throttle(function () {
	saveForm();
}, 100);

// Initialise form
function initForm() {
	document.querySelector("#fontsForm").oninput = function () {
		throttledSaveForm();
	};
}

// Generate form based on current settings
function buildForm(fonts, files, blacklist) {
	var form = document.querySelector("#fontsForm");
	var usedFonts = form.querySelector("#usedFonts");
	var blacklistEl = form.querySelector("[name=blacklist]");

	// Clear out previous form
	while (usedFonts.firstChild) {
		usedFonts.removeChild(usedFonts.firstChild);
	}

	// Inject new fonts
	var _iteratorNormalCompletion2 = true;
	var _didIteratorError2 = false;
	var _iteratorError2 = undefined;

	try {
		for (var _iterator2 = fonts[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
			var font = _step2.value;

			addFormElement(font, files);
		}

		// Inject blacklist
	} catch (err) {
		_didIteratorError2 = true;
		_iteratorError2 = err;
	} finally {
		try {
			if (!_iteratorNormalCompletion2 && _iterator2.return) {
				_iterator2.return();
			}
		} finally {
			if (_didIteratorError2) {
				throw _iteratorError2;
			}
		}
	}

	blacklistEl.value = blacklist.join(", ");

	syncVariableValues();
}

// New file uploaded, append to all selects
function updateFontDropdowns(id, name) {
	var optgroups = document.querySelectorAll(".font-file-select optgroup:first-child");
	var _iteratorNormalCompletion3 = true;
	var _didIteratorError3 = false;
	var _iteratorError3 = undefined;

	try {
		for (var _iterator3 = optgroups[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
			var optgroup = _step3.value;

			var options = optgroup.querySelectorAll("option");
			var present = false;
			var _iteratorNormalCompletion4 = true;
			var _didIteratorError4 = false;
			var _iteratorError4 = undefined;

			try {
				for (var _iterator4 = options[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
					var _option = _step4.value;

					present = _option.value === name ? true : present;
				}
			} catch (err) {
				_didIteratorError4 = true;
				_iteratorError4 = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion4 && _iterator4.return) {
						_iterator4.return();
					}
				} finally {
					if (_didIteratorError4) {
						throw _iteratorError4;
					}
				}
			}

			if (present) {
				optgroup.value = name;
			} else {
				var option = document.createElement("option");
				option.value = id;
				option.text = name;
				optgroup.append(option);
			}
		}
	} catch (err) {
		_didIteratorError3 = true;
		_iteratorError3 = err;
	} finally {
		try {
			if (!_iteratorNormalCompletion3 && _iterator3.return) {
				_iterator3.return();
			}
		} finally {
			if (_didIteratorError3) {
				throw _iteratorError3;
			}
		}
	}
}

// Add new font to the form
function addFormElement(font, files) {
	var usedFonts = document.querySelector("#usedFonts");
	var template = document.querySelector("#newFont");
	var el = document.importNode(template.content, true);
	var parentEl = el.querySelector(".font");

	el.querySelector(".font-name-title").innerText = font.name || "New font override";

	var fontSelect = el.querySelector(".font-file-select");

	var dropdown = document.createElement("select");
	dropdown.setAttribute("name", "file");
	dropdown.setAttribute("id", "file" + font.id);
	dropdown.classList.add("font-file-select");
	dropdown.onchange = function (e) {
		var parent = e.target.closest(".font");
		var name = e.target.options[e.target.selectedIndex].text;
		var fileId = e.target.options[e.target.selectedIndex].value;
		parent.querySelector(".font-name-title").innerText = name;
		addVariableSliders(false, parent);
		addNamedInstances(false, parent);
		chrome.storage.local.get("files", function (_ref5) {
			var files = _ref5.files;

			for (var file in files) {
				if (file == fileId) {
					addVariableSliders(files[file].axes, parent);
					addNamedInstances(files[file].instances, parent);
				}
			}
			saveForm();
		});
	};

	var extensionGroup = document.createElement("optgroup");
	extensionGroup.setAttribute("label", "Custom fonts:");
	for (var id in files) {
		var option = document.createElement("option");
		option.value = id;
		option.text = files[id].name;
		option.selected = font.file == id;
		extensionGroup.append(option);
	}
	dropdown.append(extensionGroup);

	var localGroup = document.createElement("optgroup");
	localGroup.setAttribute("label", "Local fonts:");
	for (var _id in localFonts) {
		var _option2 = document.createElement("option");
		_option2.value = _id;
		_option2.text = _id;
		_option2.selected = font.file == _id;
		localGroup.append(_option2);
	}
	dropdown.append(localGroup);

	fontSelect.replaceWith(dropdown);

	el.querySelector("[name=newfile]").dataset.fontid = font.id;
	el.querySelector("[name=newfile]").onchange = grabFont;

	parentEl.dataset.fontid = font.id;
	el.querySelector("[name=id]").value = font.id;
	el.querySelector("[name=css]").value = font.css;
	el.querySelector("[name=fallback]").value = font.fallback;
	el.querySelector("[name=selectors]").value = font.selectors.join(", ");

	el.querySelector(".show-fallbacks").onclick = function (e) {
		e.target.closest("fieldset").classList.toggle("show-font-fallbacks");
	};

	el.querySelector(".delete-font").onclick = function (e) {
		e.target.closest("fieldset").remove();
		saveForm();
	};

	el.querySelector(".font-title button").onclick = function (e) {
		e.target.closest("fieldset").classList.toggle("show-font-details");
	};

	if (font.new) {
		el.querySelector("fieldset").classList.add("show-font-details");
	}

	// Add variable sliders
	var axes = false;
	if (font.axes) {
		axes = font.axes;
	} else if (font.file in files) {
		axes = files[font.file].axes;
	}
	addVariableSliders(axes, parentEl);

	// Add named variable instances
	var instances = false;
	if (font.instances) {
		instances = font.instances;
	} else if (font.file in files) {
		instances = files[font.file].instances;
	}
	addNamedInstances(instances, parentEl, font.inherit);

	parentEl.addEventListener("dragover", highlight, false);
	parentEl.addEventListener("dragleave", unhighlight, false);
	parentEl.addEventListener("drop", grabFont, false);

	usedFonts.prepend(el);
}

// Select named instance based on slider values
function syncVariableValues() {
	var containers = document.querySelectorAll(".font");
	var _iteratorNormalCompletion5 = true;
	var _didIteratorError5 = false;
	var _iteratorError5 = undefined;

	try {
		for (var _iterator5 = containers[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
			var container = _step5.value;

			var sliders = container.querySelectorAll(".variable-sliders [type=range]");

			if (!sliders.length) break;

			var customInstance = {};
			var _iteratorNormalCompletion6 = true;
			var _didIteratorError6 = false;
			var _iteratorError6 = undefined;

			try {
				for (var _iterator6 = sliders[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
					var slider = _step6.value;

					var name = slider.name.replace("var-", "");
					customInstance[name] = parseFloat(slider.value);
				}
			} catch (err) {
				_didIteratorError6 = true;
				_iteratorError6 = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion6 && _iterator6.return) {
						_iterator6.return();
					}
				} finally {
					if (_didIteratorError6) {
						throw _iteratorError6;
					}
				}
			}

			var ci = JSON.stringify(customInstance);

			var dropdown = container.querySelector(".select-instance");
			if (dropdown.value == "--inherit--") {
				container.querySelector(".variable-sliders-container").classList.add("mute");
				return;
			} else {
				container.querySelector(".variable-sliders-container").classList.remove("mute");
			}

			var options = dropdown.querySelectorAll("option");
			var sel = 1; // "--axes--"
			var _iteratorNormalCompletion7 = true;
			var _didIteratorError7 = false;
			var _iteratorError7 = undefined;

			try {
				for (var _iterator7 = options[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
					var option = _step7.value;

					if (option.dataset.instance == ci) {
						sel = option.index;
						break;
					}
				}
			} catch (err) {
				_didIteratorError7 = true;
				_iteratorError7 = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion7 && _iterator7.return) {
						_iterator7.return();
					}
				} finally {
					if (_didIteratorError7) {
						throw _iteratorError7;
					}
				}
			}

			dropdown.selectedIndex = sel;
		}
	} catch (err) {
		_didIteratorError5 = true;
		_iteratorError5 = err;
	} finally {
		try {
			if (!_iteratorNormalCompletion5 && _iterator5.return) {
				_iterator5.return();
			}
		} finally {
			if (_didIteratorError5) {
				throw _iteratorError5;
			}
		}
	}
}

function addNamedInstances(instances, el, inherit) {
	var container = el.querySelector(".variable-instances");
	container.innerHTML = "";

	if (instances) {
		// Create instances dropdown
		var dropdown = document.createElement("select");
		dropdown.classList.add("select-instance");
		dropdown.name = "select-instance";

		// Add "turn off font-variation-settings" option
		var option = document.createElement("option");
		option.text = "— Inherit page styles —";
		option.value = "--inherit--";
		dropdown.append(option);

		// Add "using axes, but none of a named instance" option
		var option2 = document.createElement("option");
		option2.text = "— Custom axes —";
		option2.value = "--axes--";
		option2.disabled = true;
		dropdown.append(option2);

		var _loop = function _loop(instance) {
			var option = document.createElement("option");
			option.text = instance;
			option.value = instance;

			var axes = instances[instance];
			var orderedAxes = {};
			Object.keys(axes).sort().forEach(function (key) {
				orderedAxes[key] = axes[key];
			});
			option.dataset.instance = JSON.stringify(orderedAxes);
			dropdown.append(option);
		};

		for (var instance in instances) {
			_loop(instance);
		}

		dropdown.oninput = applyNamedInstance;

		// If not explicitly set to inherit page styles,
		// do not select an option from the dropdown, so
		// syncVariableValues can do it for us
		if (!inherit) {
			dropdown.selectedIndex = -1;
		}
		container.append(dropdown);
	}
}

function applyNamedInstance(e) {
	var sel = e.target;

	if (sel.value == "--inherit--" || sel.value == "--axes--") {
		return;
	}

	var parent = e.target.closest(".font");
	var axes = JSON.parse(sel.options[sel.selectedIndex].dataset.instance);

	for (var axis in axes) {
		var slider = parent.querySelector("[name=var-" + axis + "]");
		slider.value = axes[axis];
		slider.dispatchEvent(new Event("input"));
	}
}

function addVariableSliders(axes, el) {
	var newAxes = {};
	el.querySelector(".variable-sliders").innerHTML = "";
	if (!axes) {
		el.querySelector(".variable-sliders-container").classList.remove("show");
	} else {
		var keys = Object.keys(axes).sort();
		for (var i = 0; i < keys.length; ++i) {
			var value = axes[keys[i]].value || axes[keys[i]].default || 0;
			var axis = {
				id: keys[i],
				name: axes[keys[i]].name,
				min: axes[keys[i]].min,
				max: axes[keys[i]].max,
				value: value
			};
			newAxes[keys[i]] = axis;

			addSlider(axis, el);
			el.querySelector(".variable-sliders-container").classList.add("show");
		}
	}
	// Return new object of axes. TODO: we could just use
	// the object Fontkit returns.
	return newAxes;
}

// Store changes made to fonts
// Note: files have already been stored at this point
function saveForm() {
	var newFonts = [];
	var form = document.querySelector("#fontsForm");
	var fieldsets = form.querySelectorAll("fieldset");

	// Get new fonts
	var _iteratorNormalCompletion8 = true;
	var _didIteratorError8 = false;
	var _iteratorError8 = undefined;

	try {
		for (var _iterator8 = fieldsets[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
			var fieldset = _step8.value;

			var newFont = {};
			var inputs = fieldset.querySelectorAll("*[name]");
			var _axes = {};
			var straightInputs = ["id", "css", "fallback"];

			var _iteratorNormalCompletion9 = true;
			var _didIteratorError9 = false;
			var _iteratorError9 = undefined;

			try {
				for (var _iterator9 = inputs[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {
					var input = _step9.value;

					if (input.name === "file") {
						newFont["name"] = input.options[input.selectedIndex].text;
						newFont["file"] = input.options[input.selectedIndex].value;
					} else if (input.name === "select-instance") {
						newFont["inherit"] = input.value === "--inherit--";
					} else if (straightInputs.includes(input.name)) {
						newFont[input.name] = input.value;
					} else if (input.name.startsWith("var-")) {
						var name = input.name.replace("var-", "");
						var axis = {
							id: name,
							name: input.dataset.name,
							min: input.min,
							max: input.max,
							value: input.value
						};
						_axes[name] = axis;
					} else if (input.name === "selectors") {
						// Selectors should become an array
						newFont["selectors"] = input.value.split(",").map(function (i) {
							return i.trim();
						});
					}
				}
			} catch (err) {
				_didIteratorError9 = true;
				_iteratorError9 = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion9 && _iterator9.return) {
						_iterator9.return();
					}
				} finally {
					if (_didIteratorError9) {
						throw _iteratorError9;
					}
				}
			}

			newFont.axes = _axes;
			newFonts.unshift(newFont);
		}

		// Get blacklist
	} catch (err) {
		_didIteratorError8 = true;
		_iteratorError8 = err;
	} finally {
		try {
			if (!_iteratorNormalCompletion8 && _iterator8.return) {
				_iterator8.return();
			}
		} finally {
			if (_didIteratorError8) {
				throw _iteratorError8;
			}
		}
	}

	var blacklist = form.querySelector("[name=blacklist]").value.split(",").map(function (i) {
		return i.trim();
	});

	// Apply new fonts and activate extension
	chrome.storage.local.set({
		fonts: newFonts,
		blacklist: blacklist
	}, function () {
		updateStatus(true, true);
	});

	syncVariableValues();
}

// Keep track of file data, and hook up to rest
// of form data on submit
function grabFont(e) {
	var files = e.dataTransfer ? e.dataTransfer.files : e.target.files;
	var file = files[0]; // Only use first file if multiple are dropped
	var name = file.name;
	var parent = e.target.closest("fieldset");
	var fontId = parent.dataset.fontid;

	parent.classList.remove("highlight");

	// Check if filetype is allowed
	var allowedExt = ["ttf", "otf", "eot", "woff", "woff2"];
	var ext = name.split(".").pop().toLowerCase();
	if (!allowedExt.includes(ext)) {
		return false;
	}

	var reader = new FileReader();
	reader.onload = function (_ref6) {
		var target = _ref6.target;

		// Stick new file in storage
		chrome.storage.local.get("files", function (_ref7) {
			var files = _ref7.files;

			files[name] = {};
			files[name].file = target.result;
			files[name].name = name;
			files[name].axes = {};

			chrome.storage.local.set({
				files: files
			}, function () {
				parent.querySelector(".font-name-title").innerText = name;
				// Update dropdown
				updateFontDropdowns(name, name);
				var dropdown = document.querySelector("#file" + fontId);
				dropdown.value = name;

				// Font is saved, add variable axes, if any
				grabVariableData(file, parent);

				// Note that we might save with the wrong axes here,
				// as the grabVariableData function might save
				saveForm();
			});
		});
	};
	reader.readAsDataURL(file);
}

// Analyse a *new* font for variable axes, create form inputs
function grabVariableData(file, parent) {
	var font = false;

	parent.querySelector(".variable-sliders-container").classList.remove("show");

	(0, _blobToBuffer2.default)(file, function (_error, buffer) {
		try {
			font = _fontkit2.default.create(buffer);

			var _axes2 = addVariableSliders(font.variationAxes, parent);
			addNamedInstances(font.namedVariations, parent);

			// Save form again, now with proper axes
			saveForm();

			chrome.storage.local.get("files", function (_ref8) {
				var files = _ref8.files;

				files[file.name].axes = _axes2;
				files[file.name].instances = font.namedVariations;

				chrome.storage.local.set({
					files: files
				});
			});
		} catch (e) {
			console.log("Failed to parse font.");
		}
	});
}

function addSlider(axis, parent) {
	var variableSliders = parent.querySelector(".variable-sliders");
	var template = document.querySelector("#variableSlider");
	var el = document.importNode(template.content, true);

	var input = el.querySelector("input");
	var label = el.querySelector("label");
	var value = el.querySelector(".slider-value");

	label.innerText = axis.name;

	input.name = "var-" + axis.id;
	input.min = axis.min;
	input.max = axis.max;
	input.value = axis.value;
	input.dataset.name = axis.name;
	value.innerText = axis.value;

	input.oninput = function (e) {
		value.innerText = e.target.value;
		// Move dropdown away from "--inherit--" option to ensure
		// axes/dropdown are synced properly
		parent.querySelector(".select-instance").value = "--axes--";
	};

	variableSliders.append(el);
}

function highlight(e) {
	this.classList.add("highlight");
	e.preventDefault();
	e.stopPropagation();
}

function unhighlight(e) {
	this.classList.remove("highlight");
	e.preventDefault();
	e.stopPropagation();
}

// Initialise popup
showStatus(true);
initForm();

},{"blob-to-buffer":23,"fontkit":165}]},{},[228]);
